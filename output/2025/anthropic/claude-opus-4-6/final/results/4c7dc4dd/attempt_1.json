{"train_results": [{"success": true, "output": "[[0, 0, 0, 0, 0], [6, 2, 2, 2, 2], [2, 0, 0, 0, 0], [2, 0, 0, 0, 0], [2, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "\nimport numpy as np\nfrom scipy.ndimage import label\nfrom collections import Counter, defaultdict\n\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transform an ARC puzzle input grid to produce the output.\n\n    The input contains a repeating diagonal tile pattern as background,\n    with two large rectangular bordered regions overlaid. Each large region \n    contains two smaller bordered rectangles with patterns inside.\n    One large region is a \"demo\" (both small rects have content demonstrating a rule),\n    the other is a \"question\" (one small rect is empty).\n    The output fills the empty rect by applying the learned rule.\n\n    Rules detected: complement, line_fill, checkerboard complement, 4-fold reflection.\n    \"\"\"\n    grid_np = np.array(grid)\n    h, w = grid_np.shape\n\n    # ---- Step 1: Find big rectangles using long horizontal/vertical lines ----\n    def find_border_lines(g, min_len=9):\n        gh, gw = g.shape\n        h_lines = []\n        for r in range(gh):\n            for v in np.unique(g[r]):\n                mask = (g[r] == v)\n                start = None\n                for c in range(gw):\n                    if mask[c]:\n                        if start is None:\n                            start = c\n                    else:\n                        if start is not None:\n                            if c - start >= min_len:\n                                h_lines.append((r, start, c-1, int(v)))\n                            start = None\n                if start is not None and gw - start >= min_len:\n                    h_lines.append((r, start, gw-1, int(v)))\n        v_lines = []\n        for c in range(gw):\n            col = g[:, c]\n            for v in np.unique(col):\n                mask = (col == v)\n                start = None\n                for r in range(gh):\n                    if mask[r]:\n                        if start is None:\n                            start = r\n                    else:\n                        if start is not None:\n                            if r - start >= min_len:\n                                v_lines.append((c, start, r-1, int(v)))\n                            start = None\n                if start is not None and gh - start >= min_len:\n                    v_lines.append((c, start, gh-1, int(v)))\n        return h_lines, v_lines\n\n    def find_big_rects(g):\n        h_lines, v_lines = find_border_lines(g)\n        h_by_val = defaultdict(list)\n        v_by_val = defaultdict(list)\n        for line in h_lines:\n            h_by_val[line[3]].append(line)\n        for line in v_lines:\n            v_by_val[line[3]].append(line)\n        rects = []\n        for val in set(h_by_val.keys()) & set(v_by_val.keys()):\n            hl = h_by_val[val]\n            vl = v_by_val[val]\n            if len(hl) >= 2 and len(vl) >= 2:\n                rows = sorted(set(ln[0] for ln in hl))\n                cols = sorted(set(ln[0] for ln in vl))\n                rects.append({'value': val, 'top': rows[0], 'bottom': rows[-1], 'left': cols[0], 'right': cols[-1]})\n        return rects\n\n    big_rects = find_big_rects(grid_np)\n\n    # ---- Step 2: Find inner rectangles ----\n    def find_outline_rects(g, top, bottom, left, right, min_size=6):\n        results = []\n        for val in np.unique(g[top:bottom+1, left:right+1]):\n            val = int(val)\n            h_segs = []\n            for r in range(top, bottom+1):\n                start = None\n                for c in range(left, right+1):\n                    if g[r, c] == val:\n                        if start is None:\n                            start = c\n                    else:\n                        if start is not None:\n                            if c - start >= min_size:\n                                h_segs.append((r, start, c-1))\n                            start = None\n                if start is not None and right + 1 - start >= min_size:\n                    h_segs.append((r, start, right))\n            if len(h_segs) < 2:\n                continue\n            v_segs = []\n            for c in range(left, right+1):\n                start = None\n                for r in range(top, bottom+1):\n                    if g[r, c] == val:\n                        if start is None:\n                            start = r\n                    else:\n                        if start is not None:\n                            if r - start >= min_size:\n                                v_segs.append((c, start, r-1))\n                            start = None\n                if start is not None and bottom + 1 - start >= min_size:\n                    v_segs.append((c, start, bottom))\n            if len(v_segs) < 2:\n                continue\n            for i, (r1, c1a, c1b) in enumerate(h_segs):\n                for j, (r2, c2a, c2b) in enumerate(h_segs):\n                    if r2 <= r1 + 2:\n                        continue\n                    overlap_start = max(c1a, c2a)\n                    overlap_end = min(c1b, c2b)\n                    if overlap_end - overlap_start < min_size - 1:\n                        continue\n                    left_v = any(c == overlap_start and sr <= r1 and er >= r2 for c, sr, er in v_segs)\n                    right_v = any(c == overlap_end and sr <= r1 and er >= r2 for c, sr, er in v_segs)\n                    if left_v and right_v:\n                        inner = g[r1+1:r2, overlap_start+1:overlap_end]\n                        if inner.size >= 4 and min(inner.shape) >= 2:\n                            if not np.all(inner == val):\n                                results.append({\n                                    'content': inner.copy(),\n                                    'is_empty': bool(np.all(inner == 0)),\n                                    'r1': r1, 'r2': r2, 'c1': overlap_start, 'c2': overlap_end,\n                                    'area': inner.size\n                                })\n        unique = []\n        seen = set()\n        for rect in results:\n            key = (rect['r1'], rect['r2'], rect['c1'], rect['c2'])\n            if key not in seen:\n                seen.add(key)\n                unique.append(rect)\n        unique.sort(key=lambda x: x['area'], reverse=True)\n        selected = []\n        for rect in unique:\n            overlaps = False\n            for sel in selected:\n                if not (rect['r2'] < sel['r1'] or rect['r1'] > sel['r2'] or rect['c2'] < sel['c1'] or rect['c1'] > sel['c2']):\n                    overlaps = True\n                    break\n            if not overlaps:\n                selected.append(rect)\n            if len(selected) == 2:\n                break\n        return selected\n\n    all_inner = {}\n    for bi, br in enumerate(big_rects):\n        rects = find_outline_rects(grid_np, br['top']+1, br['bottom']-1, br['left']+1, br['right']-1)\n        all_inner[bi] = rects\n\n    # ---- Step 3: Identify demo and question pairs ----\n    demo_pair = None\n    question_input = None\n    for bi, rects in all_inner.items():\n        if len(rects) != 2:\n            continue\n        empty_count = sum(1 for r in rects if r['is_empty'])\n        if empty_count == 0:\n            demo_pair = (rects[0]['content'], rects[1]['content'])\n        elif empty_count == 1:\n            for r in rects:\n                if not r['is_empty']:\n                    question_input = r['content']\n\n    if demo_pair is None or question_input is None:\n        raise ValueError(\"Could not identify demo and question pairs\")\n\n    demo_a, demo_b = demo_pair\n    h_inner, w_inner = demo_a.shape\n\n    # ---- Step 4: Rule helpers ----\n    def line_fill(g, fill_color):\n        result = g.copy()\n        h, w = g.shape\n        for r in range(h):\n            nz = [c for c in range(w) if g[r, c] != 0]\n            if len(nz) >= 2:\n                for i in range(len(nz) - 1):\n                    for c in range(nz[i]+1, nz[i+1]):\n                        if result[r, c] == 0:\n                            result[r, c] = fill_color\n        for c in range(w):\n            nz = [r for r in range(h) if g[r, c] != 0]\n            if len(nz) >= 2:\n                for i in range(len(nz) - 1):\n                    for r in range(nz[i]+1, nz[i+1]):\n                        if result[r, c] == 0:\n                            result[r, c] = fill_color\n        return result\n\n    def complement(g, fill_color):\n        result = g.copy()\n        result[g == 0] = fill_color\n        result[g == fill_color] = 0\n        return result\n\n    all_vals = set(int(v) for v in np.unique(demo_a)) | set(int(v) for v in np.unique(demo_b))\n\n    # ---- Rule 1: Simple Complement ----\n    for fv in all_vals:\n        if fv == 0:\n            continue\n        ca = np.where(demo_a == 0, fv, np.where(demo_a == fv, 0, demo_a))\n        if np.array_equal(ca, demo_b):\n            qv = set(int(v) for v in np.unique(question_input)) - {0}\n            qf = int(Counter(question_input[question_input != 0].flatten()).most_common(1)[0][0]) if qv else fv\n            return complement(question_input, qf).tolist()\n        cb = np.where(demo_b == 0, fv, np.where(demo_b == fv, 0, demo_b))\n        if np.array_equal(cb, demo_a):\n            qv = set(int(v) for v in np.unique(question_input)) - {0}\n            qf = int(Counter(question_input[question_input != 0].flatten()).most_common(1)[0][0]) if qv else fv\n            return complement(question_input, qf).tolist()\n\n    # ---- Rule 2: Line Fill ----\n    for fv in all_vals:\n        if fv == 0:\n            continue\n        for sparse, filled in [(demo_a, demo_b), (demo_b, demo_a)]:\n            lf = line_fill(sparse, fv)\n            if np.array_equal(lf, filled):\n                qv = set(int(v) for v in np.unique(question_input)) - {0}\n                if qv:\n                    qf = int(Counter(question_input[question_input != 0].flatten()).most_common(1)[0][0])\n                else:\n                    qf = fv\n                return line_fill(question_input, qf).tolist()\n\n    # ---- Rule 3: Checkerboard Complement ----\n    for sparse, filled in [(demo_a, demo_b), (demo_b, demo_a)]:\n        ms0 = (sparse == 0)\n        mf0 = (filled == 0)\n        if np.array_equal(ms0, ~mf0):\n            ev, ov = set(), set()\n            for r in range(h_inner):\n                for c in range(w_inner):\n                    if filled[r,c] != 0 and sparse[r,c] == 0:\n                        if (r+c) % 2 == 0:\n                            ev.add(int(filled[r,c]))\n                        else:\n                            ov.add(int(filled[r,c]))\n            if len(ev) == 1 and len(ov) == 1:\n                ve, vo = ev.pop(), ov.pop()\n                if ve != vo:\n                    qe = qo = None\n                    for r in range(h_inner):\n                        for c in range(w_inner):\n                            if question_input[r,c] != 0:\n                                if (r+c) % 2 == 0:\n                                    qe = int(question_input[r,c])\n                                else:\n                                    qo = int(question_input[r,c])\n                    if qe is not None and qo is not None:\n                        result = np.zeros_like(question_input)\n                        for r in range(h_inner):\n                            for c in range(w_inner):\n                                if question_input[r,c] == 0:\n                                    result[r,c] = qe if (r+c) % 2 == 0 else qo\n                        return result.tolist()\n\n    # ---- Rule 4: 4-fold Reflection ----\n    az = np.sum(demo_a == 0)\n    bz = np.sum(demo_b == 0)\n    sparse = demo_a if az > bz else demo_b\n    filled = demo_b if az > bz else demo_a\n    fc = Counter(filled.flatten())\n    fv = int(max(fc, key=fc.get))\n    sm = list(zip(*np.where(sparse != 0)))\n    if sm:\n        sr = [p[0] for p in sm]\n        sc = [p[1] for p in sm]\n        mnr, mxr = min(sr), max(sr)\n        mnc, mxc = min(sc), max(sc)\n        bh, bw = mxr - mnr + 1, mxc - mnc + 1\n        cr, cc = (h_inner-1)/2, (w_inner-1)/2\n        bcr, bcc = (mnr + mxr) / 2, (mnc + mxc) / 2\n        if bcr < cr and bcc < cc:\n            block = sparse[0:bh, 0:bw]\n        elif bcr < cr:\n            block = sparse[0:bh, w_inner-bw:w_inner]\n            block = np.fliplr(block)\n        elif bcc < cc:\n            block = sparse[h_inner-bh:h_inner, 0:bw]\n            block = np.flipud(block)\n        else:\n            block = sparse[h_inner-bh:h_inner, w_inner-bw:w_inner]\n            block = np.flipud(np.fliplr(block))\n        tl = block\n        reconstructed = np.full((h_inner, w_inner), fv, dtype=int)\n        reconstructed[0:bh, 0:bw] = tl\n        reconstructed[0:bh, w_inner-bw:w_inner] = np.fliplr(tl)\n        reconstructed[h_inner-bh:h_inner, 0:bw] = np.flipud(tl)\n        reconstructed[h_inner-bh:h_inner, w_inner-bw:w_inner] = np.flipud(np.fliplr(tl))\n        if np.array_equal(reconstructed, filled):\n            qm = list(zip(*np.where(question_input != 0)))\n            if qm:\n                qr = [p[0] for p in qm]\n                qc = [p[1] for p in qm]\n                qmnr, qmxr = min(qr), max(qr)\n                qmnc, qmxc = min(qc), max(qc)\n                qbh, qbw = qmxr - qmnr + 1, qmxc - qmnc + 1\n                qcr, qcc = (qmnr + qmxr) / 2, (qmnc + qmxc) / 2\n                if qcr < cr and qcc < cc:\n                    qblock = question_input[0:qbh, 0:qbw]\n                elif qcr < cr:\n                    qblock = np.fliplr(question_input[0:qbh, w_inner-qbw:w_inner])\n                elif qcc < cc:\n                    qblock = np.flipud(question_input[h_inner-qbh:h_inner, 0:qbw])\n                else:\n                    qblock = np.flipud(np.fliplr(question_input[h_inner-qbh:h_inner, w_inner-qbw:w_inner]))\n                result = np.zeros((h_inner, w_inner), dtype=int)\n                result[0:qbh, 0:qbw] = qblock\n                result[0:qbh, w_inner-qbw:w_inner] = np.fliplr(qblock)\n                result[h_inner-qbh:h_inner, 0:qbw] = np.flipud(qblock)\n                result[h_inner-qbh:h_inner, w_inner-qbw:w_inner] = np.flipud(np.fliplr(qblock))\n                return result.tolist()\n\n    raise ValueError(\"No matching rule found!\")\n"}, {"success": true, "output": "[[2, 2, 0, 2], [0, 0, 0, 2], [2, 2, 2, 2], [2, 0, 0, 2]]", "soft_score": 1.0, "error": null, "code": "\nimport numpy as np\nfrom scipy.ndimage import label\nfrom collections import Counter, defaultdict\n\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transform an ARC puzzle input grid to produce the output.\n\n    The input contains a repeating diagonal tile pattern as background,\n    with two large rectangular bordered regions overlaid. Each large region \n    contains two smaller bordered rectangles with patterns inside.\n    One large region is a \"demo\" (both small rects have content demonstrating a rule),\n    the other is a \"question\" (one small rect is empty).\n    The output fills the empty rect by applying the learned rule.\n\n    Rules detected: complement, line_fill, checkerboard complement, 4-fold reflection.\n    \"\"\"\n    grid_np = np.array(grid)\n    h, w = grid_np.shape\n\n    # ---- Step 1: Find big rectangles using long horizontal/vertical lines ----\n    def find_border_lines(g, min_len=9):\n        gh, gw = g.shape\n        h_lines = []\n        for r in range(gh):\n            for v in np.unique(g[r]):\n                mask = (g[r] == v)\n                start = None\n                for c in range(gw):\n                    if mask[c]:\n                        if start is None:\n                            start = c\n                    else:\n                        if start is not None:\n                            if c - start >= min_len:\n                                h_lines.append((r, start, c-1, int(v)))\n                            start = None\n                if start is not None and gw - start >= min_len:\n                    h_lines.append((r, start, gw-1, int(v)))\n        v_lines = []\n        for c in range(gw):\n            col = g[:, c]\n            for v in np.unique(col):\n                mask = (col == v)\n                start = None\n                for r in range(gh):\n                    if mask[r]:\n                        if start is None:\n                            start = r\n                    else:\n                        if start is not None:\n                            if r - start >= min_len:\n                                v_lines.append((c, start, r-1, int(v)))\n                            start = None\n                if start is not None and gh - start >= min_len:\n                    v_lines.append((c, start, gh-1, int(v)))\n        return h_lines, v_lines\n\n    def find_big_rects(g):\n        h_lines, v_lines = find_border_lines(g)\n        h_by_val = defaultdict(list)\n        v_by_val = defaultdict(list)\n        for line in h_lines:\n            h_by_val[line[3]].append(line)\n        for line in v_lines:\n            v_by_val[line[3]].append(line)\n        rects = []\n        for val in set(h_by_val.keys()) & set(v_by_val.keys()):\n            hl = h_by_val[val]\n            vl = v_by_val[val]\n            if len(hl) >= 2 and len(vl) >= 2:\n                rows = sorted(set(ln[0] for ln in hl))\n                cols = sorted(set(ln[0] for ln in vl))\n                rects.append({'value': val, 'top': rows[0], 'bottom': rows[-1], 'left': cols[0], 'right': cols[-1]})\n        return rects\n\n    big_rects = find_big_rects(grid_np)\n\n    # ---- Step 2: Find inner rectangles ----\n    def find_outline_rects(g, top, bottom, left, right, min_size=6):\n        results = []\n        for val in np.unique(g[top:bottom+1, left:right+1]):\n            val = int(val)\n            h_segs = []\n            for r in range(top, bottom+1):\n                start = None\n                for c in range(left, right+1):\n                    if g[r, c] == val:\n                        if start is None:\n                            start = c\n                    else:\n                        if start is not None:\n                            if c - start >= min_size:\n                                h_segs.append((r, start, c-1))\n                            start = None\n                if start is not None and right + 1 - start >= min_size:\n                    h_segs.append((r, start, right))\n            if len(h_segs) < 2:\n                continue\n            v_segs = []\n            for c in range(left, right+1):\n                start = None\n                for r in range(top, bottom+1):\n                    if g[r, c] == val:\n                        if start is None:\n                            start = r\n                    else:\n                        if start is not None:\n                            if r - start >= min_size:\n                                v_segs.append((c, start, r-1))\n                            start = None\n                if start is not None and bottom + 1 - start >= min_size:\n                    v_segs.append((c, start, bottom))\n            if len(v_segs) < 2:\n                continue\n            for i, (r1, c1a, c1b) in enumerate(h_segs):\n                for j, (r2, c2a, c2b) in enumerate(h_segs):\n                    if r2 <= r1 + 2:\n                        continue\n                    overlap_start = max(c1a, c2a)\n                    overlap_end = min(c1b, c2b)\n                    if overlap_end - overlap_start < min_size - 1:\n                        continue\n                    left_v = any(c == overlap_start and sr <= r1 and er >= r2 for c, sr, er in v_segs)\n                    right_v = any(c == overlap_end and sr <= r1 and er >= r2 for c, sr, er in v_segs)\n                    if left_v and right_v:\n                        inner = g[r1+1:r2, overlap_start+1:overlap_end]\n                        if inner.size >= 4 and min(inner.shape) >= 2:\n                            if not np.all(inner == val):\n                                results.append({\n                                    'content': inner.copy(),\n                                    'is_empty': bool(np.all(inner == 0)),\n                                    'r1': r1, 'r2': r2, 'c1': overlap_start, 'c2': overlap_end,\n                                    'area': inner.size\n                                })\n        unique = []\n        seen = set()\n        for rect in results:\n            key = (rect['r1'], rect['r2'], rect['c1'], rect['c2'])\n            if key not in seen:\n                seen.add(key)\n                unique.append(rect)\n        unique.sort(key=lambda x: x['area'], reverse=True)\n        selected = []\n        for rect in unique:\n            overlaps = False\n            for sel in selected:\n                if not (rect['r2'] < sel['r1'] or rect['r1'] > sel['r2'] or rect['c2'] < sel['c1'] or rect['c1'] > sel['c2']):\n                    overlaps = True\n                    break\n            if not overlaps:\n                selected.append(rect)\n            if len(selected) == 2:\n                break\n        return selected\n\n    all_inner = {}\n    for bi, br in enumerate(big_rects):\n        rects = find_outline_rects(grid_np, br['top']+1, br['bottom']-1, br['left']+1, br['right']-1)\n        all_inner[bi] = rects\n\n    # ---- Step 3: Identify demo and question pairs ----\n    demo_pair = None\n    question_input = None\n    for bi, rects in all_inner.items():\n        if len(rects) != 2:\n            continue\n        empty_count = sum(1 for r in rects if r['is_empty'])\n        if empty_count == 0:\n            demo_pair = (rects[0]['content'], rects[1]['content'])\n        elif empty_count == 1:\n            for r in rects:\n                if not r['is_empty']:\n                    question_input = r['content']\n\n    if demo_pair is None or question_input is None:\n        raise ValueError(\"Could not identify demo and question pairs\")\n\n    demo_a, demo_b = demo_pair\n    h_inner, w_inner = demo_a.shape\n\n    # ---- Step 4: Rule helpers ----\n    def line_fill(g, fill_color):\n        result = g.copy()\n        h, w = g.shape\n        for r in range(h):\n            nz = [c for c in range(w) if g[r, c] != 0]\n            if len(nz) >= 2:\n                for i in range(len(nz) - 1):\n                    for c in range(nz[i]+1, nz[i+1]):\n                        if result[r, c] == 0:\n                            result[r, c] = fill_color\n        for c in range(w):\n            nz = [r for r in range(h) if g[r, c] != 0]\n            if len(nz) >= 2:\n                for i in range(len(nz) - 1):\n                    for r in range(nz[i]+1, nz[i+1]):\n                        if result[r, c] == 0:\n                            result[r, c] = fill_color\n        return result\n\n    def complement(g, fill_color):\n        result = g.copy()\n        result[g == 0] = fill_color\n        result[g == fill_color] = 0\n        return result\n\n    all_vals = set(int(v) for v in np.unique(demo_a)) | set(int(v) for v in np.unique(demo_b))\n\n    # ---- Rule 1: Simple Complement ----\n    for fv in all_vals:\n        if fv == 0:\n            continue\n        ca = np.where(demo_a == 0, fv, np.where(demo_a == fv, 0, demo_a))\n        if np.array_equal(ca, demo_b):\n            qv = set(int(v) for v in np.unique(question_input)) - {0}\n            qf = int(Counter(question_input[question_input != 0].flatten()).most_common(1)[0][0]) if qv else fv\n            return complement(question_input, qf).tolist()\n        cb = np.where(demo_b == 0, fv, np.where(demo_b == fv, 0, demo_b))\n        if np.array_equal(cb, demo_a):\n            qv = set(int(v) for v in np.unique(question_input)) - {0}\n            qf = int(Counter(question_input[question_input != 0].flatten()).most_common(1)[0][0]) if qv else fv\n            return complement(question_input, qf).tolist()\n\n    # ---- Rule 2: Line Fill ----\n    for fv in all_vals:\n        if fv == 0:\n            continue\n        for sparse, filled in [(demo_a, demo_b), (demo_b, demo_a)]:\n            lf = line_fill(sparse, fv)\n            if np.array_equal(lf, filled):\n                qv = set(int(v) for v in np.unique(question_input)) - {0}\n                if qv:\n                    qf = int(Counter(question_input[question_input != 0].flatten()).most_common(1)[0][0])\n                else:\n                    qf = fv\n                return line_fill(question_input, qf).tolist()\n\n    # ---- Rule 3: Checkerboard Complement ----\n    for sparse, filled in [(demo_a, demo_b), (demo_b, demo_a)]:\n        ms0 = (sparse == 0)\n        mf0 = (filled == 0)\n        if np.array_equal(ms0, ~mf0):\n            ev, ov = set(), set()\n            for r in range(h_inner):\n                for c in range(w_inner):\n                    if filled[r,c] != 0 and sparse[r,c] == 0:\n                        if (r+c) % 2 == 0:\n                            ev.add(int(filled[r,c]))\n                        else:\n                            ov.add(int(filled[r,c]))\n            if len(ev) == 1 and len(ov) == 1:\n                ve, vo = ev.pop(), ov.pop()\n                if ve != vo:\n                    qe = qo = None\n                    for r in range(h_inner):\n                        for c in range(w_inner):\n                            if question_input[r,c] != 0:\n                                if (r+c) % 2 == 0:\n                                    qe = int(question_input[r,c])\n                                else:\n                                    qo = int(question_input[r,c])\n                    if qe is not None and qo is not None:\n                        result = np.zeros_like(question_input)\n                        for r in range(h_inner):\n                            for c in range(w_inner):\n                                if question_input[r,c] == 0:\n                                    result[r,c] = qe if (r+c) % 2 == 0 else qo\n                        return result.tolist()\n\n    # ---- Rule 4: 4-fold Reflection ----\n    az = np.sum(demo_a == 0)\n    bz = np.sum(demo_b == 0)\n    sparse = demo_a if az > bz else demo_b\n    filled = demo_b if az > bz else demo_a\n    fc = Counter(filled.flatten())\n    fv = int(max(fc, key=fc.get))\n    sm = list(zip(*np.where(sparse != 0)))\n    if sm:\n        sr = [p[0] for p in sm]\n        sc = [p[1] for p in sm]\n        mnr, mxr = min(sr), max(sr)\n        mnc, mxc = min(sc), max(sc)\n        bh, bw = mxr - mnr + 1, mxc - mnc + 1\n        cr, cc = (h_inner-1)/2, (w_inner-1)/2\n        bcr, bcc = (mnr + mxr) / 2, (mnc + mxc) / 2\n        if bcr < cr and bcc < cc:\n            block = sparse[0:bh, 0:bw]\n        elif bcr < cr:\n            block = sparse[0:bh, w_inner-bw:w_inner]\n            block = np.fliplr(block)\n        elif bcc < cc:\n            block = sparse[h_inner-bh:h_inner, 0:bw]\n            block = np.flipud(block)\n        else:\n            block = sparse[h_inner-bh:h_inner, w_inner-bw:w_inner]\n            block = np.flipud(np.fliplr(block))\n        tl = block\n        reconstructed = np.full((h_inner, w_inner), fv, dtype=int)\n        reconstructed[0:bh, 0:bw] = tl\n        reconstructed[0:bh, w_inner-bw:w_inner] = np.fliplr(tl)\n        reconstructed[h_inner-bh:h_inner, 0:bw] = np.flipud(tl)\n        reconstructed[h_inner-bh:h_inner, w_inner-bw:w_inner] = np.flipud(np.fliplr(tl))\n        if np.array_equal(reconstructed, filled):\n            qm = list(zip(*np.where(question_input != 0)))\n            if qm:\n                qr = [p[0] for p in qm]\n                qc = [p[1] for p in qm]\n                qmnr, qmxr = min(qr), max(qr)\n                qmnc, qmxc = min(qc), max(qc)\n                qbh, qbw = qmxr - qmnr + 1, qmxc - qmnc + 1\n                qcr, qcc = (qmnr + qmxr) / 2, (qmnc + qmxc) / 2\n                if qcr < cr and qcc < cc:\n                    qblock = question_input[0:qbh, 0:qbw]\n                elif qcr < cr:\n                    qblock = np.fliplr(question_input[0:qbh, w_inner-qbw:w_inner])\n                elif qcc < cc:\n                    qblock = np.flipud(question_input[h_inner-qbh:h_inner, 0:qbw])\n                else:\n                    qblock = np.flipud(np.fliplr(question_input[h_inner-qbh:h_inner, w_inner-qbw:w_inner]))\n                result = np.zeros((h_inner, w_inner), dtype=int)\n                result[0:qbh, 0:qbw] = qblock\n                result[0:qbh, w_inner-qbw:w_inner] = np.fliplr(qblock)\n                result[h_inner-qbh:h_inner, 0:qbw] = np.flipud(qblock)\n                result[h_inner-qbh:h_inner, w_inner-qbw:w_inner] = np.flipud(np.fliplr(qblock))\n                return result.tolist()\n\n    raise ValueError(\"No matching rule found!\")\n"}], "test_results": [{"success": false, "output": "[[2, 4, 2, 4, 2], [4, 2, 0, 2, 4], [2, 0, 0, 0, 2], [4, 2, 0, 2, 4], [2, 4, 2, 4, 2]]", "soft_score": 0.0, "error": null, "code": "\nimport numpy as np\nfrom scipy.ndimage import label\nfrom collections import Counter, defaultdict\n\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transform an ARC puzzle input grid to produce the output.\n\n    The input contains a repeating diagonal tile pattern as background,\n    with two large rectangular bordered regions overlaid. Each large region \n    contains two smaller bordered rectangles with patterns inside.\n    One large region is a \"demo\" (both small rects have content demonstrating a rule),\n    the other is a \"question\" (one small rect is empty).\n    The output fills the empty rect by applying the learned rule.\n\n    Rules detected: complement, line_fill, checkerboard complement, 4-fold reflection.\n    \"\"\"\n    grid_np = np.array(grid)\n    h, w = grid_np.shape\n\n    # ---- Step 1: Find big rectangles using long horizontal/vertical lines ----\n    def find_border_lines(g, min_len=9):\n        gh, gw = g.shape\n        h_lines = []\n        for r in range(gh):\n            for v in np.unique(g[r]):\n                mask = (g[r] == v)\n                start = None\n                for c in range(gw):\n                    if mask[c]:\n                        if start is None:\n                            start = c\n                    else:\n                        if start is not None:\n                            if c - start >= min_len:\n                                h_lines.append((r, start, c-1, int(v)))\n                            start = None\n                if start is not None and gw - start >= min_len:\n                    h_lines.append((r, start, gw-1, int(v)))\n        v_lines = []\n        for c in range(gw):\n            col = g[:, c]\n            for v in np.unique(col):\n                mask = (col == v)\n                start = None\n                for r in range(gh):\n                    if mask[r]:\n                        if start is None:\n                            start = r\n                    else:\n                        if start is not None:\n                            if r - start >= min_len:\n                                v_lines.append((c, start, r-1, int(v)))\n                            start = None\n                if start is not None and gh - start >= min_len:\n                    v_lines.append((c, start, gh-1, int(v)))\n        return h_lines, v_lines\n\n    def find_big_rects(g):\n        h_lines, v_lines = find_border_lines(g)\n        h_by_val = defaultdict(list)\n        v_by_val = defaultdict(list)\n        for line in h_lines:\n            h_by_val[line[3]].append(line)\n        for line in v_lines:\n            v_by_val[line[3]].append(line)\n        rects = []\n        for val in set(h_by_val.keys()) & set(v_by_val.keys()):\n            hl = h_by_val[val]\n            vl = v_by_val[val]\n            if len(hl) >= 2 and len(vl) >= 2:\n                rows = sorted(set(ln[0] for ln in hl))\n                cols = sorted(set(ln[0] for ln in vl))\n                rects.append({'value': val, 'top': rows[0], 'bottom': rows[-1], 'left': cols[0], 'right': cols[-1]})\n        return rects\n\n    big_rects = find_big_rects(grid_np)\n\n    # ---- Step 2: Find inner rectangles ----\n    def find_outline_rects(g, top, bottom, left, right, min_size=6):\n        results = []\n        for val in np.unique(g[top:bottom+1, left:right+1]):\n            val = int(val)\n            h_segs = []\n            for r in range(top, bottom+1):\n                start = None\n                for c in range(left, right+1):\n                    if g[r, c] == val:\n                        if start is None:\n                            start = c\n                    else:\n                        if start is not None:\n                            if c - start >= min_size:\n                                h_segs.append((r, start, c-1))\n                            start = None\n                if start is not None and right + 1 - start >= min_size:\n                    h_segs.append((r, start, right))\n            if len(h_segs) < 2:\n                continue\n            v_segs = []\n            for c in range(left, right+1):\n                start = None\n                for r in range(top, bottom+1):\n                    if g[r, c] == val:\n                        if start is None:\n                            start = r\n                    else:\n                        if start is not None:\n                            if r - start >= min_size:\n                                v_segs.append((c, start, r-1))\n                            start = None\n                if start is not None and bottom + 1 - start >= min_size:\n                    v_segs.append((c, start, bottom))\n            if len(v_segs) < 2:\n                continue\n            for i, (r1, c1a, c1b) in enumerate(h_segs):\n                for j, (r2, c2a, c2b) in enumerate(h_segs):\n                    if r2 <= r1 + 2:\n                        continue\n                    overlap_start = max(c1a, c2a)\n                    overlap_end = min(c1b, c2b)\n                    if overlap_end - overlap_start < min_size - 1:\n                        continue\n                    left_v = any(c == overlap_start and sr <= r1 and er >= r2 for c, sr, er in v_segs)\n                    right_v = any(c == overlap_end and sr <= r1 and er >= r2 for c, sr, er in v_segs)\n                    if left_v and right_v:\n                        inner = g[r1+1:r2, overlap_start+1:overlap_end]\n                        if inner.size >= 4 and min(inner.shape) >= 2:\n                            if not np.all(inner == val):\n                                results.append({\n                                    'content': inner.copy(),\n                                    'is_empty': bool(np.all(inner == 0)),\n                                    'r1': r1, 'r2': r2, 'c1': overlap_start, 'c2': overlap_end,\n                                    'area': inner.size\n                                })\n        unique = []\n        seen = set()\n        for rect in results:\n            key = (rect['r1'], rect['r2'], rect['c1'], rect['c2'])\n            if key not in seen:\n                seen.add(key)\n                unique.append(rect)\n        unique.sort(key=lambda x: x['area'], reverse=True)\n        selected = []\n        for rect in unique:\n            overlaps = False\n            for sel in selected:\n                if not (rect['r2'] < sel['r1'] or rect['r1'] > sel['r2'] or rect['c2'] < sel['c1'] or rect['c1'] > sel['c2']):\n                    overlaps = True\n                    break\n            if not overlaps:\n                selected.append(rect)\n            if len(selected) == 2:\n                break\n        return selected\n\n    all_inner = {}\n    for bi, br in enumerate(big_rects):\n        rects = find_outline_rects(grid_np, br['top']+1, br['bottom']-1, br['left']+1, br['right']-1)\n        all_inner[bi] = rects\n\n    # ---- Step 3: Identify demo and question pairs ----\n    demo_pair = None\n    question_input = None\n    for bi, rects in all_inner.items():\n        if len(rects) != 2:\n            continue\n        empty_count = sum(1 for r in rects if r['is_empty'])\n        if empty_count == 0:\n            demo_pair = (rects[0]['content'], rects[1]['content'])\n        elif empty_count == 1:\n            for r in rects:\n                if not r['is_empty']:\n                    question_input = r['content']\n\n    if demo_pair is None or question_input is None:\n        raise ValueError(\"Could not identify demo and question pairs\")\n\n    demo_a, demo_b = demo_pair\n    h_inner, w_inner = demo_a.shape\n\n    # ---- Step 4: Rule helpers ----\n    def line_fill(g, fill_color):\n        result = g.copy()\n        h, w = g.shape\n        for r in range(h):\n            nz = [c for c in range(w) if g[r, c] != 0]\n            if len(nz) >= 2:\n                for i in range(len(nz) - 1):\n                    for c in range(nz[i]+1, nz[i+1]):\n                        if result[r, c] == 0:\n                            result[r, c] = fill_color\n        for c in range(w):\n            nz = [r for r in range(h) if g[r, c] != 0]\n            if len(nz) >= 2:\n                for i in range(len(nz) - 1):\n                    for r in range(nz[i]+1, nz[i+1]):\n                        if result[r, c] == 0:\n                            result[r, c] = fill_color\n        return result\n\n    def complement(g, fill_color):\n        result = g.copy()\n        result[g == 0] = fill_color\n        result[g == fill_color] = 0\n        return result\n\n    all_vals = set(int(v) for v in np.unique(demo_a)) | set(int(v) for v in np.unique(demo_b))\n\n    # ---- Rule 1: Simple Complement ----\n    for fv in all_vals:\n        if fv == 0:\n            continue\n        ca = np.where(demo_a == 0, fv, np.where(demo_a == fv, 0, demo_a))\n        if np.array_equal(ca, demo_b):\n            qv = set(int(v) for v in np.unique(question_input)) - {0}\n            qf = int(Counter(question_input[question_input != 0].flatten()).most_common(1)[0][0]) if qv else fv\n            return complement(question_input, qf).tolist()\n        cb = np.where(demo_b == 0, fv, np.where(demo_b == fv, 0, demo_b))\n        if np.array_equal(cb, demo_a):\n            qv = set(int(v) for v in np.unique(question_input)) - {0}\n            qf = int(Counter(question_input[question_input != 0].flatten()).most_common(1)[0][0]) if qv else fv\n            return complement(question_input, qf).tolist()\n\n    # ---- Rule 2: Line Fill ----\n    for fv in all_vals:\n        if fv == 0:\n            continue\n        for sparse, filled in [(demo_a, demo_b), (demo_b, demo_a)]:\n            lf = line_fill(sparse, fv)\n            if np.array_equal(lf, filled):\n                qv = set(int(v) for v in np.unique(question_input)) - {0}\n                if qv:\n                    qf = int(Counter(question_input[question_input != 0].flatten()).most_common(1)[0][0])\n                else:\n                    qf = fv\n                return line_fill(question_input, qf).tolist()\n\n    # ---- Rule 3: Checkerboard Complement ----\n    for sparse, filled in [(demo_a, demo_b), (demo_b, demo_a)]:\n        ms0 = (sparse == 0)\n        mf0 = (filled == 0)\n        if np.array_equal(ms0, ~mf0):\n            ev, ov = set(), set()\n            for r in range(h_inner):\n                for c in range(w_inner):\n                    if filled[r,c] != 0 and sparse[r,c] == 0:\n                        if (r+c) % 2 == 0:\n                            ev.add(int(filled[r,c]))\n                        else:\n                            ov.add(int(filled[r,c]))\n            if len(ev) == 1 and len(ov) == 1:\n                ve, vo = ev.pop(), ov.pop()\n                if ve != vo:\n                    qe = qo = None\n                    for r in range(h_inner):\n                        for c in range(w_inner):\n                            if question_input[r,c] != 0:\n                                if (r+c) % 2 == 0:\n                                    qe = int(question_input[r,c])\n                                else:\n                                    qo = int(question_input[r,c])\n                    if qe is not None and qo is not None:\n                        result = np.zeros_like(question_input)\n                        for r in range(h_inner):\n                            for c in range(w_inner):\n                                if question_input[r,c] == 0:\n                                    result[r,c] = qe if (r+c) % 2 == 0 else qo\n                        return result.tolist()\n\n    # ---- Rule 4: 4-fold Reflection ----\n    az = np.sum(demo_a == 0)\n    bz = np.sum(demo_b == 0)\n    sparse = demo_a if az > bz else demo_b\n    filled = demo_b if az > bz else demo_a\n    fc = Counter(filled.flatten())\n    fv = int(max(fc, key=fc.get))\n    sm = list(zip(*np.where(sparse != 0)))\n    if sm:\n        sr = [p[0] for p in sm]\n        sc = [p[1] for p in sm]\n        mnr, mxr = min(sr), max(sr)\n        mnc, mxc = min(sc), max(sc)\n        bh, bw = mxr - mnr + 1, mxc - mnc + 1\n        cr, cc = (h_inner-1)/2, (w_inner-1)/2\n        bcr, bcc = (mnr + mxr) / 2, (mnc + mxc) / 2\n        if bcr < cr and bcc < cc:\n            block = sparse[0:bh, 0:bw]\n        elif bcr < cr:\n            block = sparse[0:bh, w_inner-bw:w_inner]\n            block = np.fliplr(block)\n        elif bcc < cc:\n            block = sparse[h_inner-bh:h_inner, 0:bw]\n            block = np.flipud(block)\n        else:\n            block = sparse[h_inner-bh:h_inner, w_inner-bw:w_inner]\n            block = np.flipud(np.fliplr(block))\n        tl = block\n        reconstructed = np.full((h_inner, w_inner), fv, dtype=int)\n        reconstructed[0:bh, 0:bw] = tl\n        reconstructed[0:bh, w_inner-bw:w_inner] = np.fliplr(tl)\n        reconstructed[h_inner-bh:h_inner, 0:bw] = np.flipud(tl)\n        reconstructed[h_inner-bh:h_inner, w_inner-bw:w_inner] = np.flipud(np.fliplr(tl))\n        if np.array_equal(reconstructed, filled):\n            qm = list(zip(*np.where(question_input != 0)))\n            if qm:\n                qr = [p[0] for p in qm]\n                qc = [p[1] for p in qm]\n                qmnr, qmxr = min(qr), max(qr)\n                qmnc, qmxc = min(qc), max(qc)\n                qbh, qbw = qmxr - qmnr + 1, qmxc - qmnc + 1\n                qcr, qcc = (qmnr + qmxr) / 2, (qmnc + qmxc) / 2\n                if qcr < cr and qcc < cc:\n                    qblock = question_input[0:qbh, 0:qbw]\n                elif qcr < cr:\n                    qblock = np.fliplr(question_input[0:qbh, w_inner-qbw:w_inner])\n                elif qcc < cc:\n                    qblock = np.flipud(question_input[h_inner-qbh:h_inner, 0:qbw])\n                else:\n                    qblock = np.flipud(np.fliplr(question_input[h_inner-qbh:h_inner, w_inner-qbw:w_inner]))\n                result = np.zeros((h_inner, w_inner), dtype=int)\n                result[0:qbh, 0:qbw] = qblock\n                result[0:qbh, w_inner-qbw:w_inner] = np.fliplr(qblock)\n                result[h_inner-qbh:h_inner, 0:qbw] = np.flipud(qblock)\n                result[h_inner-qbh:h_inner, w_inner-qbw:w_inner] = np.flipud(np.fliplr(qblock))\n                return result.tolist()\n\n    raise ValueError(\"No matching rule found!\")\n"}, {"success": false, "output": "[[0, 8, 0, 0, 8, 0], [8, 6, 0, 0, 6, 8], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 6, 8], [0, 8, 0, 0, 8, 0]]", "soft_score": 0.0, "error": null, "code": "\nimport numpy as np\nfrom scipy.ndimage import label\nfrom collections import Counter, defaultdict\n\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transform an ARC puzzle input grid to produce the output.\n\n    The input contains a repeating diagonal tile pattern as background,\n    with two large rectangular bordered regions overlaid. Each large region \n    contains two smaller bordered rectangles with patterns inside.\n    One large region is a \"demo\" (both small rects have content demonstrating a rule),\n    the other is a \"question\" (one small rect is empty).\n    The output fills the empty rect by applying the learned rule.\n\n    Rules detected: complement, line_fill, checkerboard complement, 4-fold reflection.\n    \"\"\"\n    grid_np = np.array(grid)\n    h, w = grid_np.shape\n\n    # ---- Step 1: Find big rectangles using long horizontal/vertical lines ----\n    def find_border_lines(g, min_len=9):\n        gh, gw = g.shape\n        h_lines = []\n        for r in range(gh):\n            for v in np.unique(g[r]):\n                mask = (g[r] == v)\n                start = None\n                for c in range(gw):\n                    if mask[c]:\n                        if start is None:\n                            start = c\n                    else:\n                        if start is not None:\n                            if c - start >= min_len:\n                                h_lines.append((r, start, c-1, int(v)))\n                            start = None\n                if start is not None and gw - start >= min_len:\n                    h_lines.append((r, start, gw-1, int(v)))\n        v_lines = []\n        for c in range(gw):\n            col = g[:, c]\n            for v in np.unique(col):\n                mask = (col == v)\n                start = None\n                for r in range(gh):\n                    if mask[r]:\n                        if start is None:\n                            start = r\n                    else:\n                        if start is not None:\n                            if r - start >= min_len:\n                                v_lines.append((c, start, r-1, int(v)))\n                            start = None\n                if start is not None and gh - start >= min_len:\n                    v_lines.append((c, start, gh-1, int(v)))\n        return h_lines, v_lines\n\n    def find_big_rects(g):\n        h_lines, v_lines = find_border_lines(g)\n        h_by_val = defaultdict(list)\n        v_by_val = defaultdict(list)\n        for line in h_lines:\n            h_by_val[line[3]].append(line)\n        for line in v_lines:\n            v_by_val[line[3]].append(line)\n        rects = []\n        for val in set(h_by_val.keys()) & set(v_by_val.keys()):\n            hl = h_by_val[val]\n            vl = v_by_val[val]\n            if len(hl) >= 2 and len(vl) >= 2:\n                rows = sorted(set(ln[0] for ln in hl))\n                cols = sorted(set(ln[0] for ln in vl))\n                rects.append({'value': val, 'top': rows[0], 'bottom': rows[-1], 'left': cols[0], 'right': cols[-1]})\n        return rects\n\n    big_rects = find_big_rects(grid_np)\n\n    # ---- Step 2: Find inner rectangles ----\n    def find_outline_rects(g, top, bottom, left, right, min_size=6):\n        results = []\n        for val in np.unique(g[top:bottom+1, left:right+1]):\n            val = int(val)\n            h_segs = []\n            for r in range(top, bottom+1):\n                start = None\n                for c in range(left, right+1):\n                    if g[r, c] == val:\n                        if start is None:\n                            start = c\n                    else:\n                        if start is not None:\n                            if c - start >= min_size:\n                                h_segs.append((r, start, c-1))\n                            start = None\n                if start is not None and right + 1 - start >= min_size:\n                    h_segs.append((r, start, right))\n            if len(h_segs) < 2:\n                continue\n            v_segs = []\n            for c in range(left, right+1):\n                start = None\n                for r in range(top, bottom+1):\n                    if g[r, c] == val:\n                        if start is None:\n                            start = r\n                    else:\n                        if start is not None:\n                            if r - start >= min_size:\n                                v_segs.append((c, start, r-1))\n                            start = None\n                if start is not None and bottom + 1 - start >= min_size:\n                    v_segs.append((c, start, bottom))\n            if len(v_segs) < 2:\n                continue\n            for i, (r1, c1a, c1b) in enumerate(h_segs):\n                for j, (r2, c2a, c2b) in enumerate(h_segs):\n                    if r2 <= r1 + 2:\n                        continue\n                    overlap_start = max(c1a, c2a)\n                    overlap_end = min(c1b, c2b)\n                    if overlap_end - overlap_start < min_size - 1:\n                        continue\n                    left_v = any(c == overlap_start and sr <= r1 and er >= r2 for c, sr, er in v_segs)\n                    right_v = any(c == overlap_end and sr <= r1 and er >= r2 for c, sr, er in v_segs)\n                    if left_v and right_v:\n                        inner = g[r1+1:r2, overlap_start+1:overlap_end]\n                        if inner.size >= 4 and min(inner.shape) >= 2:\n                            if not np.all(inner == val):\n                                results.append({\n                                    'content': inner.copy(),\n                                    'is_empty': bool(np.all(inner == 0)),\n                                    'r1': r1, 'r2': r2, 'c1': overlap_start, 'c2': overlap_end,\n                                    'area': inner.size\n                                })\n        unique = []\n        seen = set()\n        for rect in results:\n            key = (rect['r1'], rect['r2'], rect['c1'], rect['c2'])\n            if key not in seen:\n                seen.add(key)\n                unique.append(rect)\n        unique.sort(key=lambda x: x['area'], reverse=True)\n        selected = []\n        for rect in unique:\n            overlaps = False\n            for sel in selected:\n                if not (rect['r2'] < sel['r1'] or rect['r1'] > sel['r2'] or rect['c2'] < sel['c1'] or rect['c1'] > sel['c2']):\n                    overlaps = True\n                    break\n            if not overlaps:\n                selected.append(rect)\n            if len(selected) == 2:\n                break\n        return selected\n\n    all_inner = {}\n    for bi, br in enumerate(big_rects):\n        rects = find_outline_rects(grid_np, br['top']+1, br['bottom']-1, br['left']+1, br['right']-1)\n        all_inner[bi] = rects\n\n    # ---- Step 3: Identify demo and question pairs ----\n    demo_pair = None\n    question_input = None\n    for bi, rects in all_inner.items():\n        if len(rects) != 2:\n            continue\n        empty_count = sum(1 for r in rects if r['is_empty'])\n        if empty_count == 0:\n            demo_pair = (rects[0]['content'], rects[1]['content'])\n        elif empty_count == 1:\n            for r in rects:\n                if not r['is_empty']:\n                    question_input = r['content']\n\n    if demo_pair is None or question_input is None:\n        raise ValueError(\"Could not identify demo and question pairs\")\n\n    demo_a, demo_b = demo_pair\n    h_inner, w_inner = demo_a.shape\n\n    # ---- Step 4: Rule helpers ----\n    def line_fill(g, fill_color):\n        result = g.copy()\n        h, w = g.shape\n        for r in range(h):\n            nz = [c for c in range(w) if g[r, c] != 0]\n            if len(nz) >= 2:\n                for i in range(len(nz) - 1):\n                    for c in range(nz[i]+1, nz[i+1]):\n                        if result[r, c] == 0:\n                            result[r, c] = fill_color\n        for c in range(w):\n            nz = [r for r in range(h) if g[r, c] != 0]\n            if len(nz) >= 2:\n                for i in range(len(nz) - 1):\n                    for r in range(nz[i]+1, nz[i+1]):\n                        if result[r, c] == 0:\n                            result[r, c] = fill_color\n        return result\n\n    def complement(g, fill_color):\n        result = g.copy()\n        result[g == 0] = fill_color\n        result[g == fill_color] = 0\n        return result\n\n    all_vals = set(int(v) for v in np.unique(demo_a)) | set(int(v) for v in np.unique(demo_b))\n\n    # ---- Rule 1: Simple Complement ----\n    for fv in all_vals:\n        if fv == 0:\n            continue\n        ca = np.where(demo_a == 0, fv, np.where(demo_a == fv, 0, demo_a))\n        if np.array_equal(ca, demo_b):\n            qv = set(int(v) for v in np.unique(question_input)) - {0}\n            qf = int(Counter(question_input[question_input != 0].flatten()).most_common(1)[0][0]) if qv else fv\n            return complement(question_input, qf).tolist()\n        cb = np.where(demo_b == 0, fv, np.where(demo_b == fv, 0, demo_b))\n        if np.array_equal(cb, demo_a):\n            qv = set(int(v) for v in np.unique(question_input)) - {0}\n            qf = int(Counter(question_input[question_input != 0].flatten()).most_common(1)[0][0]) if qv else fv\n            return complement(question_input, qf).tolist()\n\n    # ---- Rule 2: Line Fill ----\n    for fv in all_vals:\n        if fv == 0:\n            continue\n        for sparse, filled in [(demo_a, demo_b), (demo_b, demo_a)]:\n            lf = line_fill(sparse, fv)\n            if np.array_equal(lf, filled):\n                qv = set(int(v) for v in np.unique(question_input)) - {0}\n                if qv:\n                    qf = int(Counter(question_input[question_input != 0].flatten()).most_common(1)[0][0])\n                else:\n                    qf = fv\n                return line_fill(question_input, qf).tolist()\n\n    # ---- Rule 3: Checkerboard Complement ----\n    for sparse, filled in [(demo_a, demo_b), (demo_b, demo_a)]:\n        ms0 = (sparse == 0)\n        mf0 = (filled == 0)\n        if np.array_equal(ms0, ~mf0):\n            ev, ov = set(), set()\n            for r in range(h_inner):\n                for c in range(w_inner):\n                    if filled[r,c] != 0 and sparse[r,c] == 0:\n                        if (r+c) % 2 == 0:\n                            ev.add(int(filled[r,c]))\n                        else:\n                            ov.add(int(filled[r,c]))\n            if len(ev) == 1 and len(ov) == 1:\n                ve, vo = ev.pop(), ov.pop()\n                if ve != vo:\n                    qe = qo = None\n                    for r in range(h_inner):\n                        for c in range(w_inner):\n                            if question_input[r,c] != 0:\n                                if (r+c) % 2 == 0:\n                                    qe = int(question_input[r,c])\n                                else:\n                                    qo = int(question_input[r,c])\n                    if qe is not None and qo is not None:\n                        result = np.zeros_like(question_input)\n                        for r in range(h_inner):\n                            for c in range(w_inner):\n                                if question_input[r,c] == 0:\n                                    result[r,c] = qe if (r+c) % 2 == 0 else qo\n                        return result.tolist()\n\n    # ---- Rule 4: 4-fold Reflection ----\n    az = np.sum(demo_a == 0)\n    bz = np.sum(demo_b == 0)\n    sparse = demo_a if az > bz else demo_b\n    filled = demo_b if az > bz else demo_a\n    fc = Counter(filled.flatten())\n    fv = int(max(fc, key=fc.get))\n    sm = list(zip(*np.where(sparse != 0)))\n    if sm:\n        sr = [p[0] for p in sm]\n        sc = [p[1] for p in sm]\n        mnr, mxr = min(sr), max(sr)\n        mnc, mxc = min(sc), max(sc)\n        bh, bw = mxr - mnr + 1, mxc - mnc + 1\n        cr, cc = (h_inner-1)/2, (w_inner-1)/2\n        bcr, bcc = (mnr + mxr) / 2, (mnc + mxc) / 2\n        if bcr < cr and bcc < cc:\n            block = sparse[0:bh, 0:bw]\n        elif bcr < cr:\n            block = sparse[0:bh, w_inner-bw:w_inner]\n            block = np.fliplr(block)\n        elif bcc < cc:\n            block = sparse[h_inner-bh:h_inner, 0:bw]\n            block = np.flipud(block)\n        else:\n            block = sparse[h_inner-bh:h_inner, w_inner-bw:w_inner]\n            block = np.flipud(np.fliplr(block))\n        tl = block\n        reconstructed = np.full((h_inner, w_inner), fv, dtype=int)\n        reconstructed[0:bh, 0:bw] = tl\n        reconstructed[0:bh, w_inner-bw:w_inner] = np.fliplr(tl)\n        reconstructed[h_inner-bh:h_inner, 0:bw] = np.flipud(tl)\n        reconstructed[h_inner-bh:h_inner, w_inner-bw:w_inner] = np.flipud(np.fliplr(tl))\n        if np.array_equal(reconstructed, filled):\n            qm = list(zip(*np.where(question_input != 0)))\n            if qm:\n                qr = [p[0] for p in qm]\n                qc = [p[1] for p in qm]\n                qmnr, qmxr = min(qr), max(qr)\n                qmnc, qmxc = min(qc), max(qc)\n                qbh, qbw = qmxr - qmnr + 1, qmxc - qmnc + 1\n                qcr, qcc = (qmnr + qmxr) / 2, (qmnc + qmxc) / 2\n                if qcr < cr and qcc < cc:\n                    qblock = question_input[0:qbh, 0:qbw]\n                elif qcr < cr:\n                    qblock = np.fliplr(question_input[0:qbh, w_inner-qbw:w_inner])\n                elif qcc < cc:\n                    qblock = np.flipud(question_input[h_inner-qbh:h_inner, 0:qbw])\n                else:\n                    qblock = np.flipud(np.fliplr(question_input[h_inner-qbh:h_inner, w_inner-qbw:w_inner]))\n                result = np.zeros((h_inner, w_inner), dtype=int)\n                result[0:qbh, 0:qbw] = qblock\n                result[0:qbh, w_inner-qbw:w_inner] = np.fliplr(qblock)\n                result[h_inner-qbh:h_inner, 0:qbw] = np.flipud(qblock)\n                result[h_inner-qbh:h_inner, w_inner-qbw:w_inner] = np.flipud(np.fliplr(qblock))\n                return result.tolist()\n\n    raise ValueError(\"No matching rule found!\")\n"}], "agent_usage": [{"input_tokens": 8934351, "input_tokens_details": {"cached_tokens": 8761604}, "output_tokens": 112410, "output_tokens_details": {"reasoning_tokens": -122}, "total_tokens": 112534, "inference_count": 122, "cache_creation": {"ephemeral_1h_input_tokens": 172623, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 172623, "inference_geo": ["global"], "service_tier": ["standard"]}, {"input_tokens": 5783620, "input_tokens_details": {"cached_tokens": 5671610}, "output_tokens": 71168, "output_tokens_details": {"reasoning_tokens": -108}, "total_tokens": 71278, "inference_count": 108, "cache_creation": {"ephemeral_1h_input_tokens": 111900, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 111900, "inference_geo": ["global"], "service_tier": ["standard"]}], "time_taken": 3243.1761741638184, "num_agents_used": 2, "model": "anthropic/claude-opus-4-6", "reasoning_effort": "high", "error": null, "problem_id": "4c7dc4dd", "attempt_id": 1, "num": 0, "iteration": 122}