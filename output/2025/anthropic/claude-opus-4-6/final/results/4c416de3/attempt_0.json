{"train_results": [{"success": true, "output": "[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 3, 3, 0, 0, 0, 0, 0, 0, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 3, 1, 1, 1, 1, 8, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 1, 3, 1, 1, 8, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 1, 4, 1, 1, 2, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 4, 1, 1, 1, 1, 2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 4, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 4, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1]]", "soft_score": 1.0, "error": null, "code": "\ndef transform(grid):\n    \"\"\"Transform the grid by finding corner decorations on 0-bordered shapes\n    and applying the template pattern to all undecorated corners.\n\n    The grid contains rectangles and L-shapes bordered by 0-cells. Each corner\n    of these shapes can have a colored marker on its inward diagonal. One or more\n    corners already have a full decoration (template) showing the pattern to use.\n    The transformation applies this same pattern (rotated) to all other corners\n    with markers.\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label as scipy_label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    bg = int(np.bincount(grid.flatten()).argmax())\n    output = grid.copy()\n\n    # Step 1: Find all corners of 0-bordered shapes\n    corners_0 = []    # corners where the corner cell is 0\n    endpoints = []     # endpoints of 0-arms (for finding decorated corners)\n    isolated_0 = []    # isolated 0-cells (ring-decorated corners)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0:\n                continue\n            zero_neighbors = []\n            for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 0:\n                    zero_neighbors.append((dr, dc))\n\n            if len(zero_neighbors) == 2:\n                d1, d2 = zero_neighbors\n                if d1[0] * d2[0] + d1[1] * d2[1] == 0:  # perpendicular\n                    inward = (d1[0] + d2[0], d1[1] + d2[1])\n                    corners_0.append((r, c, inward[0], inward[1]))\n            elif len(zero_neighbors) == 1:\n                endpoints.append((r, c, zero_neighbors[0]))\n            elif len(zero_neighbors) == 0:\n                isolated_0.append((r, c))\n\n    # Handle isolated 0-cells (ring-decorated corners)\n    isolated_corners = []\n    for r, c in isolated_0:\n        arm_dirs = []\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            for dist in range(1, 6):\n                nr, nc = r + dist * dr, c + dist * dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    if grid[nr, nc] == 0:\n                        arm_dirs.append((dr, dc))\n                        break\n                    elif grid[nr, nc] == bg:\n                        break\n                else:\n                    break\n        if len(arm_dirs) == 2:\n            d1, d2 = arm_dirs\n            if d1[0] * d2[0] + d1[1] * d2[1] == 0:\n                inward = (d1[0] + d2[0], d1[1] + d2[1])\n                isolated_corners.append((r, c, inward[0], inward[1]))\n\n    # Pair endpoints to find decorated corners (where corner cell is non-0)\n    zero_mask = (grid == 0)\n    labeled_zeros, _ = scipy_label(zero_mask)\n\n    decorated_corners = []\n    used_endpoints = set()\n\n    for i in range(len(endpoints)):\n        if i in used_endpoints:\n            continue\n        r1, c1, d1 = endpoints[i]\n        comp1 = labeled_zeros[r1, c1]\n\n        for j in range(i + 1, len(endpoints)):\n            if j in used_endpoints:\n                continue\n            r2, c2, d2 = endpoints[j]\n\n            if labeled_zeros[r2, c2] != comp1:\n                continue\n            if d1[0] * d2[0] + d1[1] * d2[1] != 0:\n                continue\n\n            cr1, cc1 = r1 - d1[0], c1 - d1[1]\n            cr2, cc2 = r2 - d2[0], c2 - d2[1]\n\n            if cr1 == cr2 and cc1 == cc2:\n                corner_r, corner_c = cr1, cc1\n                if 0 <= corner_r < rows and 0 <= corner_c < cols:\n                    arm1 = (r1 - corner_r, c1 - corner_c)\n                    arm2 = (r2 - corner_r, c2 - corner_c)\n                    inward = (arm1[0] + arm2[0], arm1[1] + arm2[1])\n                    decorated_corners.append((corner_r, corner_c, inward[0], inward[1]))\n                    used_endpoints.add(i)\n                    used_endpoints.add(j)\n                    break\n\n    all_corners = corners_0 + decorated_corners + isolated_corners\n\n    # Step 2: For each corner, find marker and extract template\n    normalized_template = None\n    corner_data = []\n\n    for cr, cc, dr, dc in all_corners:\n        # Find diagonal length to opposite border\n        full_diag = None\n        for d in range(1, max(rows, cols)):\n            mr, mc = cr + d * dr, cc + d * dc\n            if not (0 <= mr < rows and 0 <= mc < cols):\n                break\n            if grid[mr, mc] == 0:\n                full_diag = d\n                break\n\n        max_scan = (full_diag // 2) if full_diag is not None else max(rows, cols)\n        max_scan = max(max_scan, 1)\n\n        # Scan inward diagonal for marker\n        marker_color = None\n        marker_dist = None\n        for d in range(1, max_scan + 1):\n            mr, mc = cr + d * dr, cc + d * dc\n            if not (0 <= mr < rows and 0 <= mc < cols):\n                break\n            val = int(grid[mr, mc])\n            if val == 0:\n                break\n            elif val != bg:\n                if marker_color is None:\n                    marker_color = val\n                    marker_dist = d\n                elif val == marker_color:\n                    marker_dist = d\n                else:\n                    break\n            else:\n                if marker_color is not None:\n                    break\n\n        if marker_color is None:\n            continue\n\n        # Check for existing decoration (template)\n        search_r = marker_dist + 2\n        decoration_cells = []\n        for r in range(max(0, cr - search_r), min(rows, cr + search_r + 1)):\n            for c in range(max(0, cc - search_r), min(cols, cc + search_r + 1)):\n                if int(grid[r, c]) == marker_color:\n                    decoration_cells.append((r - cr, c - cc))\n\n        is_template = len(decoration_cells) > 1\n\n        if is_template and normalized_template is None:\n            normalized_template = set()\n            for r_rel, c_rel in decoration_cells:\n                normalized_template.add((r_rel * dr, c_rel * dc))\n\n        corner_data.append((cr, cc, dr, dc, marker_color, is_template))\n\n    if normalized_template is None:\n        return output.tolist()\n\n    # Step 3: Apply template to all corners with markers\n    for cr, cc, dr, dc, color, is_template in corner_data:\n        for nr, nc in normalized_template:\n            tr = cr + nr * dr\n            tc = cc + nc * dc\n            if 0 <= tr < rows and 0 <= tc < cols:\n                output[tr, tc] = color\n\n    return output.tolist()\n"}, {"success": true, "output": "[[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 1, 0, 1, 0, 0, 0, 4, 0, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 6, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 6, 0, 6, 0, 0, 0, 3, 0, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 6, 6, 8, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 2, 2, 8, 8, 8, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 2, 0, 2, 0, 7, 0, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 2, 2, 8, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 3, 3, 8, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 3, 0, 3, 0, 4, 0, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 3, 3, 8, 8, 8, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]", "soft_score": 1.0, "error": null, "code": "\ndef transform(grid):\n    \"\"\"Transform the grid by finding corner decorations on 0-bordered shapes\n    and applying the template pattern to all undecorated corners.\n\n    The grid contains rectangles and L-shapes bordered by 0-cells. Each corner\n    of these shapes can have a colored marker on its inward diagonal. One or more\n    corners already have a full decoration (template) showing the pattern to use.\n    The transformation applies this same pattern (rotated) to all other corners\n    with markers.\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label as scipy_label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    bg = int(np.bincount(grid.flatten()).argmax())\n    output = grid.copy()\n\n    # Step 1: Find all corners of 0-bordered shapes\n    corners_0 = []    # corners where the corner cell is 0\n    endpoints = []     # endpoints of 0-arms (for finding decorated corners)\n    isolated_0 = []    # isolated 0-cells (ring-decorated corners)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0:\n                continue\n            zero_neighbors = []\n            for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 0:\n                    zero_neighbors.append((dr, dc))\n\n            if len(zero_neighbors) == 2:\n                d1, d2 = zero_neighbors\n                if d1[0] * d2[0] + d1[1] * d2[1] == 0:  # perpendicular\n                    inward = (d1[0] + d2[0], d1[1] + d2[1])\n                    corners_0.append((r, c, inward[0], inward[1]))\n            elif len(zero_neighbors) == 1:\n                endpoints.append((r, c, zero_neighbors[0]))\n            elif len(zero_neighbors) == 0:\n                isolated_0.append((r, c))\n\n    # Handle isolated 0-cells (ring-decorated corners)\n    isolated_corners = []\n    for r, c in isolated_0:\n        arm_dirs = []\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            for dist in range(1, 6):\n                nr, nc = r + dist * dr, c + dist * dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    if grid[nr, nc] == 0:\n                        arm_dirs.append((dr, dc))\n                        break\n                    elif grid[nr, nc] == bg:\n                        break\n                else:\n                    break\n        if len(arm_dirs) == 2:\n            d1, d2 = arm_dirs\n            if d1[0] * d2[0] + d1[1] * d2[1] == 0:\n                inward = (d1[0] + d2[0], d1[1] + d2[1])\n                isolated_corners.append((r, c, inward[0], inward[1]))\n\n    # Pair endpoints to find decorated corners (where corner cell is non-0)\n    zero_mask = (grid == 0)\n    labeled_zeros, _ = scipy_label(zero_mask)\n\n    decorated_corners = []\n    used_endpoints = set()\n\n    for i in range(len(endpoints)):\n        if i in used_endpoints:\n            continue\n        r1, c1, d1 = endpoints[i]\n        comp1 = labeled_zeros[r1, c1]\n\n        for j in range(i + 1, len(endpoints)):\n            if j in used_endpoints:\n                continue\n            r2, c2, d2 = endpoints[j]\n\n            if labeled_zeros[r2, c2] != comp1:\n                continue\n            if d1[0] * d2[0] + d1[1] * d2[1] != 0:\n                continue\n\n            cr1, cc1 = r1 - d1[0], c1 - d1[1]\n            cr2, cc2 = r2 - d2[0], c2 - d2[1]\n\n            if cr1 == cr2 and cc1 == cc2:\n                corner_r, corner_c = cr1, cc1\n                if 0 <= corner_r < rows and 0 <= corner_c < cols:\n                    arm1 = (r1 - corner_r, c1 - corner_c)\n                    arm2 = (r2 - corner_r, c2 - corner_c)\n                    inward = (arm1[0] + arm2[0], arm1[1] + arm2[1])\n                    decorated_corners.append((corner_r, corner_c, inward[0], inward[1]))\n                    used_endpoints.add(i)\n                    used_endpoints.add(j)\n                    break\n\n    all_corners = corners_0 + decorated_corners + isolated_corners\n\n    # Step 2: For each corner, find marker and extract template\n    normalized_template = None\n    corner_data = []\n\n    for cr, cc, dr, dc in all_corners:\n        # Find diagonal length to opposite border\n        full_diag = None\n        for d in range(1, max(rows, cols)):\n            mr, mc = cr + d * dr, cc + d * dc\n            if not (0 <= mr < rows and 0 <= mc < cols):\n                break\n            if grid[mr, mc] == 0:\n                full_diag = d\n                break\n\n        max_scan = (full_diag // 2) if full_diag is not None else max(rows, cols)\n        max_scan = max(max_scan, 1)\n\n        # Scan inward diagonal for marker\n        marker_color = None\n        marker_dist = None\n        for d in range(1, max_scan + 1):\n            mr, mc = cr + d * dr, cc + d * dc\n            if not (0 <= mr < rows and 0 <= mc < cols):\n                break\n            val = int(grid[mr, mc])\n            if val == 0:\n                break\n            elif val != bg:\n                if marker_color is None:\n                    marker_color = val\n                    marker_dist = d\n                elif val == marker_color:\n                    marker_dist = d\n                else:\n                    break\n            else:\n                if marker_color is not None:\n                    break\n\n        if marker_color is None:\n            continue\n\n        # Check for existing decoration (template)\n        search_r = marker_dist + 2\n        decoration_cells = []\n        for r in range(max(0, cr - search_r), min(rows, cr + search_r + 1)):\n            for c in range(max(0, cc - search_r), min(cols, cc + search_r + 1)):\n                if int(grid[r, c]) == marker_color:\n                    decoration_cells.append((r - cr, c - cc))\n\n        is_template = len(decoration_cells) > 1\n\n        if is_template and normalized_template is None:\n            normalized_template = set()\n            for r_rel, c_rel in decoration_cells:\n                normalized_template.add((r_rel * dr, c_rel * dc))\n\n        corner_data.append((cr, cc, dr, dc, marker_color, is_template))\n\n    if normalized_template is None:\n        return output.tolist()\n\n    # Step 3: Apply template to all corners with markers\n    for cr, cc, dr, dc, color, is_template in corner_data:\n        for nr, nc in normalized_template:\n            tr = cr + nr * dr\n            tc = cc + nc * dc\n            if 0 <= tr < rows and 0 <= tc < cols:\n                output[tr, tc] = color\n\n    return output.tolist()\n"}, {"success": true, "output": "[[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2], [2, 2, 1, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2], [2, 1, 1, 0, 0, 0, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2], [2, 2, 0, 1, 2, 3, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2], [2, 2, 0, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 9, 2, 2, 2], [2, 2, 0, 2, 2, 4, 0, 2, 2, 2, 2, 2, 2, 2, 2, 9, 9, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 9, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 8, 2, 2, 2, 2, 2, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 8, 8, 0, 0, 0, 0, 0, 9, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 0, 8, 2, 2, 2, 9, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 0, 3, 2, 2, 2, 8, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 3, 3, 0, 0, 0, 0, 0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]", "soft_score": 1.0, "error": null, "code": "\ndef transform(grid):\n    \"\"\"Transform the grid by finding corner decorations on 0-bordered shapes\n    and applying the template pattern to all undecorated corners.\n\n    The grid contains rectangles and L-shapes bordered by 0-cells. Each corner\n    of these shapes can have a colored marker on its inward diagonal. One or more\n    corners already have a full decoration (template) showing the pattern to use.\n    The transformation applies this same pattern (rotated) to all other corners\n    with markers.\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label as scipy_label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    bg = int(np.bincount(grid.flatten()).argmax())\n    output = grid.copy()\n\n    # Step 1: Find all corners of 0-bordered shapes\n    corners_0 = []    # corners where the corner cell is 0\n    endpoints = []     # endpoints of 0-arms (for finding decorated corners)\n    isolated_0 = []    # isolated 0-cells (ring-decorated corners)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0:\n                continue\n            zero_neighbors = []\n            for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 0:\n                    zero_neighbors.append((dr, dc))\n\n            if len(zero_neighbors) == 2:\n                d1, d2 = zero_neighbors\n                if d1[0] * d2[0] + d1[1] * d2[1] == 0:  # perpendicular\n                    inward = (d1[0] + d2[0], d1[1] + d2[1])\n                    corners_0.append((r, c, inward[0], inward[1]))\n            elif len(zero_neighbors) == 1:\n                endpoints.append((r, c, zero_neighbors[0]))\n            elif len(zero_neighbors) == 0:\n                isolated_0.append((r, c))\n\n    # Handle isolated 0-cells (ring-decorated corners)\n    isolated_corners = []\n    for r, c in isolated_0:\n        arm_dirs = []\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            for dist in range(1, 6):\n                nr, nc = r + dist * dr, c + dist * dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    if grid[nr, nc] == 0:\n                        arm_dirs.append((dr, dc))\n                        break\n                    elif grid[nr, nc] == bg:\n                        break\n                else:\n                    break\n        if len(arm_dirs) == 2:\n            d1, d2 = arm_dirs\n            if d1[0] * d2[0] + d1[1] * d2[1] == 0:\n                inward = (d1[0] + d2[0], d1[1] + d2[1])\n                isolated_corners.append((r, c, inward[0], inward[1]))\n\n    # Pair endpoints to find decorated corners (where corner cell is non-0)\n    zero_mask = (grid == 0)\n    labeled_zeros, _ = scipy_label(zero_mask)\n\n    decorated_corners = []\n    used_endpoints = set()\n\n    for i in range(len(endpoints)):\n        if i in used_endpoints:\n            continue\n        r1, c1, d1 = endpoints[i]\n        comp1 = labeled_zeros[r1, c1]\n\n        for j in range(i + 1, len(endpoints)):\n            if j in used_endpoints:\n                continue\n            r2, c2, d2 = endpoints[j]\n\n            if labeled_zeros[r2, c2] != comp1:\n                continue\n            if d1[0] * d2[0] + d1[1] * d2[1] != 0:\n                continue\n\n            cr1, cc1 = r1 - d1[0], c1 - d1[1]\n            cr2, cc2 = r2 - d2[0], c2 - d2[1]\n\n            if cr1 == cr2 and cc1 == cc2:\n                corner_r, corner_c = cr1, cc1\n                if 0 <= corner_r < rows and 0 <= corner_c < cols:\n                    arm1 = (r1 - corner_r, c1 - corner_c)\n                    arm2 = (r2 - corner_r, c2 - corner_c)\n                    inward = (arm1[0] + arm2[0], arm1[1] + arm2[1])\n                    decorated_corners.append((corner_r, corner_c, inward[0], inward[1]))\n                    used_endpoints.add(i)\n                    used_endpoints.add(j)\n                    break\n\n    all_corners = corners_0 + decorated_corners + isolated_corners\n\n    # Step 2: For each corner, find marker and extract template\n    normalized_template = None\n    corner_data = []\n\n    for cr, cc, dr, dc in all_corners:\n        # Find diagonal length to opposite border\n        full_diag = None\n        for d in range(1, max(rows, cols)):\n            mr, mc = cr + d * dr, cc + d * dc\n            if not (0 <= mr < rows and 0 <= mc < cols):\n                break\n            if grid[mr, mc] == 0:\n                full_diag = d\n                break\n\n        max_scan = (full_diag // 2) if full_diag is not None else max(rows, cols)\n        max_scan = max(max_scan, 1)\n\n        # Scan inward diagonal for marker\n        marker_color = None\n        marker_dist = None\n        for d in range(1, max_scan + 1):\n            mr, mc = cr + d * dr, cc + d * dc\n            if not (0 <= mr < rows and 0 <= mc < cols):\n                break\n            val = int(grid[mr, mc])\n            if val == 0:\n                break\n            elif val != bg:\n                if marker_color is None:\n                    marker_color = val\n                    marker_dist = d\n                elif val == marker_color:\n                    marker_dist = d\n                else:\n                    break\n            else:\n                if marker_color is not None:\n                    break\n\n        if marker_color is None:\n            continue\n\n        # Check for existing decoration (template)\n        search_r = marker_dist + 2\n        decoration_cells = []\n        for r in range(max(0, cr - search_r), min(rows, cr + search_r + 1)):\n            for c in range(max(0, cc - search_r), min(cols, cc + search_r + 1)):\n                if int(grid[r, c]) == marker_color:\n                    decoration_cells.append((r - cr, c - cc))\n\n        is_template = len(decoration_cells) > 1\n\n        if is_template and normalized_template is None:\n            normalized_template = set()\n            for r_rel, c_rel in decoration_cells:\n                normalized_template.add((r_rel * dr, c_rel * dc))\n\n        corner_data.append((cr, cc, dr, dc, marker_color, is_template))\n\n    if normalized_template is None:\n        return output.tolist()\n\n    # Step 3: Apply template to all corners with markers\n    for cr, cc, dr, dc, color, is_template in corner_data:\n        for nr, nc in normalized_template:\n            tr = cr + nr * dr\n            tc = cc + nc * dc\n            if 0 <= tr < rows and 0 <= tc < cols:\n                output[tr, tc] = color\n\n    return output.tolist()\n"}], "test_results": [{"success": false, "output": "[[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 4, 4, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 0, 4, 4, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 0, 4, 3, 3, 3, 0, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 6, 3], [3, 3, 0, 3, 3, 3, 1, 0, 3, 3, 3, 3, 2, 2, 0, 0, 0, 0, 0, 0, 6, 6], [3, 3, 0, 3, 3, 1, 1, 0, 3, 3, 3, 3, 3, 0, 2, 2, 3, 3, 6, 6, 0, 3], [3, 3, 0, 0, 0, 0, 0, 1, 1, 3, 3, 3, 3, 0, 2, 3, 3, 3, 3, 6, 0, 3], [3, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 0, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 0, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 8, 0, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 8, 8, 0, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 8, 8], [3, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 3], [0, 0, 0, 0, 0, 0, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 5, 5, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 5, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]]", "soft_score": 0.0, "error": null, "code": "\ndef transform(grid):\n    \"\"\"Transform the grid by finding corner decorations on 0-bordered shapes\n    and applying the template pattern to all undecorated corners.\n\n    The grid contains rectangles and L-shapes bordered by 0-cells. Each corner\n    of these shapes can have a colored marker on its inward diagonal. One or more\n    corners already have a full decoration (template) showing the pattern to use.\n    The transformation applies this same pattern (rotated) to all other corners\n    with markers.\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label as scipy_label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    bg = int(np.bincount(grid.flatten()).argmax())\n    output = grid.copy()\n\n    # Step 1: Find all corners of 0-bordered shapes\n    corners_0 = []    # corners where the corner cell is 0\n    endpoints = []     # endpoints of 0-arms (for finding decorated corners)\n    isolated_0 = []    # isolated 0-cells (ring-decorated corners)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0:\n                continue\n            zero_neighbors = []\n            for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 0:\n                    zero_neighbors.append((dr, dc))\n\n            if len(zero_neighbors) == 2:\n                d1, d2 = zero_neighbors\n                if d1[0] * d2[0] + d1[1] * d2[1] == 0:  # perpendicular\n                    inward = (d1[0] + d2[0], d1[1] + d2[1])\n                    corners_0.append((r, c, inward[0], inward[1]))\n            elif len(zero_neighbors) == 1:\n                endpoints.append((r, c, zero_neighbors[0]))\n            elif len(zero_neighbors) == 0:\n                isolated_0.append((r, c))\n\n    # Handle isolated 0-cells (ring-decorated corners)\n    isolated_corners = []\n    for r, c in isolated_0:\n        arm_dirs = []\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            for dist in range(1, 6):\n                nr, nc = r + dist * dr, c + dist * dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    if grid[nr, nc] == 0:\n                        arm_dirs.append((dr, dc))\n                        break\n                    elif grid[nr, nc] == bg:\n                        break\n                else:\n                    break\n        if len(arm_dirs) == 2:\n            d1, d2 = arm_dirs\n            if d1[0] * d2[0] + d1[1] * d2[1] == 0:\n                inward = (d1[0] + d2[0], d1[1] + d2[1])\n                isolated_corners.append((r, c, inward[0], inward[1]))\n\n    # Pair endpoints to find decorated corners (where corner cell is non-0)\n    zero_mask = (grid == 0)\n    labeled_zeros, _ = scipy_label(zero_mask)\n\n    decorated_corners = []\n    used_endpoints = set()\n\n    for i in range(len(endpoints)):\n        if i in used_endpoints:\n            continue\n        r1, c1, d1 = endpoints[i]\n        comp1 = labeled_zeros[r1, c1]\n\n        for j in range(i + 1, len(endpoints)):\n            if j in used_endpoints:\n                continue\n            r2, c2, d2 = endpoints[j]\n\n            if labeled_zeros[r2, c2] != comp1:\n                continue\n            if d1[0] * d2[0] + d1[1] * d2[1] != 0:\n                continue\n\n            cr1, cc1 = r1 - d1[0], c1 - d1[1]\n            cr2, cc2 = r2 - d2[0], c2 - d2[1]\n\n            if cr1 == cr2 and cc1 == cc2:\n                corner_r, corner_c = cr1, cc1\n                if 0 <= corner_r < rows and 0 <= corner_c < cols:\n                    arm1 = (r1 - corner_r, c1 - corner_c)\n                    arm2 = (r2 - corner_r, c2 - corner_c)\n                    inward = (arm1[0] + arm2[0], arm1[1] + arm2[1])\n                    decorated_corners.append((corner_r, corner_c, inward[0], inward[1]))\n                    used_endpoints.add(i)\n                    used_endpoints.add(j)\n                    break\n\n    all_corners = corners_0 + decorated_corners + isolated_corners\n\n    # Step 2: For each corner, find marker and extract template\n    normalized_template = None\n    corner_data = []\n\n    for cr, cc, dr, dc in all_corners:\n        # Find diagonal length to opposite border\n        full_diag = None\n        for d in range(1, max(rows, cols)):\n            mr, mc = cr + d * dr, cc + d * dc\n            if not (0 <= mr < rows and 0 <= mc < cols):\n                break\n            if grid[mr, mc] == 0:\n                full_diag = d\n                break\n\n        max_scan = (full_diag // 2) if full_diag is not None else max(rows, cols)\n        max_scan = max(max_scan, 1)\n\n        # Scan inward diagonal for marker\n        marker_color = None\n        marker_dist = None\n        for d in range(1, max_scan + 1):\n            mr, mc = cr + d * dr, cc + d * dc\n            if not (0 <= mr < rows and 0 <= mc < cols):\n                break\n            val = int(grid[mr, mc])\n            if val == 0:\n                break\n            elif val != bg:\n                if marker_color is None:\n                    marker_color = val\n                    marker_dist = d\n                elif val == marker_color:\n                    marker_dist = d\n                else:\n                    break\n            else:\n                if marker_color is not None:\n                    break\n\n        if marker_color is None:\n            continue\n\n        # Check for existing decoration (template)\n        search_r = marker_dist + 2\n        decoration_cells = []\n        for r in range(max(0, cr - search_r), min(rows, cr + search_r + 1)):\n            for c in range(max(0, cc - search_r), min(cols, cc + search_r + 1)):\n                if int(grid[r, c]) == marker_color:\n                    decoration_cells.append((r - cr, c - cc))\n\n        is_template = len(decoration_cells) > 1\n\n        if is_template and normalized_template is None:\n            normalized_template = set()\n            for r_rel, c_rel in decoration_cells:\n                normalized_template.add((r_rel * dr, c_rel * dc))\n\n        corner_data.append((cr, cc, dr, dc, marker_color, is_template))\n\n    if normalized_template is None:\n        return output.tolist()\n\n    # Step 3: Apply template to all corners with markers\n    for cr, cc, dr, dc, color, is_template in corner_data:\n        for nr, nc in normalized_template:\n            tr = cr + nr * dr\n            tc = cc + nc * dc\n            if 0 <= tr < rows and 0 <= tc < cols:\n                output[tr, tc] = color\n\n    return output.tolist()\n"}], "agent_usage": [{"input_tokens": 1039281, "input_tokens_details": {"cached_tokens": 923238}, "output_tokens": 102447, "output_tokens_details": {"reasoning_tokens": -13}, "total_tokens": 102462, "inference_count": 13, "cache_creation": {"ephemeral_1h_input_tokens": 116028, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 116028, "inference_geo": ["global"], "service_tier": ["standard"]}], "time_taken": 2604.1658215522766, "num_agents_used": 1, "model": "anthropic/claude-opus-4-6", "reasoning_effort": "high", "error": null, "problem_id": "4c416de3", "attempt_id": 0, "num": 0, "iteration": 13}