{"train_results": [{"success": true, "output": "[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 1, 1, 1], [1, 1, 1, 1, 1, 3, 9, 9, 9, 9, 9, 9, 3, 1, 1], [1, 1, 1, 1, 3, 9, 9, 9, 9, 3, 3, 3, 1, 1, 1], [1, 1, 1, 1, 3, 9, 9, 9, 3, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 3, 9, 9, 3, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 3, 9, 9, 3, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 3, 9, 9, 9, 9, 3, 1, 1, 1, 1], [1, 1, 1, 1, 3, 9, 9, 9, 9, 9, 9, 3, 1, 1, 1], [1, 1, 1, 1, 9, 9, 9, 5, 5, 9, 9, 9, 1, 1, 1], [1, 1, 1, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 1, 1], [1, 1, 9, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 9, 1], [1, 9, 9, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 9, 9]]", "soft_score": 1.0, "error": null, "code": "\nimport numpy as np\n\ndef transform(grid_input):\n    \"\"\"Transform grid by filling the interior of a border shape and extending the fill\n    through the shape's opening, with shadow casting from obstacles.\n\n    The transformation:\n    1. Identifies background, border, fill, and obstacle colors\n    2. Finds the opening direction of the border shape\n    3. Fills the interior of the shape with the fill color\n    4. Extends the fill through the opening, bounded by extrapolated border walls\n    5. Obstacles cast shadows in the opening direction, blocking the fill\n    \"\"\"\n    grid = np.array(grid_input, dtype=int)\n    H, W = grid.shape\n\n    # 1. Find colors\n    colors, counts = np.unique(grid, return_counts=True)\n    bg = int(colors[np.argmax(counts)])\n    non_bg = [int(c) for c in colors if c != bg]\n    non_bg_counts = {c: int(np.sum(grid == c)) for c in non_bg}\n    border = max(non_bg_counts, key=non_bg_counts.get)\n\n    border_mask = (grid == border)\n    other = [c for c in non_bg if c != border]\n\n    # Find fill color: non-bg, non-border color inside the border shape\n    fill_color = None\n    for c in other:\n        positions = np.argwhere(grid == c)\n        for r, col in positions:\n            bc = np.where(border_mask[r])[0]\n            if len(bc) >= 2 and bc[0] < col < bc[-1]:\n                fill_color = c\n                break\n            br = np.where(border_mask[:, col])[0]\n            if len(br) >= 2 and br[0] < r < br[-1]:\n                fill_color = c\n                break\n        if fill_color is not None:\n            break\n\n    if fill_color is None:\n        return grid.tolist()\n\n    # 2. Find opening direction based on fill position relative to border center\n    border_positions = np.argwhere(grid == border)\n    fill_positions = np.argwhere(grid == fill_color)\n    border_center = border_positions.mean(axis=0)\n    fill_center = fill_positions.mean(axis=0)\n    diff = fill_center - border_center\n\n    if abs(diff[0]) >= abs(diff[1]):\n        opening = 'top' if diff[0] > 0 else 'bottom'\n    else:\n        opening = 'left' if diff[1] > 0 else 'right'\n\n    # 3. Rotate so opening is at bottom\n    rotation_map = {'bottom': 0, 'top': 2, 'left': 1, 'right': 3}\n    reverse_map = {'bottom': 0, 'top': 2, 'left': 3, 'right': 1}\n\n    k = rotation_map[opening]\n    g = np.rot90(grid, k)\n    gH, gW = g.shape\n    result = g.copy()\n\n    # 4. Find left and right walls per row\n    border_m = (g == border)\n    border_rows_all = np.where(np.any(border_m, axis=1))[0]\n    if len(border_rows_all) == 0:\n        return grid.tolist()\n\n    min_br = int(border_rows_all[0])\n    max_br = int(border_rows_all[-1])\n\n    left_wall = {}\n    right_wall = {}\n\n    for r in range(min_br, max_br + 1):\n        cols = np.where(border_m[r])[0]\n        if len(cols) >= 2:\n            left_wall[r] = int(cols[0])\n            right_wall[r] = int(cols[-1])\n        elif len(cols) == 1:\n            c = int(cols[0])\n            prev_left = None\n            prev_right = None\n            for pr in range(r-1, min_br-1, -1):\n                if pr in left_wall and left_wall[pr] >= 0:\n                    prev_left = left_wall[pr]\n                    break\n            for pr in range(r-1, min_br-1, -1):\n                if pr in right_wall and right_wall[pr] < gW:\n                    prev_right = right_wall[pr]\n                    break\n\n            if prev_left is not None and prev_right is not None:\n                if abs(c - prev_left) <= abs(c - prev_right):\n                    left_wall[r] = c\n                    right_wall[r] = gW\n                else:\n                    right_wall[r] = c\n                    left_wall[r] = -1\n            else:\n                left_wall[r] = c\n                right_wall[r] = gW\n\n    # 5. Fill interior between walls\n    for r in range(min_br, max_br + 1):\n        if r in left_wall and r in right_wall:\n            lb = left_wall[r]\n            rb = right_wall[r]\n            for c in range(max(0, lb + 1), min(gW, rb)):\n                if g[r, c] == bg:\n                    result[r, c] = fill_color\n\n    # 6. Extrapolate boundaries for extension below the border\n    rows_with_left = sorted([r for r in left_wall if left_wall[r] >= 0])\n    rows_with_right = sorted([r for r in right_wall if right_wall[r] < gW])\n\n    if len(rows_with_left) >= 3:\n        left_vals = [left_wall[r] for r in rows_with_left]\n        left_deltas = [left_vals[i+1] - left_vals[i] for i in range(len(left_vals)-1)]\n        ld_pattern = left_deltas[-2:]\n    elif len(rows_with_left) >= 2:\n        left_vals = [left_wall[r] for r in rows_with_left]\n        d = left_vals[-1] - left_vals[-2]\n        ld_pattern = [d, d]\n    else:\n        ld_pattern = [0, 0]\n\n    if len(rows_with_right) >= 3:\n        right_vals = [right_wall[r] for r in rows_with_right]\n        right_deltas = [right_vals[i+1] - right_vals[i] for i in range(len(right_vals)-1)]\n        rd_pattern = right_deltas[-2:]\n    elif len(rows_with_right) >= 2:\n        right_vals = [right_wall[r] for r in rows_with_right]\n        d = right_vals[-1] - right_vals[-2]\n        rd_pattern = [d, d]\n    else:\n        rd_pattern = [0, 0]\n\n    last_left = left_wall.get(max_br, left_wall.get(max_br - 1, 0))\n    last_right = right_wall.get(max_br, right_wall.get(max_br - 1, gW - 1))\n\n    ext_left = {}\n    ext_right = {}\n    for i, r in enumerate(range(max_br + 1, gH)):\n        dl = ld_pattern[i % len(ld_pattern)]\n        dr = rd_pattern[i % len(rd_pattern)]\n        new_left = last_left + dl\n        new_right = last_right + dr\n        # Monotonicity: left wall can only move left, right wall can only move right\n        new_left = min(new_left, last_left)\n        new_right = max(new_right, last_right)\n        last_left = new_left\n        last_right = new_right\n        ext_left[r] = last_left\n        ext_right[r] = last_right\n\n    # Fill extension rows\n    for r in range(max_br + 1, gH):\n        lb = ext_left[r]\n        rb = ext_right[r]\n        for c in range(max(0, lb + 1), min(gW, rb)):\n            if g[r, c] == bg:\n                result[r, c] = fill_color\n\n    # 7. Cast shadows from obstacles within the fill region\n    obstacle_colors = set(c for c in non_bg if c != border and c != fill_color)\n    all_left = {**left_wall, **ext_left}\n    all_right = {**right_wall, **ext_right}\n\n    for r in range(gH):\n        for c in range(gW):\n            if int(g[r, c]) in obstacle_colors:\n                if r in all_left and r in all_right:\n                    lb = all_left[r]\n                    rb = all_right[r]\n                    if lb < c < rb:\n                        for sr in range(r + 1, gH):\n                            if result[sr, c] == fill_color:\n                                result[sr, c] = bg\n\n    # 8. Reverse rotation\n    result = np.rot90(result, reverse_map[opening])\n    return result.tolist()\n"}, {"success": true, "output": "[[4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 5, 0, 0, 0, 5, 5, 5, 0], [4, 4, 4, 4, 4, 4, 4, 4, 5, 0, 5, 4, 4, 5, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 5, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 5, 0], [4, 4, 4, 4, 4, 4, 4, 4, 5, 0, 5, 5, 5, 5, 0]]", "soft_score": 1.0, "error": null, "code": "\nimport numpy as np\n\ndef transform(grid_input):\n    \"\"\"Transform grid by filling the interior of a border shape and extending the fill\n    through the shape's opening, with shadow casting from obstacles.\n\n    The transformation:\n    1. Identifies background, border, fill, and obstacle colors\n    2. Finds the opening direction of the border shape\n    3. Fills the interior of the shape with the fill color\n    4. Extends the fill through the opening, bounded by extrapolated border walls\n    5. Obstacles cast shadows in the opening direction, blocking the fill\n    \"\"\"\n    grid = np.array(grid_input, dtype=int)\n    H, W = grid.shape\n\n    # 1. Find colors\n    colors, counts = np.unique(grid, return_counts=True)\n    bg = int(colors[np.argmax(counts)])\n    non_bg = [int(c) for c in colors if c != bg]\n    non_bg_counts = {c: int(np.sum(grid == c)) for c in non_bg}\n    border = max(non_bg_counts, key=non_bg_counts.get)\n\n    border_mask = (grid == border)\n    other = [c for c in non_bg if c != border]\n\n    # Find fill color: non-bg, non-border color inside the border shape\n    fill_color = None\n    for c in other:\n        positions = np.argwhere(grid == c)\n        for r, col in positions:\n            bc = np.where(border_mask[r])[0]\n            if len(bc) >= 2 and bc[0] < col < bc[-1]:\n                fill_color = c\n                break\n            br = np.where(border_mask[:, col])[0]\n            if len(br) >= 2 and br[0] < r < br[-1]:\n                fill_color = c\n                break\n        if fill_color is not None:\n            break\n\n    if fill_color is None:\n        return grid.tolist()\n\n    # 2. Find opening direction based on fill position relative to border center\n    border_positions = np.argwhere(grid == border)\n    fill_positions = np.argwhere(grid == fill_color)\n    border_center = border_positions.mean(axis=0)\n    fill_center = fill_positions.mean(axis=0)\n    diff = fill_center - border_center\n\n    if abs(diff[0]) >= abs(diff[1]):\n        opening = 'top' if diff[0] > 0 else 'bottom'\n    else:\n        opening = 'left' if diff[1] > 0 else 'right'\n\n    # 3. Rotate so opening is at bottom\n    rotation_map = {'bottom': 0, 'top': 2, 'left': 1, 'right': 3}\n    reverse_map = {'bottom': 0, 'top': 2, 'left': 3, 'right': 1}\n\n    k = rotation_map[opening]\n    g = np.rot90(grid, k)\n    gH, gW = g.shape\n    result = g.copy()\n\n    # 4. Find left and right walls per row\n    border_m = (g == border)\n    border_rows_all = np.where(np.any(border_m, axis=1))[0]\n    if len(border_rows_all) == 0:\n        return grid.tolist()\n\n    min_br = int(border_rows_all[0])\n    max_br = int(border_rows_all[-1])\n\n    left_wall = {}\n    right_wall = {}\n\n    for r in range(min_br, max_br + 1):\n        cols = np.where(border_m[r])[0]\n        if len(cols) >= 2:\n            left_wall[r] = int(cols[0])\n            right_wall[r] = int(cols[-1])\n        elif len(cols) == 1:\n            c = int(cols[0])\n            prev_left = None\n            prev_right = None\n            for pr in range(r-1, min_br-1, -1):\n                if pr in left_wall and left_wall[pr] >= 0:\n                    prev_left = left_wall[pr]\n                    break\n            for pr in range(r-1, min_br-1, -1):\n                if pr in right_wall and right_wall[pr] < gW:\n                    prev_right = right_wall[pr]\n                    break\n\n            if prev_left is not None and prev_right is not None:\n                if abs(c - prev_left) <= abs(c - prev_right):\n                    left_wall[r] = c\n                    right_wall[r] = gW\n                else:\n                    right_wall[r] = c\n                    left_wall[r] = -1\n            else:\n                left_wall[r] = c\n                right_wall[r] = gW\n\n    # 5. Fill interior between walls\n    for r in range(min_br, max_br + 1):\n        if r in left_wall and r in right_wall:\n            lb = left_wall[r]\n            rb = right_wall[r]\n            for c in range(max(0, lb + 1), min(gW, rb)):\n                if g[r, c] == bg:\n                    result[r, c] = fill_color\n\n    # 6. Extrapolate boundaries for extension below the border\n    rows_with_left = sorted([r for r in left_wall if left_wall[r] >= 0])\n    rows_with_right = sorted([r for r in right_wall if right_wall[r] < gW])\n\n    if len(rows_with_left) >= 3:\n        left_vals = [left_wall[r] for r in rows_with_left]\n        left_deltas = [left_vals[i+1] - left_vals[i] for i in range(len(left_vals)-1)]\n        ld_pattern = left_deltas[-2:]\n    elif len(rows_with_left) >= 2:\n        left_vals = [left_wall[r] for r in rows_with_left]\n        d = left_vals[-1] - left_vals[-2]\n        ld_pattern = [d, d]\n    else:\n        ld_pattern = [0, 0]\n\n    if len(rows_with_right) >= 3:\n        right_vals = [right_wall[r] for r in rows_with_right]\n        right_deltas = [right_vals[i+1] - right_vals[i] for i in range(len(right_vals)-1)]\n        rd_pattern = right_deltas[-2:]\n    elif len(rows_with_right) >= 2:\n        right_vals = [right_wall[r] for r in rows_with_right]\n        d = right_vals[-1] - right_vals[-2]\n        rd_pattern = [d, d]\n    else:\n        rd_pattern = [0, 0]\n\n    last_left = left_wall.get(max_br, left_wall.get(max_br - 1, 0))\n    last_right = right_wall.get(max_br, right_wall.get(max_br - 1, gW - 1))\n\n    ext_left = {}\n    ext_right = {}\n    for i, r in enumerate(range(max_br + 1, gH)):\n        dl = ld_pattern[i % len(ld_pattern)]\n        dr = rd_pattern[i % len(rd_pattern)]\n        new_left = last_left + dl\n        new_right = last_right + dr\n        # Monotonicity: left wall can only move left, right wall can only move right\n        new_left = min(new_left, last_left)\n        new_right = max(new_right, last_right)\n        last_left = new_left\n        last_right = new_right\n        ext_left[r] = last_left\n        ext_right[r] = last_right\n\n    # Fill extension rows\n    for r in range(max_br + 1, gH):\n        lb = ext_left[r]\n        rb = ext_right[r]\n        for c in range(max(0, lb + 1), min(gW, rb)):\n            if g[r, c] == bg:\n                result[r, c] = fill_color\n\n    # 7. Cast shadows from obstacles within the fill region\n    obstacle_colors = set(c for c in non_bg if c != border and c != fill_color)\n    all_left = {**left_wall, **ext_left}\n    all_right = {**right_wall, **ext_right}\n\n    for r in range(gH):\n        for c in range(gW):\n            if int(g[r, c]) in obstacle_colors:\n                if r in all_left and r in all_right:\n                    lb = all_left[r]\n                    rb = all_right[r]\n                    if lb < c < rb:\n                        for sr in range(r + 1, gH):\n                            if result[sr, c] == fill_color:\n                                result[sr, c] = bg\n\n    # 8. Reverse rotation\n    result = np.rot90(result, reverse_map[opening])\n    return result.tolist()\n"}, {"success": true, "output": "[[7, 7, 7, 3, 3, 7, 3, 7, 3, 3, 3, 3, 7, 7, 7, 7], [7, 7, 7, 7, 3, 6, 3, 7, 3, 3, 3, 7, 7, 7, 7, 7], [7, 7, 7, 7, 3, 3, 3, 7, 3, 3, 3, 7, 7, 7, 7, 7], [7, 7, 7, 7, 9, 3, 3, 7, 3, 3, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 9, 3, 3, 6, 3, 3, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 9, 3, 3, 3, 9, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 9, 3, 3, 3, 9, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 9, 3, 9, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 9, 3, 9, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 9, 3, 3, 9, 9, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 9, 3, 3, 3, 3, 3, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 9, 3, 3, 3, 3, 3, 9, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 9, 3, 3, 3, 9, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 7, 7], [7, 7, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]]", "soft_score": 1.0, "error": null, "code": "\nimport numpy as np\n\ndef transform(grid_input):\n    \"\"\"Transform grid by filling the interior of a border shape and extending the fill\n    through the shape's opening, with shadow casting from obstacles.\n\n    The transformation:\n    1. Identifies background, border, fill, and obstacle colors\n    2. Finds the opening direction of the border shape\n    3. Fills the interior of the shape with the fill color\n    4. Extends the fill through the opening, bounded by extrapolated border walls\n    5. Obstacles cast shadows in the opening direction, blocking the fill\n    \"\"\"\n    grid = np.array(grid_input, dtype=int)\n    H, W = grid.shape\n\n    # 1. Find colors\n    colors, counts = np.unique(grid, return_counts=True)\n    bg = int(colors[np.argmax(counts)])\n    non_bg = [int(c) for c in colors if c != bg]\n    non_bg_counts = {c: int(np.sum(grid == c)) for c in non_bg}\n    border = max(non_bg_counts, key=non_bg_counts.get)\n\n    border_mask = (grid == border)\n    other = [c for c in non_bg if c != border]\n\n    # Find fill color: non-bg, non-border color inside the border shape\n    fill_color = None\n    for c in other:\n        positions = np.argwhere(grid == c)\n        for r, col in positions:\n            bc = np.where(border_mask[r])[0]\n            if len(bc) >= 2 and bc[0] < col < bc[-1]:\n                fill_color = c\n                break\n            br = np.where(border_mask[:, col])[0]\n            if len(br) >= 2 and br[0] < r < br[-1]:\n                fill_color = c\n                break\n        if fill_color is not None:\n            break\n\n    if fill_color is None:\n        return grid.tolist()\n\n    # 2. Find opening direction based on fill position relative to border center\n    border_positions = np.argwhere(grid == border)\n    fill_positions = np.argwhere(grid == fill_color)\n    border_center = border_positions.mean(axis=0)\n    fill_center = fill_positions.mean(axis=0)\n    diff = fill_center - border_center\n\n    if abs(diff[0]) >= abs(diff[1]):\n        opening = 'top' if diff[0] > 0 else 'bottom'\n    else:\n        opening = 'left' if diff[1] > 0 else 'right'\n\n    # 3. Rotate so opening is at bottom\n    rotation_map = {'bottom': 0, 'top': 2, 'left': 1, 'right': 3}\n    reverse_map = {'bottom': 0, 'top': 2, 'left': 3, 'right': 1}\n\n    k = rotation_map[opening]\n    g = np.rot90(grid, k)\n    gH, gW = g.shape\n    result = g.copy()\n\n    # 4. Find left and right walls per row\n    border_m = (g == border)\n    border_rows_all = np.where(np.any(border_m, axis=1))[0]\n    if len(border_rows_all) == 0:\n        return grid.tolist()\n\n    min_br = int(border_rows_all[0])\n    max_br = int(border_rows_all[-1])\n\n    left_wall = {}\n    right_wall = {}\n\n    for r in range(min_br, max_br + 1):\n        cols = np.where(border_m[r])[0]\n        if len(cols) >= 2:\n            left_wall[r] = int(cols[0])\n            right_wall[r] = int(cols[-1])\n        elif len(cols) == 1:\n            c = int(cols[0])\n            prev_left = None\n            prev_right = None\n            for pr in range(r-1, min_br-1, -1):\n                if pr in left_wall and left_wall[pr] >= 0:\n                    prev_left = left_wall[pr]\n                    break\n            for pr in range(r-1, min_br-1, -1):\n                if pr in right_wall and right_wall[pr] < gW:\n                    prev_right = right_wall[pr]\n                    break\n\n            if prev_left is not None and prev_right is not None:\n                if abs(c - prev_left) <= abs(c - prev_right):\n                    left_wall[r] = c\n                    right_wall[r] = gW\n                else:\n                    right_wall[r] = c\n                    left_wall[r] = -1\n            else:\n                left_wall[r] = c\n                right_wall[r] = gW\n\n    # 5. Fill interior between walls\n    for r in range(min_br, max_br + 1):\n        if r in left_wall and r in right_wall:\n            lb = left_wall[r]\n            rb = right_wall[r]\n            for c in range(max(0, lb + 1), min(gW, rb)):\n                if g[r, c] == bg:\n                    result[r, c] = fill_color\n\n    # 6. Extrapolate boundaries for extension below the border\n    rows_with_left = sorted([r for r in left_wall if left_wall[r] >= 0])\n    rows_with_right = sorted([r for r in right_wall if right_wall[r] < gW])\n\n    if len(rows_with_left) >= 3:\n        left_vals = [left_wall[r] for r in rows_with_left]\n        left_deltas = [left_vals[i+1] - left_vals[i] for i in range(len(left_vals)-1)]\n        ld_pattern = left_deltas[-2:]\n    elif len(rows_with_left) >= 2:\n        left_vals = [left_wall[r] for r in rows_with_left]\n        d = left_vals[-1] - left_vals[-2]\n        ld_pattern = [d, d]\n    else:\n        ld_pattern = [0, 0]\n\n    if len(rows_with_right) >= 3:\n        right_vals = [right_wall[r] for r in rows_with_right]\n        right_deltas = [right_vals[i+1] - right_vals[i] for i in range(len(right_vals)-1)]\n        rd_pattern = right_deltas[-2:]\n    elif len(rows_with_right) >= 2:\n        right_vals = [right_wall[r] for r in rows_with_right]\n        d = right_vals[-1] - right_vals[-2]\n        rd_pattern = [d, d]\n    else:\n        rd_pattern = [0, 0]\n\n    last_left = left_wall.get(max_br, left_wall.get(max_br - 1, 0))\n    last_right = right_wall.get(max_br, right_wall.get(max_br - 1, gW - 1))\n\n    ext_left = {}\n    ext_right = {}\n    for i, r in enumerate(range(max_br + 1, gH)):\n        dl = ld_pattern[i % len(ld_pattern)]\n        dr = rd_pattern[i % len(rd_pattern)]\n        new_left = last_left + dl\n        new_right = last_right + dr\n        # Monotonicity: left wall can only move left, right wall can only move right\n        new_left = min(new_left, last_left)\n        new_right = max(new_right, last_right)\n        last_left = new_left\n        last_right = new_right\n        ext_left[r] = last_left\n        ext_right[r] = last_right\n\n    # Fill extension rows\n    for r in range(max_br + 1, gH):\n        lb = ext_left[r]\n        rb = ext_right[r]\n        for c in range(max(0, lb + 1), min(gW, rb)):\n            if g[r, c] == bg:\n                result[r, c] = fill_color\n\n    # 7. Cast shadows from obstacles within the fill region\n    obstacle_colors = set(c for c in non_bg if c != border and c != fill_color)\n    all_left = {**left_wall, **ext_left}\n    all_right = {**right_wall, **ext_right}\n\n    for r in range(gH):\n        for c in range(gW):\n            if int(g[r, c]) in obstacle_colors:\n                if r in all_left and r in all_right:\n                    lb = all_left[r]\n                    rb = all_right[r]\n                    if lb < c < rb:\n                        for sr in range(r + 1, gH):\n                            if result[sr, c] == fill_color:\n                                result[sr, c] = bg\n\n    # 8. Reverse rotation\n    result = np.rot90(result, reverse_map[opening])\n    return result.tolist()\n"}], "test_results": [{"success": false, "output": "[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 1, 1, 1, 1, 4, 4, 4, 1, 1], [1, 1, 1, 1, 3, 2, 2, 2, 2, 2, 4, 4, 1, 4, 2, 2, 4, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 4, 1, 1], [1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 1, 1], [1, 1, 1, 1, 1, 1, 3, 2, 2, 2, 2, 2, 4, 4, 2, 2, 4, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 1, 4, 4, 4, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]", "soft_score": 0.0, "error": null, "code": "\nimport numpy as np\n\ndef transform(grid_input):\n    \"\"\"Transform grid by filling the interior of a border shape and extending the fill\n    through the shape's opening, with shadow casting from obstacles.\n\n    The transformation:\n    1. Identifies background, border, fill, and obstacle colors\n    2. Finds the opening direction of the border shape\n    3. Fills the interior of the shape with the fill color\n    4. Extends the fill through the opening, bounded by extrapolated border walls\n    5. Obstacles cast shadows in the opening direction, blocking the fill\n    \"\"\"\n    grid = np.array(grid_input, dtype=int)\n    H, W = grid.shape\n\n    # 1. Find colors\n    colors, counts = np.unique(grid, return_counts=True)\n    bg = int(colors[np.argmax(counts)])\n    non_bg = [int(c) for c in colors if c != bg]\n    non_bg_counts = {c: int(np.sum(grid == c)) for c in non_bg}\n    border = max(non_bg_counts, key=non_bg_counts.get)\n\n    border_mask = (grid == border)\n    other = [c for c in non_bg if c != border]\n\n    # Find fill color: non-bg, non-border color inside the border shape\n    fill_color = None\n    for c in other:\n        positions = np.argwhere(grid == c)\n        for r, col in positions:\n            bc = np.where(border_mask[r])[0]\n            if len(bc) >= 2 and bc[0] < col < bc[-1]:\n                fill_color = c\n                break\n            br = np.where(border_mask[:, col])[0]\n            if len(br) >= 2 and br[0] < r < br[-1]:\n                fill_color = c\n                break\n        if fill_color is not None:\n            break\n\n    if fill_color is None:\n        return grid.tolist()\n\n    # 2. Find opening direction based on fill position relative to border center\n    border_positions = np.argwhere(grid == border)\n    fill_positions = np.argwhere(grid == fill_color)\n    border_center = border_positions.mean(axis=0)\n    fill_center = fill_positions.mean(axis=0)\n    diff = fill_center - border_center\n\n    if abs(diff[0]) >= abs(diff[1]):\n        opening = 'top' if diff[0] > 0 else 'bottom'\n    else:\n        opening = 'left' if diff[1] > 0 else 'right'\n\n    # 3. Rotate so opening is at bottom\n    rotation_map = {'bottom': 0, 'top': 2, 'left': 1, 'right': 3}\n    reverse_map = {'bottom': 0, 'top': 2, 'left': 3, 'right': 1}\n\n    k = rotation_map[opening]\n    g = np.rot90(grid, k)\n    gH, gW = g.shape\n    result = g.copy()\n\n    # 4. Find left and right walls per row\n    border_m = (g == border)\n    border_rows_all = np.where(np.any(border_m, axis=1))[0]\n    if len(border_rows_all) == 0:\n        return grid.tolist()\n\n    min_br = int(border_rows_all[0])\n    max_br = int(border_rows_all[-1])\n\n    left_wall = {}\n    right_wall = {}\n\n    for r in range(min_br, max_br + 1):\n        cols = np.where(border_m[r])[0]\n        if len(cols) >= 2:\n            left_wall[r] = int(cols[0])\n            right_wall[r] = int(cols[-1])\n        elif len(cols) == 1:\n            c = int(cols[0])\n            prev_left = None\n            prev_right = None\n            for pr in range(r-1, min_br-1, -1):\n                if pr in left_wall and left_wall[pr] >= 0:\n                    prev_left = left_wall[pr]\n                    break\n            for pr in range(r-1, min_br-1, -1):\n                if pr in right_wall and right_wall[pr] < gW:\n                    prev_right = right_wall[pr]\n                    break\n\n            if prev_left is not None and prev_right is not None:\n                if abs(c - prev_left) <= abs(c - prev_right):\n                    left_wall[r] = c\n                    right_wall[r] = gW\n                else:\n                    right_wall[r] = c\n                    left_wall[r] = -1\n            else:\n                left_wall[r] = c\n                right_wall[r] = gW\n\n    # 5. Fill interior between walls\n    for r in range(min_br, max_br + 1):\n        if r in left_wall and r in right_wall:\n            lb = left_wall[r]\n            rb = right_wall[r]\n            for c in range(max(0, lb + 1), min(gW, rb)):\n                if g[r, c] == bg:\n                    result[r, c] = fill_color\n\n    # 6. Extrapolate boundaries for extension below the border\n    rows_with_left = sorted([r for r in left_wall if left_wall[r] >= 0])\n    rows_with_right = sorted([r for r in right_wall if right_wall[r] < gW])\n\n    if len(rows_with_left) >= 3:\n        left_vals = [left_wall[r] for r in rows_with_left]\n        left_deltas = [left_vals[i+1] - left_vals[i] for i in range(len(left_vals)-1)]\n        ld_pattern = left_deltas[-2:]\n    elif len(rows_with_left) >= 2:\n        left_vals = [left_wall[r] for r in rows_with_left]\n        d = left_vals[-1] - left_vals[-2]\n        ld_pattern = [d, d]\n    else:\n        ld_pattern = [0, 0]\n\n    if len(rows_with_right) >= 3:\n        right_vals = [right_wall[r] for r in rows_with_right]\n        right_deltas = [right_vals[i+1] - right_vals[i] for i in range(len(right_vals)-1)]\n        rd_pattern = right_deltas[-2:]\n    elif len(rows_with_right) >= 2:\n        right_vals = [right_wall[r] for r in rows_with_right]\n        d = right_vals[-1] - right_vals[-2]\n        rd_pattern = [d, d]\n    else:\n        rd_pattern = [0, 0]\n\n    last_left = left_wall.get(max_br, left_wall.get(max_br - 1, 0))\n    last_right = right_wall.get(max_br, right_wall.get(max_br - 1, gW - 1))\n\n    ext_left = {}\n    ext_right = {}\n    for i, r in enumerate(range(max_br + 1, gH)):\n        dl = ld_pattern[i % len(ld_pattern)]\n        dr = rd_pattern[i % len(rd_pattern)]\n        new_left = last_left + dl\n        new_right = last_right + dr\n        # Monotonicity: left wall can only move left, right wall can only move right\n        new_left = min(new_left, last_left)\n        new_right = max(new_right, last_right)\n        last_left = new_left\n        last_right = new_right\n        ext_left[r] = last_left\n        ext_right[r] = last_right\n\n    # Fill extension rows\n    for r in range(max_br + 1, gH):\n        lb = ext_left[r]\n        rb = ext_right[r]\n        for c in range(max(0, lb + 1), min(gW, rb)):\n            if g[r, c] == bg:\n                result[r, c] = fill_color\n\n    # 7. Cast shadows from obstacles within the fill region\n    obstacle_colors = set(c for c in non_bg if c != border and c != fill_color)\n    all_left = {**left_wall, **ext_left}\n    all_right = {**right_wall, **ext_right}\n\n    for r in range(gH):\n        for c in range(gW):\n            if int(g[r, c]) in obstacle_colors:\n                if r in all_left and r in all_right:\n                    lb = all_left[r]\n                    rb = all_right[r]\n                    if lb < c < rb:\n                        for sr in range(r + 1, gH):\n                            if result[sr, c] == fill_color:\n                                result[sr, c] = bg\n\n    # 8. Reverse rotation\n    result = np.rot90(result, reverse_map[opening])\n    return result.tolist()\n"}], "agent_usage": [{"input_tokens": 1896047, "input_tokens_details": {"cached_tokens": 1774285}, "output_tokens": 107360, "output_tokens_details": {"reasoning_tokens": -23}, "total_tokens": 107385, "inference_count": 23, "cache_creation": {"ephemeral_1h_input_tokens": 121737, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 121737, "inference_geo": ["global"], "service_tier": ["standard"]}, {"input_tokens": 392371, "input_tokens_details": {"cached_tokens": 366984}, "output_tokens": 14279, "output_tokens_details": {"reasoning_tokens": -25}, "total_tokens": 14306, "inference_count": 25, "cache_creation": {"ephemeral_1h_input_tokens": 25360, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 25360, "inference_geo": ["global"], "service_tier": ["standard"]}], "time_taken": 3908.4456112384796, "num_agents_used": 2, "model": "anthropic/claude-opus-4-6", "reasoning_effort": "high", "error": null, "problem_id": "b9e38dc0", "attempt_id": 0, "num": 0, "iteration": 23}