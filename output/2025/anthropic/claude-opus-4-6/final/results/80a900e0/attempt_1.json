{"train_results": [{"success": true, "output": "[[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 8], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 8, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 8, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 8, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 8, 0, 1, 0, 8], [1, 0, 1, 0, 1, 0, 1, 0, 8, 0, 1, 0, 8, 0], [0, 1, 0, 1, 0, 1, 0, 8, 0, 1, 0, 8, 0, 1], [1, 0, 1, 0, 1, 0, 3, 0, 8, 0, 8, 0, 1, 0], [0, 1, 0, 1, 0, 3, 0, 3, 0, 8, 0, 1, 0, 1], [1, 0, 1, 0, 3, 0, 1, 0, 3, 0, 1, 0, 1, 0], [0, 1, 0, 8, 0, 3, 0, 3, 0, 1, 0, 1, 0, 1], [1, 0, 8, 0, 8, 0, 3, 0, 1, 0, 1, 0, 1, 0], [0, 8, 0, 1, 0, 8, 0, 1, 0, 1, 0, 1, 0, 1], [8, 0, 1, 0, 8, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 8, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 8, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 8, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [8, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]]", "soft_score": 1.0, "error": null, "code": "def transform(grid):\n    import numpy as np\n    from scipy import ndimage\n    from collections import defaultdict, Counter\n\n    rows, cols = len(grid), len(grid[0])\n    g = np.array(grid)\n    result = g.copy()\n\n    # Determine checkerboard background\n    bg = np.zeros_like(g)\n    for r in range(rows):\n        for c in range(cols):\n            bg[r,c] = g[0,0] if (r+c)%2==0 else 1-g[0,0]\n\n    # Non-background mask\n    non_bg_mask = g != bg\n\n    # Label connected components with diagonal connectivity\n    struct = np.array([[1,0,1],[0,1,0],[1,0,1]])\n    labels, num = ndimage.label(non_bg_mask, structure=struct)\n\n    for label_id in range(1, num + 1):\n        comp_cells = []\n        for r in range(rows):\n            for c in range(cols):\n                if labels[r, c] == label_id:\n                    comp_cells.append((r, c, int(g[r, c])))\n\n        if len(comp_cells) < 3:\n            continue\n\n        # Find center in diagonal coordinates\n        center_a = np.mean([r+c for r,c,v in comp_cells])\n        center_b = np.mean([r-c for r,c,v in comp_cells])\n\n        # Find extremes\n        a_vals = [r+c for r,c,v in comp_cells]\n        b_vals = [r-c for r,c,v in comp_cells]\n        min_a, max_a = min(a_vals), max(a_vals)\n        min_b, max_b = min(b_vals), max(b_vals)\n\n        # Interior cells: not on any extreme diagonal\n        interior_cells = [(r,c,v) for r,c,v in comp_cells \n                         if r+c != min_a and r+c != max_a and r-c != min_b and r-c != max_b]\n\n        if interior_cells:\n            ic = Counter(v for r,c,v in interior_cells)\n            interior_color = ic.most_common(1)[0][0]\n        else:\n            color_counts = Counter(v for r,c,v in comp_cells)\n            interior_color = color_counts.most_common(1)[0][0]\n\n        # Border cells (non-interior color)\n        border_cells = [(r,c,v) for r,c,v in comp_cells if v != interior_color]\n\n        # Group by color\n        cells_by_color = defaultdict(list)\n        for r,c,v in border_cells:\n            cells_by_color[v].append((r,c))\n\n        for color, cells in cells_by_color.items():\n            # Group by r+c\n            by_rpc = defaultdict(list)\n            for r,c in cells:\n                by_rpc[r+c].append((r,c))\n\n            # Group by r-c\n            by_rmc = defaultdict(list)\n            for r,c in cells:\n                by_rmc[r-c].append((r,c))\n\n            # Process r+c groups (sides along direction (1,-1))\n            for k, group in by_rpc.items():\n                group_sorted = sorted(group, key=lambda x: x[0]-x[1])\n                segments = []\n                current_seg = [group_sorted[0]]\n                for i in range(1, len(group_sorted)):\n                    prev_b = current_seg[-1][0] - current_seg[-1][1]\n                    curr_b = group_sorted[i][0] - group_sorted[i][1]\n                    if curr_b - prev_b == 2:\n                        current_seg.append(group_sorted[i])\n                    else:\n                        segments.append(current_seg)\n                        current_seg = [group_sorted[i]]\n                segments.append(current_seg)\n\n                for seg in segments:\n                    if len(seg) < 2:\n                        continue\n\n                    # Perpendicular to (1,-1) is (1,1) or (-1,-1)\n                    if k < center_a:\n                        dr, dc = -1, -1\n                    else:\n                        dr, dc = 1, 1\n\n                    ep1 = seg[0]\n                    ep2 = seg[-1]\n\n                    for er, ec in [ep1, ep2]:\n                        r, c = er + dr, ec + dc\n                        while 0 <= r < rows and 0 <= c < cols:\n                            result[r, c] = color\n                            r += dr\n                            c += dc\n\n            # Process r-c groups (sides along direction (1,1))\n            for k, group in by_rmc.items():\n                group_sorted = sorted(group, key=lambda x: x[0]+x[1])\n                segments = []\n                current_seg = [group_sorted[0]]\n                for i in range(1, len(group_sorted)):\n                    prev_a = current_seg[-1][0] + current_seg[-1][1]\n                    curr_a = group_sorted[i][0] + group_sorted[i][1]\n                    if curr_a - prev_a == 2:\n                        current_seg.append(group_sorted[i])\n                    else:\n                        segments.append(current_seg)\n                        current_seg = [group_sorted[i]]\n                segments.append(current_seg)\n\n                for seg in segments:\n                    if len(seg) < 2:\n                        continue\n\n                    # Perpendicular to (1,1) is (1,-1) or (-1,1)\n                    if k < center_b:\n                        dr, dc = -1, 1\n                    else:\n                        dr, dc = 1, -1\n\n                    ep1 = seg[0]\n                    ep2 = seg[-1]\n\n                    for er, ec in [ep1, ep2]:\n                        r, c = er + dr, ec + dc\n                        while 0 <= r < rows and 0 <= c < cols:\n                            result[r, c] = color\n                            r += dr\n                            c += dc\n\n    return result.tolist()\n"}, {"success": true, "output": "[[1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 1, 0, 4, 0, 1, 0, 4, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 4, 0, 1, 0, 4, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 4, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 4, 0, 1, 0, 4, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 2, 0, 2, 0, 3, 0, 4, 0, 4, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 2, 0, 3, 0, 3, 0, 4, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 1, 0, 3, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 4, 0, 3, 0, 3, 0, 2, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 4, 0, 4, 0, 3, 0, 2, 0, 2, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 4, 0, 1, 0, 4, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 4, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 4, 0, 1, 0, 4, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 4, 0, 1, 0, 4, 0, 1, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 4, 0, 1, 0, 4, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [4, 0, 1, 0, 4, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 4, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 4, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 1, 0], [0, 4, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 1], [4, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2]]", "soft_score": 1.0, "error": null, "code": "def transform(grid):\n    import numpy as np\n    from scipy import ndimage\n    from collections import defaultdict, Counter\n\n    rows, cols = len(grid), len(grid[0])\n    g = np.array(grid)\n    result = g.copy()\n\n    # Determine checkerboard background\n    bg = np.zeros_like(g)\n    for r in range(rows):\n        for c in range(cols):\n            bg[r,c] = g[0,0] if (r+c)%2==0 else 1-g[0,0]\n\n    # Non-background mask\n    non_bg_mask = g != bg\n\n    # Label connected components with diagonal connectivity\n    struct = np.array([[1,0,1],[0,1,0],[1,0,1]])\n    labels, num = ndimage.label(non_bg_mask, structure=struct)\n\n    for label_id in range(1, num + 1):\n        comp_cells = []\n        for r in range(rows):\n            for c in range(cols):\n                if labels[r, c] == label_id:\n                    comp_cells.append((r, c, int(g[r, c])))\n\n        if len(comp_cells) < 3:\n            continue\n\n        # Find center in diagonal coordinates\n        center_a = np.mean([r+c for r,c,v in comp_cells])\n        center_b = np.mean([r-c for r,c,v in comp_cells])\n\n        # Find extremes\n        a_vals = [r+c for r,c,v in comp_cells]\n        b_vals = [r-c for r,c,v in comp_cells]\n        min_a, max_a = min(a_vals), max(a_vals)\n        min_b, max_b = min(b_vals), max(b_vals)\n\n        # Interior cells: not on any extreme diagonal\n        interior_cells = [(r,c,v) for r,c,v in comp_cells \n                         if r+c != min_a and r+c != max_a and r-c != min_b and r-c != max_b]\n\n        if interior_cells:\n            ic = Counter(v for r,c,v in interior_cells)\n            interior_color = ic.most_common(1)[0][0]\n        else:\n            color_counts = Counter(v for r,c,v in comp_cells)\n            interior_color = color_counts.most_common(1)[0][0]\n\n        # Border cells (non-interior color)\n        border_cells = [(r,c,v) for r,c,v in comp_cells if v != interior_color]\n\n        # Group by color\n        cells_by_color = defaultdict(list)\n        for r,c,v in border_cells:\n            cells_by_color[v].append((r,c))\n\n        for color, cells in cells_by_color.items():\n            # Group by r+c\n            by_rpc = defaultdict(list)\n            for r,c in cells:\n                by_rpc[r+c].append((r,c))\n\n            # Group by r-c\n            by_rmc = defaultdict(list)\n            for r,c in cells:\n                by_rmc[r-c].append((r,c))\n\n            # Process r+c groups (sides along direction (1,-1))\n            for k, group in by_rpc.items():\n                group_sorted = sorted(group, key=lambda x: x[0]-x[1])\n                segments = []\n                current_seg = [group_sorted[0]]\n                for i in range(1, len(group_sorted)):\n                    prev_b = current_seg[-1][0] - current_seg[-1][1]\n                    curr_b = group_sorted[i][0] - group_sorted[i][1]\n                    if curr_b - prev_b == 2:\n                        current_seg.append(group_sorted[i])\n                    else:\n                        segments.append(current_seg)\n                        current_seg = [group_sorted[i]]\n                segments.append(current_seg)\n\n                for seg in segments:\n                    if len(seg) < 2:\n                        continue\n\n                    # Perpendicular to (1,-1) is (1,1) or (-1,-1)\n                    if k < center_a:\n                        dr, dc = -1, -1\n                    else:\n                        dr, dc = 1, 1\n\n                    ep1 = seg[0]\n                    ep2 = seg[-1]\n\n                    for er, ec in [ep1, ep2]:\n                        r, c = er + dr, ec + dc\n                        while 0 <= r < rows and 0 <= c < cols:\n                            result[r, c] = color\n                            r += dr\n                            c += dc\n\n            # Process r-c groups (sides along direction (1,1))\n            for k, group in by_rmc.items():\n                group_sorted = sorted(group, key=lambda x: x[0]+x[1])\n                segments = []\n                current_seg = [group_sorted[0]]\n                for i in range(1, len(group_sorted)):\n                    prev_a = current_seg[-1][0] + current_seg[-1][1]\n                    curr_a = group_sorted[i][0] + group_sorted[i][1]\n                    if curr_a - prev_a == 2:\n                        current_seg.append(group_sorted[i])\n                    else:\n                        segments.append(current_seg)\n                        current_seg = [group_sorted[i]]\n                segments.append(current_seg)\n\n                for seg in segments:\n                    if len(seg) < 2:\n                        continue\n\n                    # Perpendicular to (1,1) is (1,-1) or (-1,1)\n                    if k < center_b:\n                        dr, dc = -1, 1\n                    else:\n                        dr, dc = 1, -1\n\n                    ep1 = seg[0]\n                    ep2 = seg[-1]\n\n                    for er, ec in [ep1, ep2]:\n                        r, c = er + dr, ec + dc\n                        while 0 <= r < rows and 0 <= c < cols:\n                            result[r, c] = color\n                            r += dr\n                            c += dc\n\n    return result.tolist()\n"}], "test_results": [{"success": false, "output": "[[2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 4, 0, 1, 0, 4, 0, 1, 0, 1, 0, 1], [0, 2, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 4, 0, 1, 0, 1, 0, 1, 0], [1, 0, 2, 0, 1, 0, 2, 0, 4, 0, 1, 0, 4, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 0, 2, 0, 2, 0, 6, 0, 4, 0, 4, 0, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 2, 0, 6, 0, 6, 0, 4, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6], [0, 1, 0, 1, 0, 6, 0, 1, 0, 6, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 0], [1, 0, 1, 0, 9, 0, 6, 0, 6, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 0, 1], [0, 1, 0, 9, 0, 9, 0, 6, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 0, 1, 0], [1, 0, 9, 0, 1, 0, 9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 0, 1, 0, 6], [0, 9, 0, 1, 0, 9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 0, 1, 0, 6, 0], [9, 0, 1, 0, 9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 0, 1, 0, 6, 0, 1], [0, 1, 0, 9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 0, 1, 0, 6, 0, 1, 0], [1, 0, 9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 6, 0, 6, 0, 1, 0, 1], [0, 9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 3, 0, 6, 0, 1, 0, 1, 0], [9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 1, 0, 3, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 3, 0, 7, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 7, 0, 7, 0, 1, 0, 1], [0, 1, 0, 1, 0, 2, 0, 1, 0, 1, 0, 1, 0, 7, 0, 1, 0, 7, 0, 1, 0], [1, 0, 1, 0, 2, 0, 2, 0, 1, 0, 1, 0, 1, 0, 7, 0, 1, 0, 7, 0, 1], [0, 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 1, 0, 7, 0, 1, 0, 7, 0], [1, 0, 6, 0, 2, 0, 2, 0, 6, 0, 1, 0, 1, 0, 1, 0, 7, 0, 1, 0, 7], [0, 6, 0, 6, 0, 2, 0, 6, 0, 6, 0, 1, 0, 1, 0, 1, 0, 7, 0, 1, 0]]", "soft_score": 0.0, "error": null, "code": "def transform(grid):\n    import numpy as np\n    from scipy import ndimage\n    from collections import defaultdict, Counter\n\n    rows, cols = len(grid), len(grid[0])\n    g = np.array(grid)\n    result = g.copy()\n\n    # Determine checkerboard background\n    bg = np.zeros_like(g)\n    for r in range(rows):\n        for c in range(cols):\n            bg[r,c] = g[0,0] if (r+c)%2==0 else 1-g[0,0]\n\n    # Non-background mask\n    non_bg_mask = g != bg\n\n    # Label connected components with diagonal connectivity\n    struct = np.array([[1,0,1],[0,1,0],[1,0,1]])\n    labels, num = ndimage.label(non_bg_mask, structure=struct)\n\n    for label_id in range(1, num + 1):\n        comp_cells = []\n        for r in range(rows):\n            for c in range(cols):\n                if labels[r, c] == label_id:\n                    comp_cells.append((r, c, int(g[r, c])))\n\n        if len(comp_cells) < 3:\n            continue\n\n        # Find center in diagonal coordinates\n        center_a = np.mean([r+c for r,c,v in comp_cells])\n        center_b = np.mean([r-c for r,c,v in comp_cells])\n\n        # Find extremes\n        a_vals = [r+c for r,c,v in comp_cells]\n        b_vals = [r-c for r,c,v in comp_cells]\n        min_a, max_a = min(a_vals), max(a_vals)\n        min_b, max_b = min(b_vals), max(b_vals)\n\n        # Interior cells: not on any extreme diagonal\n        interior_cells = [(r,c,v) for r,c,v in comp_cells \n                         if r+c != min_a and r+c != max_a and r-c != min_b and r-c != max_b]\n\n        if interior_cells:\n            ic = Counter(v for r,c,v in interior_cells)\n            interior_color = ic.most_common(1)[0][0]\n        else:\n            color_counts = Counter(v for r,c,v in comp_cells)\n            interior_color = color_counts.most_common(1)[0][0]\n\n        # Border cells (non-interior color)\n        border_cells = [(r,c,v) for r,c,v in comp_cells if v != interior_color]\n\n        # Group by color\n        cells_by_color = defaultdict(list)\n        for r,c,v in border_cells:\n            cells_by_color[v].append((r,c))\n\n        for color, cells in cells_by_color.items():\n            # Group by r+c\n            by_rpc = defaultdict(list)\n            for r,c in cells:\n                by_rpc[r+c].append((r,c))\n\n            # Group by r-c\n            by_rmc = defaultdict(list)\n            for r,c in cells:\n                by_rmc[r-c].append((r,c))\n\n            # Process r+c groups (sides along direction (1,-1))\n            for k, group in by_rpc.items():\n                group_sorted = sorted(group, key=lambda x: x[0]-x[1])\n                segments = []\n                current_seg = [group_sorted[0]]\n                for i in range(1, len(group_sorted)):\n                    prev_b = current_seg[-1][0] - current_seg[-1][1]\n                    curr_b = group_sorted[i][0] - group_sorted[i][1]\n                    if curr_b - prev_b == 2:\n                        current_seg.append(group_sorted[i])\n                    else:\n                        segments.append(current_seg)\n                        current_seg = [group_sorted[i]]\n                segments.append(current_seg)\n\n                for seg in segments:\n                    if len(seg) < 2:\n                        continue\n\n                    # Perpendicular to (1,-1) is (1,1) or (-1,-1)\n                    if k < center_a:\n                        dr, dc = -1, -1\n                    else:\n                        dr, dc = 1, 1\n\n                    ep1 = seg[0]\n                    ep2 = seg[-1]\n\n                    for er, ec in [ep1, ep2]:\n                        r, c = er + dr, ec + dc\n                        while 0 <= r < rows and 0 <= c < cols:\n                            result[r, c] = color\n                            r += dr\n                            c += dc\n\n            # Process r-c groups (sides along direction (1,1))\n            for k, group in by_rmc.items():\n                group_sorted = sorted(group, key=lambda x: x[0]+x[1])\n                segments = []\n                current_seg = [group_sorted[0]]\n                for i in range(1, len(group_sorted)):\n                    prev_a = current_seg[-1][0] + current_seg[-1][1]\n                    curr_a = group_sorted[i][0] + group_sorted[i][1]\n                    if curr_a - prev_a == 2:\n                        current_seg.append(group_sorted[i])\n                    else:\n                        segments.append(current_seg)\n                        current_seg = [group_sorted[i]]\n                segments.append(current_seg)\n\n                for seg in segments:\n                    if len(seg) < 2:\n                        continue\n\n                    # Perpendicular to (1,1) is (1,-1) or (-1,1)\n                    if k < center_b:\n                        dr, dc = -1, 1\n                    else:\n                        dr, dc = 1, -1\n\n                    ep1 = seg[0]\n                    ep2 = seg[-1]\n\n                    for er, ec in [ep1, ep2]:\n                        r, c = er + dr, ec + dc\n                        while 0 <= r < rows and 0 <= c < cols:\n                            result[r, c] = color\n                            r += dr\n                            c += dc\n\n    return result.tolist()\n"}], "agent_usage": [{"input_tokens": 303489, "input_tokens_details": {"cached_tokens": 243540}, "output_tokens": 49904, "output_tokens_details": {"reasoning_tokens": -11}, "total_tokens": 49917, "inference_count": 11, "cache_creation": {"ephemeral_1h_input_tokens": 59936, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 59936, "inference_geo": ["global"], "service_tier": ["standard"]}], "time_taken": 1265.9472205638885, "num_agents_used": 1, "model": "anthropic/claude-opus-4-6", "reasoning_effort": "high", "error": null, "problem_id": "80a900e0", "attempt_id": 1, "num": 0, "iteration": 11}