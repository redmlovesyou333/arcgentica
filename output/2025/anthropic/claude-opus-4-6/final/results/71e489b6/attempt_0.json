{"train_results": [{"success": true, "output": "[[1, 1, 7, 0, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 7, 7, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 7], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 0], [1, 1, 1, 1, 1, 1, 1, 7, 7, 7, 1, 1, 1, 1, 1, 7, 7], [1, 1, 1, 1, 1, 1, 1, 7, 0, 7, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 7, 7, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 7, 7, 0, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 7, 0, 0, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 7, 7, 7, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 0, 7, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 7, 7, 1]]", "soft_score": 1.0, "error": null, "code": "def transform(grid):\n    \"\"\"\n    Transform the grid by:\n    1. Finding defect pixels using priority-based 4-neighbor majority voting.\n       A defect is a pixel where the majority of its 4-connected non-defect \n       neighbors have a different value. Defects are detected in priority order\n       (most confident first) to avoid cascading false positives at boundaries.\n    2. For defects that are 0 in a 1-region: keep the 0 and surround with 7-border\n    3. For defects that are 1 in a 0-region: correct to 0 (remove the anomaly)\n    \"\"\"\n    import numpy as np\n    import heapq\n\n    inp = np.array(grid)\n    H, W = inp.shape\n    is_defect = np.zeros((H, W), dtype=bool)\n\n    def compute_score(r, c):\n        \"\"\"Count different and same-valued non-defect 4-neighbors.\"\"\"\n        val = inp[r, c]\n        same = 0\n        diff = 0\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                if inp[nr, nc] == val:\n                    same += 1\n                else:\n                    diff += 1\n        return diff, same\n\n    # Priority queue: process most confident defects first (highest diff-same)\n    heap = []\n    for r in range(H):\n        for c in range(W):\n            diff, same = compute_score(r, c)\n            if diff > same:\n                heapq.heappush(heap, (-(diff - same), r, c))\n\n    while heap:\n        neg_score, r, c = heapq.heappop(heap)\n        if is_defect[r, c]:\n            continue\n\n        # Recompute with current defect state\n        diff, same = compute_score(r, c)\n        if diff <= same:\n            continue\n\n        # If score changed, re-insert with updated priority\n        if -(diff - same) != neg_score:\n            if diff > same:\n                heapq.heappush(heap, (-(diff - same), r, c))\n            continue\n\n        is_defect[r, c] = True\n\n        # Check if neighbors now qualify as defects\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                diff_n, same_n = compute_score(nr, nc)\n                if diff_n > same_n:\n                    heapq.heappush(heap, (-(diff_n - same_n), nr, nc))\n\n    # Build output grid\n    out = inp.copy()\n\n    for r in range(H):\n        for c in range(W):\n            if is_defect[r, c]:\n                if inp[r, c] == 0:\n                    # 0-in-1-region: keep 0, draw 7-border around it\n                    out[r, c] = 0\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = r + dr, c + dc\n                            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                                out[nr, nc] = 7\n                else:\n                    # 1-in-0-region: correct to 0 (remove anomaly)\n                    out[r, c] = 0\n\n    return out.tolist()\n"}, {"success": true, "output": "[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 7], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 7, 7, 7], [1, 1, 0, 0, 0, 0, 1, 7, 7, 7, 1, 1, 0, 7, 0, 7], [1, 1, 0, 0, 0, 0, 1, 7, 0, 7, 1, 1, 0, 7, 7, 7], [1, 1, 0, 0, 0, 0, 1, 7, 7, 7, 1, 1, 0, 1, 7, 0], [1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 7, 7], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 7, 7, 7, 7, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 7, 0, 0, 7, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 7, 7, 7, 7, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]", "soft_score": 1.0, "error": null, "code": "def transform(grid):\n    \"\"\"\n    Transform the grid by:\n    1. Finding defect pixels using priority-based 4-neighbor majority voting.\n       A defect is a pixel where the majority of its 4-connected non-defect \n       neighbors have a different value. Defects are detected in priority order\n       (most confident first) to avoid cascading false positives at boundaries.\n    2. For defects that are 0 in a 1-region: keep the 0 and surround with 7-border\n    3. For defects that are 1 in a 0-region: correct to 0 (remove the anomaly)\n    \"\"\"\n    import numpy as np\n    import heapq\n\n    inp = np.array(grid)\n    H, W = inp.shape\n    is_defect = np.zeros((H, W), dtype=bool)\n\n    def compute_score(r, c):\n        \"\"\"Count different and same-valued non-defect 4-neighbors.\"\"\"\n        val = inp[r, c]\n        same = 0\n        diff = 0\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                if inp[nr, nc] == val:\n                    same += 1\n                else:\n                    diff += 1\n        return diff, same\n\n    # Priority queue: process most confident defects first (highest diff-same)\n    heap = []\n    for r in range(H):\n        for c in range(W):\n            diff, same = compute_score(r, c)\n            if diff > same:\n                heapq.heappush(heap, (-(diff - same), r, c))\n\n    while heap:\n        neg_score, r, c = heapq.heappop(heap)\n        if is_defect[r, c]:\n            continue\n\n        # Recompute with current defect state\n        diff, same = compute_score(r, c)\n        if diff <= same:\n            continue\n\n        # If score changed, re-insert with updated priority\n        if -(diff - same) != neg_score:\n            if diff > same:\n                heapq.heappush(heap, (-(diff - same), r, c))\n            continue\n\n        is_defect[r, c] = True\n\n        # Check if neighbors now qualify as defects\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                diff_n, same_n = compute_score(nr, nc)\n                if diff_n > same_n:\n                    heapq.heappush(heap, (-(diff_n - same_n), nr, nc))\n\n    # Build output grid\n    out = inp.copy()\n\n    for r in range(H):\n        for c in range(W):\n            if is_defect[r, c]:\n                if inp[r, c] == 0:\n                    # 0-in-1-region: keep 0, draw 7-border around it\n                    out[r, c] = 0\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = r + dr, c + dc\n                            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                                out[nr, nc] = 7\n                else:\n                    # 1-in-0-region: correct to 0 (remove anomaly)\n                    out[r, c] = 0\n\n    return out.tolist()\n"}, {"success": true, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 7, 7, 7, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 7, 0, 7, 7, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 7, 7, 0, 7, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 7, 7, 7, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 7, 7, 7, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 7, 0, 7, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "def transform(grid):\n    \"\"\"\n    Transform the grid by:\n    1. Finding defect pixels using priority-based 4-neighbor majority voting.\n       A defect is a pixel where the majority of its 4-connected non-defect \n       neighbors have a different value. Defects are detected in priority order\n       (most confident first) to avoid cascading false positives at boundaries.\n    2. For defects that are 0 in a 1-region: keep the 0 and surround with 7-border\n    3. For defects that are 1 in a 0-region: correct to 0 (remove the anomaly)\n    \"\"\"\n    import numpy as np\n    import heapq\n\n    inp = np.array(grid)\n    H, W = inp.shape\n    is_defect = np.zeros((H, W), dtype=bool)\n\n    def compute_score(r, c):\n        \"\"\"Count different and same-valued non-defect 4-neighbors.\"\"\"\n        val = inp[r, c]\n        same = 0\n        diff = 0\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                if inp[nr, nc] == val:\n                    same += 1\n                else:\n                    diff += 1\n        return diff, same\n\n    # Priority queue: process most confident defects first (highest diff-same)\n    heap = []\n    for r in range(H):\n        for c in range(W):\n            diff, same = compute_score(r, c)\n            if diff > same:\n                heapq.heappush(heap, (-(diff - same), r, c))\n\n    while heap:\n        neg_score, r, c = heapq.heappop(heap)\n        if is_defect[r, c]:\n            continue\n\n        # Recompute with current defect state\n        diff, same = compute_score(r, c)\n        if diff <= same:\n            continue\n\n        # If score changed, re-insert with updated priority\n        if -(diff - same) != neg_score:\n            if diff > same:\n                heapq.heappush(heap, (-(diff - same), r, c))\n            continue\n\n        is_defect[r, c] = True\n\n        # Check if neighbors now qualify as defects\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                diff_n, same_n = compute_score(nr, nc)\n                if diff_n > same_n:\n                    heapq.heappush(heap, (-(diff_n - same_n), nr, nc))\n\n    # Build output grid\n    out = inp.copy()\n\n    for r in range(H):\n        for c in range(W):\n            if is_defect[r, c]:\n                if inp[r, c] == 0:\n                    # 0-in-1-region: keep 0, draw 7-border around it\n                    out[r, c] = 0\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = r + dr, c + dc\n                            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                                out[nr, nc] = 7\n                else:\n                    # 1-in-0-region: correct to 0 (remove anomaly)\n                    out[r, c] = 0\n\n    return out.tolist()\n"}], "test_results": [{"success": false, "output": "[[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 0, 7, 1, 0, 0], [1, 1, 1, 1, 7, 7, 7, 1, 1, 1, 7, 7, 7, 1, 0, 0], [1, 1, 1, 7, 7, 0, 7, 1, 1, 1, 1, 1, 1, 1, 0, 0], [1, 1, 7, 7, 0, 7, 7, 1, 1, 1, 1, 1, 1, 1, 0, 0], [1, 1, 7, 0, 7, 7, 1, 1, 1, 1, 7, 7, 7, 1, 0, 0], [1, 1, 7, 7, 7, 1, 1, 1, 1, 1, 7, 0, 7, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 0, 7, 1, 0, 0], [1, 1, 1, 1, 1, 7, 7, 7, 1, 1, 7, 7, 7, 1, 0, 0], [1, 1, 1, 1, 1, 7, 0, 7, 1, 1, 1, 1, 1, 1, 0, 0], [1, 1, 1, 1, 1, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 0.0, "error": null, "code": "def transform(grid):\n    \"\"\"\n    Transform the grid by:\n    1. Finding defect pixels using priority-based 4-neighbor majority voting.\n       A defect is a pixel where the majority of its 4-connected non-defect \n       neighbors have a different value. Defects are detected in priority order\n       (most confident first) to avoid cascading false positives at boundaries.\n    2. For defects that are 0 in a 1-region: keep the 0 and surround with 7-border\n    3. For defects that are 1 in a 0-region: correct to 0 (remove the anomaly)\n    \"\"\"\n    import numpy as np\n    import heapq\n\n    inp = np.array(grid)\n    H, W = inp.shape\n    is_defect = np.zeros((H, W), dtype=bool)\n\n    def compute_score(r, c):\n        \"\"\"Count different and same-valued non-defect 4-neighbors.\"\"\"\n        val = inp[r, c]\n        same = 0\n        diff = 0\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                if inp[nr, nc] == val:\n                    same += 1\n                else:\n                    diff += 1\n        return diff, same\n\n    # Priority queue: process most confident defects first (highest diff-same)\n    heap = []\n    for r in range(H):\n        for c in range(W):\n            diff, same = compute_score(r, c)\n            if diff > same:\n                heapq.heappush(heap, (-(diff - same), r, c))\n\n    while heap:\n        neg_score, r, c = heapq.heappop(heap)\n        if is_defect[r, c]:\n            continue\n\n        # Recompute with current defect state\n        diff, same = compute_score(r, c)\n        if diff <= same:\n            continue\n\n        # If score changed, re-insert with updated priority\n        if -(diff - same) != neg_score:\n            if diff > same:\n                heapq.heappush(heap, (-(diff - same), r, c))\n            continue\n\n        is_defect[r, c] = True\n\n        # Check if neighbors now qualify as defects\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                diff_n, same_n = compute_score(nr, nc)\n                if diff_n > same_n:\n                    heapq.heappush(heap, (-(diff_n - same_n), nr, nc))\n\n    # Build output grid\n    out = inp.copy()\n\n    for r in range(H):\n        for c in range(W):\n            if is_defect[r, c]:\n                if inp[r, c] == 0:\n                    # 0-in-1-region: keep 0, draw 7-border around it\n                    out[r, c] = 0\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = r + dr, c + dc\n                            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                                out[nr, nc] = 7\n                else:\n                    # 1-in-0-region: correct to 0 (remove anomaly)\n                    out[r, c] = 0\n\n    return out.tolist()\n"}, {"success": false, "output": "[[0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 7, 7, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 7, 7, 1], [0, 0, 1, 7, 0, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 0, 7, 1], [0, 0, 1, 7, 7, 7, 7, 7, 1, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 1, 1, 1, 7, 0, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 7, 7, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 7, 7, 7, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 7, 7, 0, 7, 7, 1, 0, 0, 1, 1, 7, 7, 7, 1, 1, 1], [0, 0, 1, 7, 0, 7, 0, 7, 1, 0, 0, 1, 1, 7, 0, 7, 1, 1, 1], [0, 0, 1, 7, 7, 7, 7, 7, 1, 0, 0, 1, 1, 7, 0, 7, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 7, 7, 7, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 1, 1, 1, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 7, 1, 1, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 7, 1, 1, 1, 1]]", "soft_score": 0.0, "error": null, "code": "def transform(grid):\n    \"\"\"\n    Transform the grid by:\n    1. Finding defect pixels using priority-based 4-neighbor majority voting.\n       A defect is a pixel where the majority of its 4-connected non-defect \n       neighbors have a different value. Defects are detected in priority order\n       (most confident first) to avoid cascading false positives at boundaries.\n    2. For defects that are 0 in a 1-region: keep the 0 and surround with 7-border\n    3. For defects that are 1 in a 0-region: correct to 0 (remove the anomaly)\n    \"\"\"\n    import numpy as np\n    import heapq\n\n    inp = np.array(grid)\n    H, W = inp.shape\n    is_defect = np.zeros((H, W), dtype=bool)\n\n    def compute_score(r, c):\n        \"\"\"Count different and same-valued non-defect 4-neighbors.\"\"\"\n        val = inp[r, c]\n        same = 0\n        diff = 0\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                if inp[nr, nc] == val:\n                    same += 1\n                else:\n                    diff += 1\n        return diff, same\n\n    # Priority queue: process most confident defects first (highest diff-same)\n    heap = []\n    for r in range(H):\n        for c in range(W):\n            diff, same = compute_score(r, c)\n            if diff > same:\n                heapq.heappush(heap, (-(diff - same), r, c))\n\n    while heap:\n        neg_score, r, c = heapq.heappop(heap)\n        if is_defect[r, c]:\n            continue\n\n        # Recompute with current defect state\n        diff, same = compute_score(r, c)\n        if diff <= same:\n            continue\n\n        # If score changed, re-insert with updated priority\n        if -(diff - same) != neg_score:\n            if diff > same:\n                heapq.heappush(heap, (-(diff - same), r, c))\n            continue\n\n        is_defect[r, c] = True\n\n        # Check if neighbors now qualify as defects\n        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                diff_n, same_n = compute_score(nr, nc)\n                if diff_n > same_n:\n                    heapq.heappush(heap, (-(diff_n - same_n), nr, nc))\n\n    # Build output grid\n    out = inp.copy()\n\n    for r in range(H):\n        for c in range(W):\n            if is_defect[r, c]:\n                if inp[r, c] == 0:\n                    # 0-in-1-region: keep 0, draw 7-border around it\n                    out[r, c] = 0\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = r + dr, c + dc\n                            if 0 <= nr < H and 0 <= nc < W and not is_defect[nr, nc]:\n                                out[nr, nc] = 7\n                else:\n                    # 1-in-0-region: correct to 0 (remove anomaly)\n                    out[r, c] = 0\n\n    return out.tolist()\n"}], "agent_usage": [{"input_tokens": 1238214, "input_tokens_details": {"cached_tokens": 1185771}, "output_tokens": 29563, "output_tokens_details": {"reasoning_tokens": -42}, "total_tokens": 29607, "inference_count": 42, "cache_creation": {"ephemeral_1h_input_tokens": 52399, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 52399, "inference_geo": ["global"], "service_tier": ["standard"]}], "time_taken": 756.8275706768036, "num_agents_used": 1, "model": "anthropic/claude-opus-4-6", "reasoning_effort": "high", "error": null, "problem_id": "71e489b6", "attempt_id": 0, "num": 0, "iteration": 42}