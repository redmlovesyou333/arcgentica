{"train_results": [{"success": true, "output": "[[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 8, 8, 8, 8, 2, 2, 1, 1, 2, 2], [2, 2, 8, 8, 8, 8, 2, 2, 1, 1, 2, 2], [2, 2, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2], [2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 2, 2], [2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]", "soft_score": 1.0, "error": null, "code": "def transform(grid):\n    import numpy as np\n    from scipy.ndimage import label\n    from math import gcd\n    from functools import reduce\n\n    grid = np.array(grid)\n    H, W = grid.shape\n\n    # Find all non-zero colors\n    colors = [int(c) for c in np.unique(grid) if c != 0]\n\n    # Identify template: rectangular region of one color with 0-holes, solid border\n    template_color = None\n    template_box = None\n    for c in colors:\n        positions = np.argwhere(grid == c)\n        min_r, min_c = positions.min(axis=0)\n        max_r, max_c = positions.max(axis=0)\n        region = grid[min_r:max_r+1, min_c:max_c+1]\n        border_ok = (\n            np.all(region[0, :] == c) and\n            np.all(region[-1, :] == c) and\n            np.all(region[:, 0] == c) and\n            np.all(region[:, -1] == c)\n        )\n        interior_ok = np.all((region == c) | (region == 0))\n        has_holes = np.any(region == 0)\n        if border_ok and interior_ok and has_holes:\n            template_color = c\n            template_box = (int(min_r), int(min_c), int(max_r), int(max_c))\n            break\n\n    r0, c0, r1, c1 = template_box\n    template = grid[r0:r1+1, c0:c1+1]\n    template_h, template_w = template.shape\n\n    # Find connected components of all non-template, non-zero colors\n    other_colors = [c for c in colors if c != template_color]\n\n    # Collect all connected components of non-template colors\n    all_components = []\n    for c in other_colors:\n        mask_c = (grid == c).astype(int)\n        labeled_c, num_c = label(mask_c)\n        for comp_id in range(1, num_c + 1):\n            comp_pos = np.argwhere(labeled_c == comp_id)\n            comp_min_r, comp_min_c = comp_pos.min(axis=0)\n            comp_max_r, comp_max_c = comp_pos.max(axis=0)\n            comp_h = int(comp_max_r - comp_min_r + 1)\n            comp_w = int(comp_max_c - comp_min_c + 1)\n            comp_region = np.zeros((comp_h, comp_w), dtype=int)\n            for pr, pc in comp_pos:\n                comp_region[pr - comp_min_r, pc - comp_min_c] = 1\n            all_components.append({\n                'color': c,\n                'region': comp_region,\n                'h': comp_h,\n                'w': comp_w,\n                'count': len(comp_pos)\n            })\n\n    # Determine scale factor from the larger components (filter out noise)\n    large_components = [comp for comp in all_components if comp['count'] >= 4]\n    if not large_components:\n        large_components = [comp for comp in all_components if comp['count'] >= 2]\n\n    all_dims = []\n    for comp in large_components:\n        all_dims.extend([comp['h'], comp['w']])\n\n    scale = reduce(gcd, all_dims)\n\n    # Find hole regions in template\n    holes = (template == 0).astype(int)\n    labeled_holes, num_holes = label(holes)\n\n    hole_regions = {}\n    for rid in range(1, num_holes + 1):\n        positions = np.argwhere(labeled_holes == rid)\n        min_r_h, min_c_h = positions.min(axis=0)\n        max_r_h, max_c_h = positions.max(axis=0)\n        pattern = np.zeros((max_r_h - min_r_h + 1, max_c_h - min_c_h + 1), dtype=int)\n        for r, c in positions:\n            pattern[r - min_r_h, c - min_c_h] = 1\n        hole_regions[rid] = {\n            'pattern': pattern,\n            'positions': positions,\n            'min_r': min_r_h,\n            'min_c': min_c_h,\n            'count': len(positions)\n        }\n\n    # Downsample shape components by scale\n    ds_shapes = []\n    for comp in all_components:\n        if comp['h'] % scale != 0 or comp['w'] % scale != 0:\n            continue  # skip noise components\n        if comp['count'] < scale * scale:\n            continue  # skip very small components\n        ds_h = comp['h'] // scale\n        ds_w = comp['w'] // scale\n        ds = np.zeros((ds_h, ds_w), dtype=int)\n        for r in range(ds_h):\n            for c in range(ds_w):\n                ds[r, c] = comp['region'][scale * r, scale * c]\n        ds_shapes.append({'color': comp['color'], 'pattern': ds})\n\n    # Get all orientations (rotations + reflections)\n    def get_all_orientations(pattern):\n        orientations = set()\n        for k in range(4):\n            rotated = np.rot90(pattern, k)\n            orientations.add(tuple(map(tuple, rotated)))\n            flipped = np.fliplr(rotated)\n            orientations.add(tuple(map(tuple, flipped)))\n        return orientations\n\n    # Build output: template scaled up, filled with template color\n    out_h = template_h * scale\n    out_w = template_w * scale\n    output = np.full((out_h, out_w), template_color, dtype=int)\n\n    # Match hole regions to downsampled shapes and fill\n    used_shapes = set()\n    for rid, rinfo in hole_regions.items():\n        r_pattern = rinfo['pattern']\n        r_tuple = tuple(map(tuple, r_pattern))\n\n        for si, sinfo in enumerate(ds_shapes):\n            if si in used_shapes:\n                continue\n            s_orientations = get_all_orientations(sinfo['pattern'])\n            if r_tuple in s_orientations:\n                # Fill the hole region cells with the shape's color\n                for pos in rinfo['positions']:\n                    tr, tc = pos\n                    for dr in range(scale):\n                        for dc in range(scale):\n                            output[tr * scale + dr, tc * scale + dc] = sinfo['color']\n                used_shapes.add(si)\n                break\n\n    return output.tolist()\n"}, {"success": true, "output": "[[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 5, 5, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3], [3, 3, 5, 5, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 3, 3, 3, 3], [3, 3, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 3, 3, 3, 3], [3, 3, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]]", "soft_score": 1.0, "error": null, "code": "def transform(grid):\n    import numpy as np\n    from scipy.ndimage import label\n    from math import gcd\n    from functools import reduce\n\n    grid = np.array(grid)\n    H, W = grid.shape\n\n    # Find all non-zero colors\n    colors = [int(c) for c in np.unique(grid) if c != 0]\n\n    # Identify template: rectangular region of one color with 0-holes, solid border\n    template_color = None\n    template_box = None\n    for c in colors:\n        positions = np.argwhere(grid == c)\n        min_r, min_c = positions.min(axis=0)\n        max_r, max_c = positions.max(axis=0)\n        region = grid[min_r:max_r+1, min_c:max_c+1]\n        border_ok = (\n            np.all(region[0, :] == c) and\n            np.all(region[-1, :] == c) and\n            np.all(region[:, 0] == c) and\n            np.all(region[:, -1] == c)\n        )\n        interior_ok = np.all((region == c) | (region == 0))\n        has_holes = np.any(region == 0)\n        if border_ok and interior_ok and has_holes:\n            template_color = c\n            template_box = (int(min_r), int(min_c), int(max_r), int(max_c))\n            break\n\n    r0, c0, r1, c1 = template_box\n    template = grid[r0:r1+1, c0:c1+1]\n    template_h, template_w = template.shape\n\n    # Find connected components of all non-template, non-zero colors\n    other_colors = [c for c in colors if c != template_color]\n\n    # Collect all connected components of non-template colors\n    all_components = []\n    for c in other_colors:\n        mask_c = (grid == c).astype(int)\n        labeled_c, num_c = label(mask_c)\n        for comp_id in range(1, num_c + 1):\n            comp_pos = np.argwhere(labeled_c == comp_id)\n            comp_min_r, comp_min_c = comp_pos.min(axis=0)\n            comp_max_r, comp_max_c = comp_pos.max(axis=0)\n            comp_h = int(comp_max_r - comp_min_r + 1)\n            comp_w = int(comp_max_c - comp_min_c + 1)\n            comp_region = np.zeros((comp_h, comp_w), dtype=int)\n            for pr, pc in comp_pos:\n                comp_region[pr - comp_min_r, pc - comp_min_c] = 1\n            all_components.append({\n                'color': c,\n                'region': comp_region,\n                'h': comp_h,\n                'w': comp_w,\n                'count': len(comp_pos)\n            })\n\n    # Determine scale factor from the larger components (filter out noise)\n    large_components = [comp for comp in all_components if comp['count'] >= 4]\n    if not large_components:\n        large_components = [comp for comp in all_components if comp['count'] >= 2]\n\n    all_dims = []\n    for comp in large_components:\n        all_dims.extend([comp['h'], comp['w']])\n\n    scale = reduce(gcd, all_dims)\n\n    # Find hole regions in template\n    holes = (template == 0).astype(int)\n    labeled_holes, num_holes = label(holes)\n\n    hole_regions = {}\n    for rid in range(1, num_holes + 1):\n        positions = np.argwhere(labeled_holes == rid)\n        min_r_h, min_c_h = positions.min(axis=0)\n        max_r_h, max_c_h = positions.max(axis=0)\n        pattern = np.zeros((max_r_h - min_r_h + 1, max_c_h - min_c_h + 1), dtype=int)\n        for r, c in positions:\n            pattern[r - min_r_h, c - min_c_h] = 1\n        hole_regions[rid] = {\n            'pattern': pattern,\n            'positions': positions,\n            'min_r': min_r_h,\n            'min_c': min_c_h,\n            'count': len(positions)\n        }\n\n    # Downsample shape components by scale\n    ds_shapes = []\n    for comp in all_components:\n        if comp['h'] % scale != 0 or comp['w'] % scale != 0:\n            continue  # skip noise components\n        if comp['count'] < scale * scale:\n            continue  # skip very small components\n        ds_h = comp['h'] // scale\n        ds_w = comp['w'] // scale\n        ds = np.zeros((ds_h, ds_w), dtype=int)\n        for r in range(ds_h):\n            for c in range(ds_w):\n                ds[r, c] = comp['region'][scale * r, scale * c]\n        ds_shapes.append({'color': comp['color'], 'pattern': ds})\n\n    # Get all orientations (rotations + reflections)\n    def get_all_orientations(pattern):\n        orientations = set()\n        for k in range(4):\n            rotated = np.rot90(pattern, k)\n            orientations.add(tuple(map(tuple, rotated)))\n            flipped = np.fliplr(rotated)\n            orientations.add(tuple(map(tuple, flipped)))\n        return orientations\n\n    # Build output: template scaled up, filled with template color\n    out_h = template_h * scale\n    out_w = template_w * scale\n    output = np.full((out_h, out_w), template_color, dtype=int)\n\n    # Match hole regions to downsampled shapes and fill\n    used_shapes = set()\n    for rid, rinfo in hole_regions.items():\n        r_pattern = rinfo['pattern']\n        r_tuple = tuple(map(tuple, r_pattern))\n\n        for si, sinfo in enumerate(ds_shapes):\n            if si in used_shapes:\n                continue\n            s_orientations = get_all_orientations(sinfo['pattern'])\n            if r_tuple in s_orientations:\n                # Fill the hole region cells with the shape's color\n                for pos in rinfo['positions']:\n                    tr, tc = pos\n                    for dr in range(scale):\n                        for dc in range(scale):\n                            output[tr * scale + dr, tc * scale + dc] = sinfo['color']\n                used_shapes.add(si)\n                break\n\n    return output.tolist()\n"}], "test_results": [{"success": false, "output": "[[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 8, 8, 8, 4, 4, 4, 8, 8, 8, 4, 4, 4, 4, 4, 4, 5, 5, 5, 4, 4, 4, 5, 5, 5, 4, 4, 4], [4, 4, 4, 8, 8, 8, 4, 4, 4, 8, 8, 8, 4, 4, 4, 4, 4, 4, 5, 5, 5, 4, 4, 4, 5, 5, 5, 4, 4, 4], [4, 4, 4, 8, 8, 8, 4, 4, 4, 8, 8, 8, 4, 4, 4, 4, 4, 4, 5, 5, 5, 4, 4, 4, 5, 5, 5, 4, 4, 4], [4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4], [4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4], [4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4], [4, 4, 4, 8, 8, 8, 4, 4, 4, 8, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 4, 4, 4], [4, 4, 4, 8, 8, 8, 4, 4, 4, 8, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 4, 4, 4], [4, 4, 4, 8, 8, 8, 4, 4, 4, 8, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4, 9, 9, 9, 9, 9, 9, 9, 9, 9, 4, 4, 4, 4, 4, 4], [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4, 9, 9, 9, 9, 9, 9, 9, 9, 9, 4, 4, 4, 4, 4, 4], [4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4, 9, 9, 9, 9, 9, 9, 9, 9, 9, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 4, 4, 9, 9, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 4, 4, 9, 9, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 4, 4, 9, 9, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 4, 4, 9, 9, 9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 4, 4, 4], [4, 4, 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 4, 4, 9, 9, 9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 4, 4, 4], [4, 4, 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 4, 4, 9, 9, 9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]]", "soft_score": 0.0, "error": null, "code": "def transform(grid):\n    import numpy as np\n    from scipy.ndimage import label\n    from math import gcd\n    from functools import reduce\n\n    grid = np.array(grid)\n    H, W = grid.shape\n\n    # Find all non-zero colors\n    colors = [int(c) for c in np.unique(grid) if c != 0]\n\n    # Identify template: rectangular region of one color with 0-holes, solid border\n    template_color = None\n    template_box = None\n    for c in colors:\n        positions = np.argwhere(grid == c)\n        min_r, min_c = positions.min(axis=0)\n        max_r, max_c = positions.max(axis=0)\n        region = grid[min_r:max_r+1, min_c:max_c+1]\n        border_ok = (\n            np.all(region[0, :] == c) and\n            np.all(region[-1, :] == c) and\n            np.all(region[:, 0] == c) and\n            np.all(region[:, -1] == c)\n        )\n        interior_ok = np.all((region == c) | (region == 0))\n        has_holes = np.any(region == 0)\n        if border_ok and interior_ok and has_holes:\n            template_color = c\n            template_box = (int(min_r), int(min_c), int(max_r), int(max_c))\n            break\n\n    r0, c0, r1, c1 = template_box\n    template = grid[r0:r1+1, c0:c1+1]\n    template_h, template_w = template.shape\n\n    # Find connected components of all non-template, non-zero colors\n    other_colors = [c for c in colors if c != template_color]\n\n    # Collect all connected components of non-template colors\n    all_components = []\n    for c in other_colors:\n        mask_c = (grid == c).astype(int)\n        labeled_c, num_c = label(mask_c)\n        for comp_id in range(1, num_c + 1):\n            comp_pos = np.argwhere(labeled_c == comp_id)\n            comp_min_r, comp_min_c = comp_pos.min(axis=0)\n            comp_max_r, comp_max_c = comp_pos.max(axis=0)\n            comp_h = int(comp_max_r - comp_min_r + 1)\n            comp_w = int(comp_max_c - comp_min_c + 1)\n            comp_region = np.zeros((comp_h, comp_w), dtype=int)\n            for pr, pc in comp_pos:\n                comp_region[pr - comp_min_r, pc - comp_min_c] = 1\n            all_components.append({\n                'color': c,\n                'region': comp_region,\n                'h': comp_h,\n                'w': comp_w,\n                'count': len(comp_pos)\n            })\n\n    # Determine scale factor from the larger components (filter out noise)\n    large_components = [comp for comp in all_components if comp['count'] >= 4]\n    if not large_components:\n        large_components = [comp for comp in all_components if comp['count'] >= 2]\n\n    all_dims = []\n    for comp in large_components:\n        all_dims.extend([comp['h'], comp['w']])\n\n    scale = reduce(gcd, all_dims)\n\n    # Find hole regions in template\n    holes = (template == 0).astype(int)\n    labeled_holes, num_holes = label(holes)\n\n    hole_regions = {}\n    for rid in range(1, num_holes + 1):\n        positions = np.argwhere(labeled_holes == rid)\n        min_r_h, min_c_h = positions.min(axis=0)\n        max_r_h, max_c_h = positions.max(axis=0)\n        pattern = np.zeros((max_r_h - min_r_h + 1, max_c_h - min_c_h + 1), dtype=int)\n        for r, c in positions:\n            pattern[r - min_r_h, c - min_c_h] = 1\n        hole_regions[rid] = {\n            'pattern': pattern,\n            'positions': positions,\n            'min_r': min_r_h,\n            'min_c': min_c_h,\n            'count': len(positions)\n        }\n\n    # Downsample shape components by scale\n    ds_shapes = []\n    for comp in all_components:\n        if comp['h'] % scale != 0 or comp['w'] % scale != 0:\n            continue  # skip noise components\n        if comp['count'] < scale * scale:\n            continue  # skip very small components\n        ds_h = comp['h'] // scale\n        ds_w = comp['w'] // scale\n        ds = np.zeros((ds_h, ds_w), dtype=int)\n        for r in range(ds_h):\n            for c in range(ds_w):\n                ds[r, c] = comp['region'][scale * r, scale * c]\n        ds_shapes.append({'color': comp['color'], 'pattern': ds})\n\n    # Get all orientations (rotations + reflections)\n    def get_all_orientations(pattern):\n        orientations = set()\n        for k in range(4):\n            rotated = np.rot90(pattern, k)\n            orientations.add(tuple(map(tuple, rotated)))\n            flipped = np.fliplr(rotated)\n            orientations.add(tuple(map(tuple, flipped)))\n        return orientations\n\n    # Build output: template scaled up, filled with template color\n    out_h = template_h * scale\n    out_w = template_w * scale\n    output = np.full((out_h, out_w), template_color, dtype=int)\n\n    # Match hole regions to downsampled shapes and fill\n    used_shapes = set()\n    for rid, rinfo in hole_regions.items():\n        r_pattern = rinfo['pattern']\n        r_tuple = tuple(map(tuple, r_pattern))\n\n        for si, sinfo in enumerate(ds_shapes):\n            if si in used_shapes:\n                continue\n            s_orientations = get_all_orientations(sinfo['pattern'])\n            if r_tuple in s_orientations:\n                # Fill the hole region cells with the shape's color\n                for pos in rinfo['positions']:\n                    tr, tc = pos\n                    for dr in range(scale):\n                        for dc in range(scale):\n                            output[tr * scale + dr, tc * scale + dc] = sinfo['color']\n                used_shapes.add(si)\n                break\n\n    return output.tolist()\n"}], "agent_usage": [{"input_tokens": 1007798, "input_tokens_details": {"cached_tokens": 963114}, "output_tokens": 24583, "output_tokens_details": {"reasoning_tokens": -40}, "total_tokens": 24625, "inference_count": 40, "cache_creation": {"ephemeral_1h_input_tokens": 44642, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 44642, "inference_geo": ["global"], "service_tier": ["standard"]}], "time_taken": 428.6693797111511, "num_agents_used": 1, "model": "anthropic/claude-opus-4-6", "reasoning_effort": "high", "error": null, "problem_id": "898e7135", "attempt_id": 1, "num": 0, "iteration": 40}