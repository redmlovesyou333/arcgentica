{"train_results": [{"success": true, "output": "[[0, 0, 0, 2, 2, 3, 3, 3, 0, 0], [0, 0, 0, 2, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 1, 1, 0, 3, 0, 0], [0, 0, 0, 3, 1, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 1, 3, 0, 0], [0, 0, 0, 3, 0, 1, 1, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 2, 0, 0], [0, 0, 0, 3, 3, 3, 2, 2, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 3, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform an ARC grid by filling rectangles defined by L-shape pairs.\n\n    The transformation:\n    1. Identifies the background color (most frequent).\n    2. Finds the legend region (most color-diverse non-bg connected component).\n    3. Parses the legend as a 2-column table: (shape_color, fill_color) per row.\n    4. Groups legend entries into blocks of 2 rows. A block is active only if \n       all shapes in it have scene presence (non-legend cells in the grid).\n    5. For each active entry: fills the bounding rectangle of the shape's scene cells\n       with the fill color. L-shapes (proper 3-cell pairs) are preserved on top.\n    6. Priority: first legend row = highest priority (drawn last, wins overlaps).\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    bg = int(np.bincount(grid.flatten()).argmax())\n\n    # Find connected components of non-bg cells\n    non_bg_mask = grid != bg\n    labeled_all, n_all = label(non_bg_mask)\n\n    # Find legend region (most color-diverse non-bg connected component)\n    best_region = None\n    best_diversity = 0\n    for i in range(1, n_all + 1):\n        cells = np.argwhere(labeled_all == i)\n        colors = set(int(grid[r, c]) for r, c in cells)\n        diversity = len(colors)\n        if diversity > best_diversity:\n            best_diversity = diversity\n            best_region = i\n\n    legend_cell_set = set()\n    if best_region is not None:\n        for r, c in np.argwhere(labeled_all == best_region):\n            legend_cell_set.add((int(r), int(c)))\n\n    # Parse legend as 2-column table\n    legend_positions = sorted(legend_cell_set)\n    l_rows = sorted(set(r for r, c in legend_positions))\n    l_cols = sorted(set(c for r, c in legend_positions))\n    col0, col1 = l_cols[0], l_cols[-1]\n\n    legend_entries = []\n    for r in l_rows:\n        v0 = int(grid[r, col0])\n        v1 = int(grid[r, col1])\n        legend_entries.append((v0, v1))\n\n    # Group legend entries into blocks of 2\n    blocks = []\n    for i in range(0, len(legend_entries), 2):\n        if i + 1 < len(legend_entries):\n            blocks.append([i, i + 1])\n        else:\n            blocks.append([i])\n\n    # Find scene cells (non-legend, non-bg)\n    scene_cells = {}\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in legend_cell_set and grid[r, c] != bg:\n                color = int(grid[r, c])\n                if color not in scene_cells:\n                    scene_cells[color] = []\n                scene_cells[color].append((r, c))\n\n    # Find connected components for each scene color\n    scene_components = {}\n    for color, cells in scene_cells.items():\n        mask = np.zeros_like(grid, dtype=bool)\n        for r, c in cells:\n            mask[r, c] = True\n        labeled_c, n_c = label(mask)\n        comps = []\n        for i in range(1, n_c + 1):\n            comp_cells = [tuple(x) for x in np.argwhere(labeled_c == i)]\n            comps.append(comp_cells)\n        scene_components[color] = comps\n\n    def is_l_shape_pair(color):\n        \"\"\"Check if a color has exactly 2 components, each with 3 cells (L-shapes).\"\"\"\n        comps = scene_components.get(color, [])\n        return len(comps) == 2 and all(len(c) == 3 for c in comps)\n\n    def has_scene_presence(color):\n        return color in scene_cells and len(scene_cells[color]) > 0\n\n    def get_bbox(color):\n        cells = scene_cells[color]\n        rs = [r for r, c in cells]\n        cs = [c for r, c in cells]\n        return min(rs), min(cs), max(rs), max(cs)\n\n    # Determine active entries based on block membership\n    active_rows = set()\n    for block in blocks:\n        block_entries = [legend_entries[i] for i in block]\n        if all(has_scene_presence(entry[0]) for entry in block_entries):\n            for i in block:\n                active_rows.add(i)\n\n    # Build fill operations\n    result = grid.copy()\n    fill_ops = []\n\n    for row_idx in active_rows:\n        shape_color, fill_color = legend_entries[row_idx]\n        if not has_scene_presence(shape_color):\n            continue\n        bbox = get_bbox(shape_color)\n        preserve = is_l_shape_pair(shape_color)\n        # Row 0 = highest priority (drawn last)\n        priority = len(legend_entries) - 1 - row_idx\n        fill_ops.append((priority, shape_color, fill_color, bbox, preserve))\n\n    # Draw fills: lowest priority first, highest last\n    fill_ops.sort(key=lambda x: x[0])\n\n    for priority, shape_color, fill_color, bbox, preserve in fill_ops:\n        r_min, c_min, r_max, c_max = bbox\n        for r in range(r_min, r_max + 1):\n            for c in range(c_min, c_max + 1):\n                result[r, c] = fill_color\n\n    # Preserve L-shapes on top\n    for priority, shape_color, fill_color, bbox, preserve in fill_ops:\n        if preserve:\n            for r, c in scene_cells[shape_color]:\n                result[r, c] = shape_color\n\n    return result.tolist()\n"}, {"success": true, "output": "[[0, 0, 0, 0, 5, 5, 5, 5, 4, 4], [0, 0, 0, 0, 5, 5, 5, 5, 5, 4], [0, 0, 0, 0, 5, 1, 1, 3, 5, 5], [0, 0, 0, 0, 5, 1, 3, 3, 5, 5], [0, 0, 0, 0, 5, 3, 3, 3, 5, 5], [0, 0, 0, 0, 5, 3, 3, 3, 5, 5], [0, 0, 0, 0, 5, 3, 3, 1, 5, 5], [0, 1, 3, 0, 4, 3, 1, 1, 5, 5], [0, 4, 5, 0, 4, 4, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform an ARC grid by filling rectangles defined by L-shape pairs.\n\n    The transformation:\n    1. Identifies the background color (most frequent).\n    2. Finds the legend region (most color-diverse non-bg connected component).\n    3. Parses the legend as a 2-column table: (shape_color, fill_color) per row.\n    4. Groups legend entries into blocks of 2 rows. A block is active only if \n       all shapes in it have scene presence (non-legend cells in the grid).\n    5. For each active entry: fills the bounding rectangle of the shape's scene cells\n       with the fill color. L-shapes (proper 3-cell pairs) are preserved on top.\n    6. Priority: first legend row = highest priority (drawn last, wins overlaps).\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    bg = int(np.bincount(grid.flatten()).argmax())\n\n    # Find connected components of non-bg cells\n    non_bg_mask = grid != bg\n    labeled_all, n_all = label(non_bg_mask)\n\n    # Find legend region (most color-diverse non-bg connected component)\n    best_region = None\n    best_diversity = 0\n    for i in range(1, n_all + 1):\n        cells = np.argwhere(labeled_all == i)\n        colors = set(int(grid[r, c]) for r, c in cells)\n        diversity = len(colors)\n        if diversity > best_diversity:\n            best_diversity = diversity\n            best_region = i\n\n    legend_cell_set = set()\n    if best_region is not None:\n        for r, c in np.argwhere(labeled_all == best_region):\n            legend_cell_set.add((int(r), int(c)))\n\n    # Parse legend as 2-column table\n    legend_positions = sorted(legend_cell_set)\n    l_rows = sorted(set(r for r, c in legend_positions))\n    l_cols = sorted(set(c for r, c in legend_positions))\n    col0, col1 = l_cols[0], l_cols[-1]\n\n    legend_entries = []\n    for r in l_rows:\n        v0 = int(grid[r, col0])\n        v1 = int(grid[r, col1])\n        legend_entries.append((v0, v1))\n\n    # Group legend entries into blocks of 2\n    blocks = []\n    for i in range(0, len(legend_entries), 2):\n        if i + 1 < len(legend_entries):\n            blocks.append([i, i + 1])\n        else:\n            blocks.append([i])\n\n    # Find scene cells (non-legend, non-bg)\n    scene_cells = {}\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in legend_cell_set and grid[r, c] != bg:\n                color = int(grid[r, c])\n                if color not in scene_cells:\n                    scene_cells[color] = []\n                scene_cells[color].append((r, c))\n\n    # Find connected components for each scene color\n    scene_components = {}\n    for color, cells in scene_cells.items():\n        mask = np.zeros_like(grid, dtype=bool)\n        for r, c in cells:\n            mask[r, c] = True\n        labeled_c, n_c = label(mask)\n        comps = []\n        for i in range(1, n_c + 1):\n            comp_cells = [tuple(x) for x in np.argwhere(labeled_c == i)]\n            comps.append(comp_cells)\n        scene_components[color] = comps\n\n    def is_l_shape_pair(color):\n        \"\"\"Check if a color has exactly 2 components, each with 3 cells (L-shapes).\"\"\"\n        comps = scene_components.get(color, [])\n        return len(comps) == 2 and all(len(c) == 3 for c in comps)\n\n    def has_scene_presence(color):\n        return color in scene_cells and len(scene_cells[color]) > 0\n\n    def get_bbox(color):\n        cells = scene_cells[color]\n        rs = [r for r, c in cells]\n        cs = [c for r, c in cells]\n        return min(rs), min(cs), max(rs), max(cs)\n\n    # Determine active entries based on block membership\n    active_rows = set()\n    for block in blocks:\n        block_entries = [legend_entries[i] for i in block]\n        if all(has_scene_presence(entry[0]) for entry in block_entries):\n            for i in block:\n                active_rows.add(i)\n\n    # Build fill operations\n    result = grid.copy()\n    fill_ops = []\n\n    for row_idx in active_rows:\n        shape_color, fill_color = legend_entries[row_idx]\n        if not has_scene_presence(shape_color):\n            continue\n        bbox = get_bbox(shape_color)\n        preserve = is_l_shape_pair(shape_color)\n        # Row 0 = highest priority (drawn last)\n        priority = len(legend_entries) - 1 - row_idx\n        fill_ops.append((priority, shape_color, fill_color, bbox, preserve))\n\n    # Draw fills: lowest priority first, highest last\n    fill_ops.sort(key=lambda x: x[0])\n\n    for priority, shape_color, fill_color, bbox, preserve in fill_ops:\n        r_min, c_min, r_max, c_max = bbox\n        for r in range(r_min, r_max + 1):\n            for c in range(c_min, c_max + 1):\n                result[r, c] = fill_color\n\n    # Preserve L-shapes on top\n    for priority, shape_color, fill_color, bbox, preserve in fill_ops:\n        if preserve:\n            for r, c in scene_cells[shape_color]:\n                result[r, c] = shape_color\n\n    return result.tolist()\n"}, {"success": true, "output": "[[3, 3, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 5, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 2, 2, 9, 9, 9, 9, 9, 9, 9, 9, 3, 3, 3], [3, 3, 3, 3, 2, 9, 9, 9, 9, 9, 9, 9, 9, 9, 3, 3, 3], [3, 3, 3, 3, 9, 9, 9, 6, 6, 1, 1, 9, 9, 2, 3, 3, 3], [3, 3, 3, 3, 9, 9, 9, 6, 6, 6, 1, 9, 2, 2, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 3], [3, 3, 1, 6, 3, 3, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 3], [3, 3, 2, 9, 3, 3, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 3], [3, 3, 4, 0, 3, 3, 3, 1, 6, 6, 6, 3, 3, 3, 3, 3, 3], [3, 3, 8, 9, 3, 3, 3, 1, 1, 6, 6, 3, 3, 3, 3, 3, 3]]", "soft_score": 1.0, "error": null, "code": "\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform an ARC grid by filling rectangles defined by L-shape pairs.\n\n    The transformation:\n    1. Identifies the background color (most frequent).\n    2. Finds the legend region (most color-diverse non-bg connected component).\n    3. Parses the legend as a 2-column table: (shape_color, fill_color) per row.\n    4. Groups legend entries into blocks of 2 rows. A block is active only if \n       all shapes in it have scene presence (non-legend cells in the grid).\n    5. For each active entry: fills the bounding rectangle of the shape's scene cells\n       with the fill color. L-shapes (proper 3-cell pairs) are preserved on top.\n    6. Priority: first legend row = highest priority (drawn last, wins overlaps).\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    bg = int(np.bincount(grid.flatten()).argmax())\n\n    # Find connected components of non-bg cells\n    non_bg_mask = grid != bg\n    labeled_all, n_all = label(non_bg_mask)\n\n    # Find legend region (most color-diverse non-bg connected component)\n    best_region = None\n    best_diversity = 0\n    for i in range(1, n_all + 1):\n        cells = np.argwhere(labeled_all == i)\n        colors = set(int(grid[r, c]) for r, c in cells)\n        diversity = len(colors)\n        if diversity > best_diversity:\n            best_diversity = diversity\n            best_region = i\n\n    legend_cell_set = set()\n    if best_region is not None:\n        for r, c in np.argwhere(labeled_all == best_region):\n            legend_cell_set.add((int(r), int(c)))\n\n    # Parse legend as 2-column table\n    legend_positions = sorted(legend_cell_set)\n    l_rows = sorted(set(r for r, c in legend_positions))\n    l_cols = sorted(set(c for r, c in legend_positions))\n    col0, col1 = l_cols[0], l_cols[-1]\n\n    legend_entries = []\n    for r in l_rows:\n        v0 = int(grid[r, col0])\n        v1 = int(grid[r, col1])\n        legend_entries.append((v0, v1))\n\n    # Group legend entries into blocks of 2\n    blocks = []\n    for i in range(0, len(legend_entries), 2):\n        if i + 1 < len(legend_entries):\n            blocks.append([i, i + 1])\n        else:\n            blocks.append([i])\n\n    # Find scene cells (non-legend, non-bg)\n    scene_cells = {}\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in legend_cell_set and grid[r, c] != bg:\n                color = int(grid[r, c])\n                if color not in scene_cells:\n                    scene_cells[color] = []\n                scene_cells[color].append((r, c))\n\n    # Find connected components for each scene color\n    scene_components = {}\n    for color, cells in scene_cells.items():\n        mask = np.zeros_like(grid, dtype=bool)\n        for r, c in cells:\n            mask[r, c] = True\n        labeled_c, n_c = label(mask)\n        comps = []\n        for i in range(1, n_c + 1):\n            comp_cells = [tuple(x) for x in np.argwhere(labeled_c == i)]\n            comps.append(comp_cells)\n        scene_components[color] = comps\n\n    def is_l_shape_pair(color):\n        \"\"\"Check if a color has exactly 2 components, each with 3 cells (L-shapes).\"\"\"\n        comps = scene_components.get(color, [])\n        return len(comps) == 2 and all(len(c) == 3 for c in comps)\n\n    def has_scene_presence(color):\n        return color in scene_cells and len(scene_cells[color]) > 0\n\n    def get_bbox(color):\n        cells = scene_cells[color]\n        rs = [r for r, c in cells]\n        cs = [c for r, c in cells]\n        return min(rs), min(cs), max(rs), max(cs)\n\n    # Determine active entries based on block membership\n    active_rows = set()\n    for block in blocks:\n        block_entries = [legend_entries[i] for i in block]\n        if all(has_scene_presence(entry[0]) for entry in block_entries):\n            for i in block:\n                active_rows.add(i)\n\n    # Build fill operations\n    result = grid.copy()\n    fill_ops = []\n\n    for row_idx in active_rows:\n        shape_color, fill_color = legend_entries[row_idx]\n        if not has_scene_presence(shape_color):\n            continue\n        bbox = get_bbox(shape_color)\n        preserve = is_l_shape_pair(shape_color)\n        # Row 0 = highest priority (drawn last)\n        priority = len(legend_entries) - 1 - row_idx\n        fill_ops.append((priority, shape_color, fill_color, bbox, preserve))\n\n    # Draw fills: lowest priority first, highest last\n    fill_ops.sort(key=lambda x: x[0])\n\n    for priority, shape_color, fill_color, bbox, preserve in fill_ops:\n        r_min, c_min, r_max, c_max = bbox\n        for r in range(r_min, r_max + 1):\n            for c in range(c_min, c_max + 1):\n                result[r, c] = fill_color\n\n    # Preserve L-shapes on top\n    for priority, shape_color, fill_color, bbox, preserve in fill_ops:\n        if preserve:\n            for r, c in scene_cells[shape_color]:\n                result[r, c] = shape_color\n\n    return result.tolist()\n"}, {"success": true, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 6, 6, 7, 7, 7, 0, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 6, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [3, 3, 0, 0, 0, 0, 7, 7, 7, 7, 6, 0, 0, 0, 6, 6, 0, 0], [6, 7, 0, 0, 0, 0, 7, 7, 7, 6, 6, 0, 0, 0, 6, 6, 0, 0], [4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform an ARC grid by filling rectangles defined by L-shape pairs.\n\n    The transformation:\n    1. Identifies the background color (most frequent).\n    2. Finds the legend region (most color-diverse non-bg connected component).\n    3. Parses the legend as a 2-column table: (shape_color, fill_color) per row.\n    4. Groups legend entries into blocks of 2 rows. A block is active only if \n       all shapes in it have scene presence (non-legend cells in the grid).\n    5. For each active entry: fills the bounding rectangle of the shape's scene cells\n       with the fill color. L-shapes (proper 3-cell pairs) are preserved on top.\n    6. Priority: first legend row = highest priority (drawn last, wins overlaps).\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    bg = int(np.bincount(grid.flatten()).argmax())\n\n    # Find connected components of non-bg cells\n    non_bg_mask = grid != bg\n    labeled_all, n_all = label(non_bg_mask)\n\n    # Find legend region (most color-diverse non-bg connected component)\n    best_region = None\n    best_diversity = 0\n    for i in range(1, n_all + 1):\n        cells = np.argwhere(labeled_all == i)\n        colors = set(int(grid[r, c]) for r, c in cells)\n        diversity = len(colors)\n        if diversity > best_diversity:\n            best_diversity = diversity\n            best_region = i\n\n    legend_cell_set = set()\n    if best_region is not None:\n        for r, c in np.argwhere(labeled_all == best_region):\n            legend_cell_set.add((int(r), int(c)))\n\n    # Parse legend as 2-column table\n    legend_positions = sorted(legend_cell_set)\n    l_rows = sorted(set(r for r, c in legend_positions))\n    l_cols = sorted(set(c for r, c in legend_positions))\n    col0, col1 = l_cols[0], l_cols[-1]\n\n    legend_entries = []\n    for r in l_rows:\n        v0 = int(grid[r, col0])\n        v1 = int(grid[r, col1])\n        legend_entries.append((v0, v1))\n\n    # Group legend entries into blocks of 2\n    blocks = []\n    for i in range(0, len(legend_entries), 2):\n        if i + 1 < len(legend_entries):\n            blocks.append([i, i + 1])\n        else:\n            blocks.append([i])\n\n    # Find scene cells (non-legend, non-bg)\n    scene_cells = {}\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in legend_cell_set and grid[r, c] != bg:\n                color = int(grid[r, c])\n                if color not in scene_cells:\n                    scene_cells[color] = []\n                scene_cells[color].append((r, c))\n\n    # Find connected components for each scene color\n    scene_components = {}\n    for color, cells in scene_cells.items():\n        mask = np.zeros_like(grid, dtype=bool)\n        for r, c in cells:\n            mask[r, c] = True\n        labeled_c, n_c = label(mask)\n        comps = []\n        for i in range(1, n_c + 1):\n            comp_cells = [tuple(x) for x in np.argwhere(labeled_c == i)]\n            comps.append(comp_cells)\n        scene_components[color] = comps\n\n    def is_l_shape_pair(color):\n        \"\"\"Check if a color has exactly 2 components, each with 3 cells (L-shapes).\"\"\"\n        comps = scene_components.get(color, [])\n        return len(comps) == 2 and all(len(c) == 3 for c in comps)\n\n    def has_scene_presence(color):\n        return color in scene_cells and len(scene_cells[color]) > 0\n\n    def get_bbox(color):\n        cells = scene_cells[color]\n        rs = [r for r, c in cells]\n        cs = [c for r, c in cells]\n        return min(rs), min(cs), max(rs), max(cs)\n\n    # Determine active entries based on block membership\n    active_rows = set()\n    for block in blocks:\n        block_entries = [legend_entries[i] for i in block]\n        if all(has_scene_presence(entry[0]) for entry in block_entries):\n            for i in block:\n                active_rows.add(i)\n\n    # Build fill operations\n    result = grid.copy()\n    fill_ops = []\n\n    for row_idx in active_rows:\n        shape_color, fill_color = legend_entries[row_idx]\n        if not has_scene_presence(shape_color):\n            continue\n        bbox = get_bbox(shape_color)\n        preserve = is_l_shape_pair(shape_color)\n        # Row 0 = highest priority (drawn last)\n        priority = len(legend_entries) - 1 - row_idx\n        fill_ops.append((priority, shape_color, fill_color, bbox, preserve))\n\n    # Draw fills: lowest priority first, highest last\n    fill_ops.sort(key=lambda x: x[0])\n\n    for priority, shape_color, fill_color, bbox, preserve in fill_ops:\n        r_min, c_min, r_max, c_max = bbox\n        for r in range(r_min, r_max + 1):\n            for c in range(c_min, c_max + 1):\n                result[r, c] = fill_color\n\n    # Preserve L-shapes on top\n    for priority, shape_color, fill_color, bbox, preserve in fill_ops:\n        if preserve:\n            for r, c in scene_cells[shape_color]:\n                result[r, c] = shape_color\n\n    return result.tolist()\n"}], "test_results": [{"success": false, "output": "[[9, 9, 9, 9, 4, 4, 9, 2, 2, 9, 9, 9, 9], [9, 9, 9, 9, 4, 6, 9, 2, 2, 9, 9, 9, 9], [9, 9, 9, 9, 6, 6, 9, 2, 2, 9, 9, 9, 9], [9, 1, 1, 4, 4, 4, 4, 2, 2, 4, 4, 4, 1], [9, 1, 4, 4, 4, 4, 4, 2, 2, 4, 4, 1, 1], [9, 9, 9, 9, 6, 6, 9, 2, 2, 9, 9, 9, 9], [9, 9, 9, 9, 5, 5, 9, 2, 2, 9, 9, 9, 5], [9, 9, 9, 9, 5, 9, 9, 2, 2, 9, 9, 5, 5], [9, 9, 9, 9, 6, 6, 9, 2, 2, 9, 9, 9, 9], [9, 9, 9, 9, 3, 3, 9, 2, 2, 9, 9, 9, 3], [9, 9, 9, 9, 3, 9, 9, 2, 2, 9, 9, 3, 3], [9, 9, 9, 9, 6, 6, 9, 2, 2, 9, 9, 9, 9], [9, 9, 9, 9, 6, 6, 9, 2, 2, 9, 9, 9, 9], [9, 9, 9, 9, 6, 6, 9, 2, 2, 9, 9, 9, 9], [9, 2, 2, 9, 6, 6, 9, 2, 2, 9, 9, 9, 9], [9, 5, 9, 9, 6, 6, 9, 2, 2, 9, 9, 9, 9], [9, 3, 9, 9, 6, 6, 9, 2, 2, 9, 9, 9, 9], [9, 1, 4, 9, 6, 4, 9, 2, 2, 9, 9, 9, 9], [9, 4, 6, 9, 4, 4, 9, 2, 2, 9, 9, 9, 9]]", "soft_score": 0.0, "error": null, "code": "\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform an ARC grid by filling rectangles defined by L-shape pairs.\n\n    The transformation:\n    1. Identifies the background color (most frequent).\n    2. Finds the legend region (most color-diverse non-bg connected component).\n    3. Parses the legend as a 2-column table: (shape_color, fill_color) per row.\n    4. Groups legend entries into blocks of 2 rows. A block is active only if \n       all shapes in it have scene presence (non-legend cells in the grid).\n    5. For each active entry: fills the bounding rectangle of the shape's scene cells\n       with the fill color. L-shapes (proper 3-cell pairs) are preserved on top.\n    6. Priority: first legend row = highest priority (drawn last, wins overlaps).\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    bg = int(np.bincount(grid.flatten()).argmax())\n\n    # Find connected components of non-bg cells\n    non_bg_mask = grid != bg\n    labeled_all, n_all = label(non_bg_mask)\n\n    # Find legend region (most color-diverse non-bg connected component)\n    best_region = None\n    best_diversity = 0\n    for i in range(1, n_all + 1):\n        cells = np.argwhere(labeled_all == i)\n        colors = set(int(grid[r, c]) for r, c in cells)\n        diversity = len(colors)\n        if diversity > best_diversity:\n            best_diversity = diversity\n            best_region = i\n\n    legend_cell_set = set()\n    if best_region is not None:\n        for r, c in np.argwhere(labeled_all == best_region):\n            legend_cell_set.add((int(r), int(c)))\n\n    # Parse legend as 2-column table\n    legend_positions = sorted(legend_cell_set)\n    l_rows = sorted(set(r for r, c in legend_positions))\n    l_cols = sorted(set(c for r, c in legend_positions))\n    col0, col1 = l_cols[0], l_cols[-1]\n\n    legend_entries = []\n    for r in l_rows:\n        v0 = int(grid[r, col0])\n        v1 = int(grid[r, col1])\n        legend_entries.append((v0, v1))\n\n    # Group legend entries into blocks of 2\n    blocks = []\n    for i in range(0, len(legend_entries), 2):\n        if i + 1 < len(legend_entries):\n            blocks.append([i, i + 1])\n        else:\n            blocks.append([i])\n\n    # Find scene cells (non-legend, non-bg)\n    scene_cells = {}\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in legend_cell_set and grid[r, c] != bg:\n                color = int(grid[r, c])\n                if color not in scene_cells:\n                    scene_cells[color] = []\n                scene_cells[color].append((r, c))\n\n    # Find connected components for each scene color\n    scene_components = {}\n    for color, cells in scene_cells.items():\n        mask = np.zeros_like(grid, dtype=bool)\n        for r, c in cells:\n            mask[r, c] = True\n        labeled_c, n_c = label(mask)\n        comps = []\n        for i in range(1, n_c + 1):\n            comp_cells = [tuple(x) for x in np.argwhere(labeled_c == i)]\n            comps.append(comp_cells)\n        scene_components[color] = comps\n\n    def is_l_shape_pair(color):\n        \"\"\"Check if a color has exactly 2 components, each with 3 cells (L-shapes).\"\"\"\n        comps = scene_components.get(color, [])\n        return len(comps) == 2 and all(len(c) == 3 for c in comps)\n\n    def has_scene_presence(color):\n        return color in scene_cells and len(scene_cells[color]) > 0\n\n    def get_bbox(color):\n        cells = scene_cells[color]\n        rs = [r for r, c in cells]\n        cs = [c for r, c in cells]\n        return min(rs), min(cs), max(rs), max(cs)\n\n    # Determine active entries based on block membership\n    active_rows = set()\n    for block in blocks:\n        block_entries = [legend_entries[i] for i in block]\n        if all(has_scene_presence(entry[0]) for entry in block_entries):\n            for i in block:\n                active_rows.add(i)\n\n    # Build fill operations\n    result = grid.copy()\n    fill_ops = []\n\n    for row_idx in active_rows:\n        shape_color, fill_color = legend_entries[row_idx]\n        if not has_scene_presence(shape_color):\n            continue\n        bbox = get_bbox(shape_color)\n        preserve = is_l_shape_pair(shape_color)\n        # Row 0 = highest priority (drawn last)\n        priority = len(legend_entries) - 1 - row_idx\n        fill_ops.append((priority, shape_color, fill_color, bbox, preserve))\n\n    # Draw fills: lowest priority first, highest last\n    fill_ops.sort(key=lambda x: x[0])\n\n    for priority, shape_color, fill_color, bbox, preserve in fill_ops:\n        r_min, c_min, r_max, c_max = bbox\n        for r in range(r_min, r_max + 1):\n            for c in range(c_min, c_max + 1):\n                result[r, c] = fill_color\n\n    # Preserve L-shapes on top\n    for priority, shape_color, fill_color, bbox, preserve in fill_ops:\n        if preserve:\n            for r, c in scene_cells[shape_color]:\n                result[r, c] = shape_color\n\n    return result.tolist()\n"}, {"success": false, "output": "[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 2, 2, 1, 1, 1, 7, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 2, 2, 1, 1, 1, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 6, 6, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 6, 8, 3, 3, 4, 8, 8, 8, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 8, 8, 3, 4, 4, 8, 8, 6, 4, 2, 2, 1, 1], [1, 1, 3, 4, 1, 1, 8, 8, 4, 4, 3, 8, 6, 6, 4, 4, 2, 1, 1], [1, 1, 6, 8, 1, 1, 1, 1, 4, 3, 3, 1, 1, 4, 4, 4, 4, 1, 1], [1, 1, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4, 4, 4, 1, 1], [1, 1, 8, 2, 1, 1, 1, 1, 7, 1, 1, 1, 1, 2, 2, 4, 4, 1, 1], [1, 1, 2, 4, 1, 1, 1, 7, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]", "soft_score": 0.0, "error": null, "code": "\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform an ARC grid by filling rectangles defined by L-shape pairs.\n\n    The transformation:\n    1. Identifies the background color (most frequent).\n    2. Finds the legend region (most color-diverse non-bg connected component).\n    3. Parses the legend as a 2-column table: (shape_color, fill_color) per row.\n    4. Groups legend entries into blocks of 2 rows. A block is active only if \n       all shapes in it have scene presence (non-legend cells in the grid).\n    5. For each active entry: fills the bounding rectangle of the shape's scene cells\n       with the fill color. L-shapes (proper 3-cell pairs) are preserved on top.\n    6. Priority: first legend row = highest priority (drawn last, wins overlaps).\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    bg = int(np.bincount(grid.flatten()).argmax())\n\n    # Find connected components of non-bg cells\n    non_bg_mask = grid != bg\n    labeled_all, n_all = label(non_bg_mask)\n\n    # Find legend region (most color-diverse non-bg connected component)\n    best_region = None\n    best_diversity = 0\n    for i in range(1, n_all + 1):\n        cells = np.argwhere(labeled_all == i)\n        colors = set(int(grid[r, c]) for r, c in cells)\n        diversity = len(colors)\n        if diversity > best_diversity:\n            best_diversity = diversity\n            best_region = i\n\n    legend_cell_set = set()\n    if best_region is not None:\n        for r, c in np.argwhere(labeled_all == best_region):\n            legend_cell_set.add((int(r), int(c)))\n\n    # Parse legend as 2-column table\n    legend_positions = sorted(legend_cell_set)\n    l_rows = sorted(set(r for r, c in legend_positions))\n    l_cols = sorted(set(c for r, c in legend_positions))\n    col0, col1 = l_cols[0], l_cols[-1]\n\n    legend_entries = []\n    for r in l_rows:\n        v0 = int(grid[r, col0])\n        v1 = int(grid[r, col1])\n        legend_entries.append((v0, v1))\n\n    # Group legend entries into blocks of 2\n    blocks = []\n    for i in range(0, len(legend_entries), 2):\n        if i + 1 < len(legend_entries):\n            blocks.append([i, i + 1])\n        else:\n            blocks.append([i])\n\n    # Find scene cells (non-legend, non-bg)\n    scene_cells = {}\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in legend_cell_set and grid[r, c] != bg:\n                color = int(grid[r, c])\n                if color not in scene_cells:\n                    scene_cells[color] = []\n                scene_cells[color].append((r, c))\n\n    # Find connected components for each scene color\n    scene_components = {}\n    for color, cells in scene_cells.items():\n        mask = np.zeros_like(grid, dtype=bool)\n        for r, c in cells:\n            mask[r, c] = True\n        labeled_c, n_c = label(mask)\n        comps = []\n        for i in range(1, n_c + 1):\n            comp_cells = [tuple(x) for x in np.argwhere(labeled_c == i)]\n            comps.append(comp_cells)\n        scene_components[color] = comps\n\n    def is_l_shape_pair(color):\n        \"\"\"Check if a color has exactly 2 components, each with 3 cells (L-shapes).\"\"\"\n        comps = scene_components.get(color, [])\n        return len(comps) == 2 and all(len(c) == 3 for c in comps)\n\n    def has_scene_presence(color):\n        return color in scene_cells and len(scene_cells[color]) > 0\n\n    def get_bbox(color):\n        cells = scene_cells[color]\n        rs = [r for r, c in cells]\n        cs = [c for r, c in cells]\n        return min(rs), min(cs), max(rs), max(cs)\n\n    # Determine active entries based on block membership\n    active_rows = set()\n    for block in blocks:\n        block_entries = [legend_entries[i] for i in block]\n        if all(has_scene_presence(entry[0]) for entry in block_entries):\n            for i in block:\n                active_rows.add(i)\n\n    # Build fill operations\n    result = grid.copy()\n    fill_ops = []\n\n    for row_idx in active_rows:\n        shape_color, fill_color = legend_entries[row_idx]\n        if not has_scene_presence(shape_color):\n            continue\n        bbox = get_bbox(shape_color)\n        preserve = is_l_shape_pair(shape_color)\n        # Row 0 = highest priority (drawn last)\n        priority = len(legend_entries) - 1 - row_idx\n        fill_ops.append((priority, shape_color, fill_color, bbox, preserve))\n\n    # Draw fills: lowest priority first, highest last\n    fill_ops.sort(key=lambda x: x[0])\n\n    for priority, shape_color, fill_color, bbox, preserve in fill_ops:\n        r_min, c_min, r_max, c_max = bbox\n        for r in range(r_min, r_max + 1):\n            for c in range(c_min, c_max + 1):\n                result[r, c] = fill_color\n\n    # Preserve L-shapes on top\n    for priority, shape_color, fill_color, bbox, preserve in fill_ops:\n        if preserve:\n            for r, c in scene_cells[shape_color]:\n                result[r, c] = shape_color\n\n    return result.tolist()\n"}], "agent_usage": [{"input_tokens": 3674370, "input_tokens_details": {"cached_tokens": 3568578}, "output_tokens": 75620, "output_tokens_details": {"reasoning_tokens": -69}, "total_tokens": 75691, "inference_count": 69, "cache_creation": {"ephemeral_1h_input_tokens": 105721, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 105721, "inference_geo": ["global"], "service_tier": ["standard"]}, {"input_tokens": 746749, "input_tokens_details": {"cached_tokens": 705619}, "output_tokens": 25114, "output_tokens_details": {"reasoning_tokens": -29}, "total_tokens": 25145, "inference_count": 29, "cache_creation": {"ephemeral_1h_input_tokens": 41099, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 41099, "inference_geo": ["global"], "service_tier": ["standard"]}], "time_taken": 1788.5658032894135, "num_agents_used": 2, "model": "anthropic/claude-opus-4-6", "reasoning_effort": "high", "error": null, "problem_id": "9385bd28", "attempt_id": 0, "num": 0, "iteration": 69}