{"train_results": [{"success": true, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 7, 7, 5, 0], [2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 5, 7, 7, 5, 0], [2, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 5, 5, 1, 0], [0, 2, 2, 1, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 1, 0, 0, 0, 0, 2, 7, 2, 2, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 7, 7, 7, 7, 2, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 2, 7, 7, 2, 2, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 0, 0, 0, 1, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 3, 7, 7, 3, 0, 0, 0, 2, 2, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 3, 7, 7, 3, 0, 0, 2, 7, 7, 2, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 1, 3, 3, 1, 1, 1, 2, 7, 7, 2, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 7, 7, 7, 2, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 7, 7, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 7]]", "soft_score": 1.0, "error": null, "code": "def transform(grid):\n    \"\"\"Transform input grid by filling enclosed box interiors with seed color(s).\n\n    Rule:\n    1. Find background color (most common color in grid)\n    2. Find seed color(s) (colors appearing exactly once, non-background)\n    3. Find connected components of non-background cells (8-connectivity)\n    4. Find enclosed background regions (holes in non-background mask)\n    5. Also detect edge-bounded enclosed regions (boxes touching grid edge)\n    6. For each enclosed region:\n       - Determine box color (most common border color)\n       - Check if border is in same component as a seed\n       - Check if border touches non-box-color connectors\n       - If both conditions met: fill with matching seed color\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label as ndlabel, binary_fill_holes\n    from collections import Counter\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Find background color (most common)\n    color_counts = Counter(int(v) for v in grid.flat)\n    bg_color = color_counts.most_common(1)[0][0]\n\n    # Find seed colors (appear exactly once, non-background)\n    seeds = {}\n    for c, cnt in color_counts.items():\n        if cnt == 1 and c != bg_color:\n            pos = tuple(np.argwhere(grid == c)[0])\n            seeds[c] = pos\n\n    if not seeds:\n        return grid.tolist()\n\n    # Determine connector type for each seed (adjacent non-bg, non-seed colors)\n    seed_connector_types = {}\n    for seed_color, seed_pos in seeds.items():\n        r, c_pos = seed_pos\n        adj = set()\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c_pos + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    v = int(grid[nr, nc])\n                    if v != bg_color and v != seed_color:\n                        adj.add(v)\n        seed_connector_types[seed_color] = adj\n\n    struct8 = np.ones((3, 3), dtype=int)\n    nonbg = grid != bg_color\n    labeled, n_comp = ndlabel(nonbg, structure=struct8)\n\n    # Find standard enclosed regions\n    enclosed = binary_fill_holes(nonbg) & ~nonbg\n\n    # Find edge-bounded enclosed regions\n    struct4 = np.array([[0,1,0],[1,1,1],[0,1,0]])\n    bg_labeled, bg_n = ndlabel(grid == bg_color, structure=struct4)\n\n    for comp in range(1, bg_n + 1):\n        comp_cells = np.argwhere(bg_labeled == comp)\n\n        # Skip if already detected or too large\n        if any(enclosed[r, c] for r, c in comp_cells):\n            continue\n        if len(comp_cells) > 20:\n            continue\n\n        comp_set = set(map(tuple, comp_cells.tolist()))\n\n        # Must touch grid edge\n        touches_edge = any(\n            r == 0 or r == rows-1 or c == 0 or c == cols-1\n            for r, c in comp_set\n        )\n        if not touches_edge:\n            continue\n\n        # Check edge sealing: on each touched edge, the component's footprint\n        # must be bounded by non-bg cells on both sides\n        sealed = True\n        for edge_name, edge_vals, edge_idx in [\n            ('top', [c for r, c in comp_set if r == 0], 0),\n            ('bottom', [c for r, c in comp_set if r == rows-1], rows-1),\n            ('left', [r for r, c in comp_set if c == 0], 0),\n            ('right', [r for r, c in comp_set if c == cols-1], cols-1),\n        ]:\n            if not edge_vals:\n                continue\n            min_val = min(edge_vals)\n            max_val = max(edge_vals)\n            has_lower = has_upper = False\n\n            if edge_name in ('top', 'bottom'):\n                r_edge = edge_idx\n                for cc in range(min_val - 1, -1, -1):\n                    if grid[r_edge, cc] != bg_color:\n                        has_lower = True\n                        break\n                for cc in range(max_val + 1, cols):\n                    if grid[r_edge, cc] != bg_color:\n                        has_upper = True\n                        break\n            else:\n                c_edge = edge_idx\n                for rr in range(min_val - 1, -1, -1):\n                    if grid[rr, c_edge] != bg_color:\n                        has_lower = True\n                        break\n                for rr in range(max_val + 1, rows):\n                    if grid[rr, c_edge] != bg_color:\n                        has_upper = True\n                        break\n\n            if not (has_lower and has_upper):\n                sealed = False\n                break\n\n        if not sealed:\n            continue\n\n        # Box-like check: most common border color must be >= 75% of border\n        border_cells = set()\n        for r, c in comp_cells:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if grid[nr, nc] != bg_color:\n                            border_cells.add((nr, nc))\n\n        if border_cells:\n            bc_counts = Counter(int(grid[r, c]) for r, c in border_cells)\n            most_common_count = bc_counts.most_common(1)[0][1]\n            total_border = sum(bc_counts.values())\n            if most_common_count / total_border >= 0.75:\n                for r, c in comp_cells:\n                    enclosed[r, c] = True\n\n    # Label enclosed regions\n    enc_labeled, n_enc = ndlabel(enclosed)\n    output = grid.copy()\n\n    for j in range(1, n_enc + 1):\n        region = np.argwhere(enc_labeled == j)\n\n        # Find border cells (non-bg cells 8-adjacent to region)\n        border_cells = set()\n        for r, c in region:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if grid[nr, nc] != bg_color:\n                            border_cells.add((nr, nc))\n\n        if not border_cells:\n            continue\n\n        # Determine box color (most common border color)\n        bc_counts = Counter(int(grid[r, c]) for r, c in border_cells)\n        box_color = bc_counts.most_common(1)[0][0]\n\n        # Find which components the border belongs to\n        border_comps = set(int(labeled[r, c]) for r, c in border_cells)\n\n        # Find connector colors (non-bg, non-box-color in border neighborhood)\n        connector_colors = set()\n        for r, c in border_cells:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        v = int(grid[nr, nc])\n                        if v != bg_color and v != box_color:\n                            connector_colors.add(v)\n\n        if not connector_colors:\n            continue  # No connectors touching border -> don't fill\n\n        # Determine fill color by matching connector type to seed\n        fill_color = None\n\n        # First try: match seed's connector type with region's connectors\n        for seed_color, seed_pos in seeds.items():\n            seed_comp = int(labeled[seed_pos[0], seed_pos[1]])\n            if seed_comp not in border_comps:\n                continue\n            seed_conn = seed_connector_types.get(seed_color, set())\n            if connector_colors & seed_conn:\n                fill_color = seed_color\n                break\n\n        # Fallback: any seed in the same component\n        if fill_color is None:\n            for seed_color, seed_pos in seeds.items():\n                seed_comp = int(labeled[seed_pos[0], seed_pos[1]])\n                if seed_comp in border_comps:\n                    fill_color = seed_color\n                    break\n\n        if fill_color is not None:\n            for r, c in region:\n                output[r, c] = fill_color\n\n    return output.tolist()\n"}, {"success": true, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 2, 2, 0, 2, 4, 4, 2, 0, 0, 0, 0, 0, 2, 4, 4, 2, 0], [0, 0, 2, 4, 4, 2, 2, 4, 4, 2, 0, 0, 2, 2, 0, 2, 4, 4, 2, 0], [0, 0, 2, 4, 4, 2, 1, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 2, 1, 0], [0, 0, 0, 2, 2, 1, 1, 1, 0, 0, 0, 2, 0, 0, 2, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 2, 2, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2], [4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2]]", "soft_score": 1.0, "error": null, "code": "def transform(grid):\n    \"\"\"Transform input grid by filling enclosed box interiors with seed color(s).\n\n    Rule:\n    1. Find background color (most common color in grid)\n    2. Find seed color(s) (colors appearing exactly once, non-background)\n    3. Find connected components of non-background cells (8-connectivity)\n    4. Find enclosed background regions (holes in non-background mask)\n    5. Also detect edge-bounded enclosed regions (boxes touching grid edge)\n    6. For each enclosed region:\n       - Determine box color (most common border color)\n       - Check if border is in same component as a seed\n       - Check if border touches non-box-color connectors\n       - If both conditions met: fill with matching seed color\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label as ndlabel, binary_fill_holes\n    from collections import Counter\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Find background color (most common)\n    color_counts = Counter(int(v) for v in grid.flat)\n    bg_color = color_counts.most_common(1)[0][0]\n\n    # Find seed colors (appear exactly once, non-background)\n    seeds = {}\n    for c, cnt in color_counts.items():\n        if cnt == 1 and c != bg_color:\n            pos = tuple(np.argwhere(grid == c)[0])\n            seeds[c] = pos\n\n    if not seeds:\n        return grid.tolist()\n\n    # Determine connector type for each seed (adjacent non-bg, non-seed colors)\n    seed_connector_types = {}\n    for seed_color, seed_pos in seeds.items():\n        r, c_pos = seed_pos\n        adj = set()\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c_pos + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    v = int(grid[nr, nc])\n                    if v != bg_color and v != seed_color:\n                        adj.add(v)\n        seed_connector_types[seed_color] = adj\n\n    struct8 = np.ones((3, 3), dtype=int)\n    nonbg = grid != bg_color\n    labeled, n_comp = ndlabel(nonbg, structure=struct8)\n\n    # Find standard enclosed regions\n    enclosed = binary_fill_holes(nonbg) & ~nonbg\n\n    # Find edge-bounded enclosed regions\n    struct4 = np.array([[0,1,0],[1,1,1],[0,1,0]])\n    bg_labeled, bg_n = ndlabel(grid == bg_color, structure=struct4)\n\n    for comp in range(1, bg_n + 1):\n        comp_cells = np.argwhere(bg_labeled == comp)\n\n        # Skip if already detected or too large\n        if any(enclosed[r, c] for r, c in comp_cells):\n            continue\n        if len(comp_cells) > 20:\n            continue\n\n        comp_set = set(map(tuple, comp_cells.tolist()))\n\n        # Must touch grid edge\n        touches_edge = any(\n            r == 0 or r == rows-1 or c == 0 or c == cols-1\n            for r, c in comp_set\n        )\n        if not touches_edge:\n            continue\n\n        # Check edge sealing: on each touched edge, the component's footprint\n        # must be bounded by non-bg cells on both sides\n        sealed = True\n        for edge_name, edge_vals, edge_idx in [\n            ('top', [c for r, c in comp_set if r == 0], 0),\n            ('bottom', [c for r, c in comp_set if r == rows-1], rows-1),\n            ('left', [r for r, c in comp_set if c == 0], 0),\n            ('right', [r for r, c in comp_set if c == cols-1], cols-1),\n        ]:\n            if not edge_vals:\n                continue\n            min_val = min(edge_vals)\n            max_val = max(edge_vals)\n            has_lower = has_upper = False\n\n            if edge_name in ('top', 'bottom'):\n                r_edge = edge_idx\n                for cc in range(min_val - 1, -1, -1):\n                    if grid[r_edge, cc] != bg_color:\n                        has_lower = True\n                        break\n                for cc in range(max_val + 1, cols):\n                    if grid[r_edge, cc] != bg_color:\n                        has_upper = True\n                        break\n            else:\n                c_edge = edge_idx\n                for rr in range(min_val - 1, -1, -1):\n                    if grid[rr, c_edge] != bg_color:\n                        has_lower = True\n                        break\n                for rr in range(max_val + 1, rows):\n                    if grid[rr, c_edge] != bg_color:\n                        has_upper = True\n                        break\n\n            if not (has_lower and has_upper):\n                sealed = False\n                break\n\n        if not sealed:\n            continue\n\n        # Box-like check: most common border color must be >= 75% of border\n        border_cells = set()\n        for r, c in comp_cells:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if grid[nr, nc] != bg_color:\n                            border_cells.add((nr, nc))\n\n        if border_cells:\n            bc_counts = Counter(int(grid[r, c]) for r, c in border_cells)\n            most_common_count = bc_counts.most_common(1)[0][1]\n            total_border = sum(bc_counts.values())\n            if most_common_count / total_border >= 0.75:\n                for r, c in comp_cells:\n                    enclosed[r, c] = True\n\n    # Label enclosed regions\n    enc_labeled, n_enc = ndlabel(enclosed)\n    output = grid.copy()\n\n    for j in range(1, n_enc + 1):\n        region = np.argwhere(enc_labeled == j)\n\n        # Find border cells (non-bg cells 8-adjacent to region)\n        border_cells = set()\n        for r, c in region:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if grid[nr, nc] != bg_color:\n                            border_cells.add((nr, nc))\n\n        if not border_cells:\n            continue\n\n        # Determine box color (most common border color)\n        bc_counts = Counter(int(grid[r, c]) for r, c in border_cells)\n        box_color = bc_counts.most_common(1)[0][0]\n\n        # Find which components the border belongs to\n        border_comps = set(int(labeled[r, c]) for r, c in border_cells)\n\n        # Find connector colors (non-bg, non-box-color in border neighborhood)\n        connector_colors = set()\n        for r, c in border_cells:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        v = int(grid[nr, nc])\n                        if v != bg_color and v != box_color:\n                            connector_colors.add(v)\n\n        if not connector_colors:\n            continue  # No connectors touching border -> don't fill\n\n        # Determine fill color by matching connector type to seed\n        fill_color = None\n\n        # First try: match seed's connector type with region's connectors\n        for seed_color, seed_pos in seeds.items():\n            seed_comp = int(labeled[seed_pos[0], seed_pos[1]])\n            if seed_comp not in border_comps:\n                continue\n            seed_conn = seed_connector_types.get(seed_color, set())\n            if connector_colors & seed_conn:\n                fill_color = seed_color\n                break\n\n        # Fallback: any seed in the same component\n        if fill_color is None:\n            for seed_color, seed_pos in seeds.items():\n                seed_comp = int(labeled[seed_pos[0], seed_pos[1]])\n                if seed_comp in border_comps:\n                    fill_color = seed_color\n                    break\n\n        if fill_color is not None:\n            for r, c in region:\n                output[r, c] = fill_color\n\n    return output.tolist()\n"}, {"success": true, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 4, 4], [0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 2, 4, 4], [0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 3, 2, 2], [0, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 0, 0, 0, 3, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 3, 0], [1, 1, 0, 0, 0, 0, 0, 2, 2, 1, 1, 1, 0, 0, 0, 0, 2, 2, 3, 0], [0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 4, 4, 2, 0], [1, 1, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 4, 4, 2, 0], [0, 0, 0, 0, 0, 0, 1, 2, 2, 0, 0, 0, 0, 0, 0, 3, 2, 2, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 3, 2, 2, 3, 0, 0, 0, 0], [0, 0, 2, 2, 1, 0, 0, 0, 0, 0, 3, 0, 2, 4, 4, 2, 0, 0, 0, 0], [0, 2, 0, 0, 2, 0, 0, 0, 3, 3, 3, 0, 2, 4, 4, 2, 0, 0, 0, 0], [0, 2, 0, 0, 2, 0, 0, 0, 3, 4, 3, 0, 0, 2, 2, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "def transform(grid):\n    \"\"\"Transform input grid by filling enclosed box interiors with seed color(s).\n\n    Rule:\n    1. Find background color (most common color in grid)\n    2. Find seed color(s) (colors appearing exactly once, non-background)\n    3. Find connected components of non-background cells (8-connectivity)\n    4. Find enclosed background regions (holes in non-background mask)\n    5. Also detect edge-bounded enclosed regions (boxes touching grid edge)\n    6. For each enclosed region:\n       - Determine box color (most common border color)\n       - Check if border is in same component as a seed\n       - Check if border touches non-box-color connectors\n       - If both conditions met: fill with matching seed color\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label as ndlabel, binary_fill_holes\n    from collections import Counter\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Find background color (most common)\n    color_counts = Counter(int(v) for v in grid.flat)\n    bg_color = color_counts.most_common(1)[0][0]\n\n    # Find seed colors (appear exactly once, non-background)\n    seeds = {}\n    for c, cnt in color_counts.items():\n        if cnt == 1 and c != bg_color:\n            pos = tuple(np.argwhere(grid == c)[0])\n            seeds[c] = pos\n\n    if not seeds:\n        return grid.tolist()\n\n    # Determine connector type for each seed (adjacent non-bg, non-seed colors)\n    seed_connector_types = {}\n    for seed_color, seed_pos in seeds.items():\n        r, c_pos = seed_pos\n        adj = set()\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c_pos + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    v = int(grid[nr, nc])\n                    if v != bg_color and v != seed_color:\n                        adj.add(v)\n        seed_connector_types[seed_color] = adj\n\n    struct8 = np.ones((3, 3), dtype=int)\n    nonbg = grid != bg_color\n    labeled, n_comp = ndlabel(nonbg, structure=struct8)\n\n    # Find standard enclosed regions\n    enclosed = binary_fill_holes(nonbg) & ~nonbg\n\n    # Find edge-bounded enclosed regions\n    struct4 = np.array([[0,1,0],[1,1,1],[0,1,0]])\n    bg_labeled, bg_n = ndlabel(grid == bg_color, structure=struct4)\n\n    for comp in range(1, bg_n + 1):\n        comp_cells = np.argwhere(bg_labeled == comp)\n\n        # Skip if already detected or too large\n        if any(enclosed[r, c] for r, c in comp_cells):\n            continue\n        if len(comp_cells) > 20:\n            continue\n\n        comp_set = set(map(tuple, comp_cells.tolist()))\n\n        # Must touch grid edge\n        touches_edge = any(\n            r == 0 or r == rows-1 or c == 0 or c == cols-1\n            for r, c in comp_set\n        )\n        if not touches_edge:\n            continue\n\n        # Check edge sealing: on each touched edge, the component's footprint\n        # must be bounded by non-bg cells on both sides\n        sealed = True\n        for edge_name, edge_vals, edge_idx in [\n            ('top', [c for r, c in comp_set if r == 0], 0),\n            ('bottom', [c for r, c in comp_set if r == rows-1], rows-1),\n            ('left', [r for r, c in comp_set if c == 0], 0),\n            ('right', [r for r, c in comp_set if c == cols-1], cols-1),\n        ]:\n            if not edge_vals:\n                continue\n            min_val = min(edge_vals)\n            max_val = max(edge_vals)\n            has_lower = has_upper = False\n\n            if edge_name in ('top', 'bottom'):\n                r_edge = edge_idx\n                for cc in range(min_val - 1, -1, -1):\n                    if grid[r_edge, cc] != bg_color:\n                        has_lower = True\n                        break\n                for cc in range(max_val + 1, cols):\n                    if grid[r_edge, cc] != bg_color:\n                        has_upper = True\n                        break\n            else:\n                c_edge = edge_idx\n                for rr in range(min_val - 1, -1, -1):\n                    if grid[rr, c_edge] != bg_color:\n                        has_lower = True\n                        break\n                for rr in range(max_val + 1, rows):\n                    if grid[rr, c_edge] != bg_color:\n                        has_upper = True\n                        break\n\n            if not (has_lower and has_upper):\n                sealed = False\n                break\n\n        if not sealed:\n            continue\n\n        # Box-like check: most common border color must be >= 75% of border\n        border_cells = set()\n        for r, c in comp_cells:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if grid[nr, nc] != bg_color:\n                            border_cells.add((nr, nc))\n\n        if border_cells:\n            bc_counts = Counter(int(grid[r, c]) for r, c in border_cells)\n            most_common_count = bc_counts.most_common(1)[0][1]\n            total_border = sum(bc_counts.values())\n            if most_common_count / total_border >= 0.75:\n                for r, c in comp_cells:\n                    enclosed[r, c] = True\n\n    # Label enclosed regions\n    enc_labeled, n_enc = ndlabel(enclosed)\n    output = grid.copy()\n\n    for j in range(1, n_enc + 1):\n        region = np.argwhere(enc_labeled == j)\n\n        # Find border cells (non-bg cells 8-adjacent to region)\n        border_cells = set()\n        for r, c in region:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if grid[nr, nc] != bg_color:\n                            border_cells.add((nr, nc))\n\n        if not border_cells:\n            continue\n\n        # Determine box color (most common border color)\n        bc_counts = Counter(int(grid[r, c]) for r, c in border_cells)\n        box_color = bc_counts.most_common(1)[0][0]\n\n        # Find which components the border belongs to\n        border_comps = set(int(labeled[r, c]) for r, c in border_cells)\n\n        # Find connector colors (non-bg, non-box-color in border neighborhood)\n        connector_colors = set()\n        for r, c in border_cells:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        v = int(grid[nr, nc])\n                        if v != bg_color and v != box_color:\n                            connector_colors.add(v)\n\n        if not connector_colors:\n            continue  # No connectors touching border -> don't fill\n\n        # Determine fill color by matching connector type to seed\n        fill_color = None\n\n        # First try: match seed's connector type with region's connectors\n        for seed_color, seed_pos in seeds.items():\n            seed_comp = int(labeled[seed_pos[0], seed_pos[1]])\n            if seed_comp not in border_comps:\n                continue\n            seed_conn = seed_connector_types.get(seed_color, set())\n            if connector_colors & seed_conn:\n                fill_color = seed_color\n                break\n\n        # Fallback: any seed in the same component\n        if fill_color is None:\n            for seed_color, seed_pos in seeds.items():\n                seed_comp = int(labeled[seed_pos[0], seed_pos[1]])\n                if seed_comp in border_comps:\n                    fill_color = seed_color\n                    break\n\n        if fill_color is not None:\n            for r, c in region:\n                output[r, c] = fill_color\n\n    return output.tolist()\n"}, {"success": true, "output": "[[0, 0, 2, 2, 0, 0, 0, 0], [0, 2, 4, 4, 2, 0, 0, 0], [0, 2, 4, 4, 2, 0, 0, 0], [0, 0, 2, 2, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 1, 4]]", "soft_score": 1.0, "error": null, "code": "def transform(grid):\n    \"\"\"Transform input grid by filling enclosed box interiors with seed color(s).\n\n    Rule:\n    1. Find background color (most common color in grid)\n    2. Find seed color(s) (colors appearing exactly once, non-background)\n    3. Find connected components of non-background cells (8-connectivity)\n    4. Find enclosed background regions (holes in non-background mask)\n    5. Also detect edge-bounded enclosed regions (boxes touching grid edge)\n    6. For each enclosed region:\n       - Determine box color (most common border color)\n       - Check if border is in same component as a seed\n       - Check if border touches non-box-color connectors\n       - If both conditions met: fill with matching seed color\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label as ndlabel, binary_fill_holes\n    from collections import Counter\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Find background color (most common)\n    color_counts = Counter(int(v) for v in grid.flat)\n    bg_color = color_counts.most_common(1)[0][0]\n\n    # Find seed colors (appear exactly once, non-background)\n    seeds = {}\n    for c, cnt in color_counts.items():\n        if cnt == 1 and c != bg_color:\n            pos = tuple(np.argwhere(grid == c)[0])\n            seeds[c] = pos\n\n    if not seeds:\n        return grid.tolist()\n\n    # Determine connector type for each seed (adjacent non-bg, non-seed colors)\n    seed_connector_types = {}\n    for seed_color, seed_pos in seeds.items():\n        r, c_pos = seed_pos\n        adj = set()\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c_pos + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    v = int(grid[nr, nc])\n                    if v != bg_color and v != seed_color:\n                        adj.add(v)\n        seed_connector_types[seed_color] = adj\n\n    struct8 = np.ones((3, 3), dtype=int)\n    nonbg = grid != bg_color\n    labeled, n_comp = ndlabel(nonbg, structure=struct8)\n\n    # Find standard enclosed regions\n    enclosed = binary_fill_holes(nonbg) & ~nonbg\n\n    # Find edge-bounded enclosed regions\n    struct4 = np.array([[0,1,0],[1,1,1],[0,1,0]])\n    bg_labeled, bg_n = ndlabel(grid == bg_color, structure=struct4)\n\n    for comp in range(1, bg_n + 1):\n        comp_cells = np.argwhere(bg_labeled == comp)\n\n        # Skip if already detected or too large\n        if any(enclosed[r, c] for r, c in comp_cells):\n            continue\n        if len(comp_cells) > 20:\n            continue\n\n        comp_set = set(map(tuple, comp_cells.tolist()))\n\n        # Must touch grid edge\n        touches_edge = any(\n            r == 0 or r == rows-1 or c == 0 or c == cols-1\n            for r, c in comp_set\n        )\n        if not touches_edge:\n            continue\n\n        # Check edge sealing: on each touched edge, the component's footprint\n        # must be bounded by non-bg cells on both sides\n        sealed = True\n        for edge_name, edge_vals, edge_idx in [\n            ('top', [c for r, c in comp_set if r == 0], 0),\n            ('bottom', [c for r, c in comp_set if r == rows-1], rows-1),\n            ('left', [r for r, c in comp_set if c == 0], 0),\n            ('right', [r for r, c in comp_set if c == cols-1], cols-1),\n        ]:\n            if not edge_vals:\n                continue\n            min_val = min(edge_vals)\n            max_val = max(edge_vals)\n            has_lower = has_upper = False\n\n            if edge_name in ('top', 'bottom'):\n                r_edge = edge_idx\n                for cc in range(min_val - 1, -1, -1):\n                    if grid[r_edge, cc] != bg_color:\n                        has_lower = True\n                        break\n                for cc in range(max_val + 1, cols):\n                    if grid[r_edge, cc] != bg_color:\n                        has_upper = True\n                        break\n            else:\n                c_edge = edge_idx\n                for rr in range(min_val - 1, -1, -1):\n                    if grid[rr, c_edge] != bg_color:\n                        has_lower = True\n                        break\n                for rr in range(max_val + 1, rows):\n                    if grid[rr, c_edge] != bg_color:\n                        has_upper = True\n                        break\n\n            if not (has_lower and has_upper):\n                sealed = False\n                break\n\n        if not sealed:\n            continue\n\n        # Box-like check: most common border color must be >= 75% of border\n        border_cells = set()\n        for r, c in comp_cells:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if grid[nr, nc] != bg_color:\n                            border_cells.add((nr, nc))\n\n        if border_cells:\n            bc_counts = Counter(int(grid[r, c]) for r, c in border_cells)\n            most_common_count = bc_counts.most_common(1)[0][1]\n            total_border = sum(bc_counts.values())\n            if most_common_count / total_border >= 0.75:\n                for r, c in comp_cells:\n                    enclosed[r, c] = True\n\n    # Label enclosed regions\n    enc_labeled, n_enc = ndlabel(enclosed)\n    output = grid.copy()\n\n    for j in range(1, n_enc + 1):\n        region = np.argwhere(enc_labeled == j)\n\n        # Find border cells (non-bg cells 8-adjacent to region)\n        border_cells = set()\n        for r, c in region:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if grid[nr, nc] != bg_color:\n                            border_cells.add((nr, nc))\n\n        if not border_cells:\n            continue\n\n        # Determine box color (most common border color)\n        bc_counts = Counter(int(grid[r, c]) for r, c in border_cells)\n        box_color = bc_counts.most_common(1)[0][0]\n\n        # Find which components the border belongs to\n        border_comps = set(int(labeled[r, c]) for r, c in border_cells)\n\n        # Find connector colors (non-bg, non-box-color in border neighborhood)\n        connector_colors = set()\n        for r, c in border_cells:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        v = int(grid[nr, nc])\n                        if v != bg_color and v != box_color:\n                            connector_colors.add(v)\n\n        if not connector_colors:\n            continue  # No connectors touching border -> don't fill\n\n        # Determine fill color by matching connector type to seed\n        fill_color = None\n\n        # First try: match seed's connector type with region's connectors\n        for seed_color, seed_pos in seeds.items():\n            seed_comp = int(labeled[seed_pos[0], seed_pos[1]])\n            if seed_comp not in border_comps:\n                continue\n            seed_conn = seed_connector_types.get(seed_color, set())\n            if connector_colors & seed_conn:\n                fill_color = seed_color\n                break\n\n        # Fallback: any seed in the same component\n        if fill_color is None:\n            for seed_color, seed_pos in seeds.items():\n                seed_comp = int(labeled[seed_pos[0], seed_pos[1]])\n                if seed_comp in border_comps:\n                    fill_color = seed_color\n                    break\n\n        if fill_color is not None:\n            for r, c in region:\n                output[r, c] = fill_color\n\n    return output.tolist()\n"}], "test_results": [{"success": false, "output": "[[6, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 8], [1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 3], [5, 5, 5, 1, 9, 9, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 5, 5, 5, 5, 5, 5, 3, 3, 5, 5], [5, 5, 5, 9, 6, 6, 9, 5, 5, 5, 5, 5, 9, 6, 6, 6, 6, 6, 6, 6, 9, 5, 5, 5, 5, 5, 3, 5, 5, 5], [5, 5, 5, 9, 6, 6, 9, 5, 5, 5, 5, 5, 9, 6, 6, 6, 6, 6, 6, 6, 9, 5, 5, 5, 5, 3, 3, 5, 5, 5], [5, 5, 5, 5, 9, 9, 5, 5, 5, 5, 5, 5, 5, 9, 9, 9, 9, 9, 9, 9, 1, 1, 1, 1, 5, 3, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 3, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 1, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 5, 5, 1, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 9, 3, 5, 5, 1, 5, 5], [5, 5, 5, 5, 9, 9, 9, 9, 9, 9, 9, 5, 5, 5, 5, 5, 9, 3, 3, 5, 5, 9, 8, 8, 9, 5, 5, 1, 5, 5], [5, 5, 5, 9, 5, 5, 5, 5, 5, 5, 5, 9, 5, 5, 5, 9, 9, 9, 3, 3, 3, 9, 8, 8, 9, 5, 5, 1, 5, 5], [5, 5, 5, 9, 5, 5, 5, 5, 5, 5, 5, 9, 5, 5, 5, 9, 8, 9, 5, 5, 3, 3, 9, 9, 5, 5, 5, 1, 1, 5], [5, 5, 3, 3, 9, 9, 9, 9, 9, 9, 9, 5, 5, 5, 5, 9, 8, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 5], [5, 0, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 8, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 8, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 8, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 8, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 5, 5], [5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 8, 9, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 5, 5], [5, 5, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 8, 9, 5, 5, 5, 5, 5, 5, 5, 5, 1, 5, 5, 5], [5, 5, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 3, 3, 9, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 5, 5, 5], [5, 5, 3, 3, 5, 5, 5, 5, 5, 5, 3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 9, 9, 9, 1, 1, 1, 5, 5, 5, 5], [5, 5, 5, 3, 9, 9, 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 9, 6, 6, 9, 1, 1, 5, 5, 5, 5, 5], [5, 5, 5, 9, 8, 8, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 6, 6, 6, 9, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 9, 8, 8, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 6, 6, 6, 9, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 9, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 6, 6, 6, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 6, 6, 6, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9, 9, 9, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]]", "soft_score": 0.0, "error": null, "code": "def transform(grid):\n    \"\"\"Transform input grid by filling enclosed box interiors with seed color(s).\n\n    Rule:\n    1. Find background color (most common color in grid)\n    2. Find seed color(s) (colors appearing exactly once, non-background)\n    3. Find connected components of non-background cells (8-connectivity)\n    4. Find enclosed background regions (holes in non-background mask)\n    5. Also detect edge-bounded enclosed regions (boxes touching grid edge)\n    6. For each enclosed region:\n       - Determine box color (most common border color)\n       - Check if border is in same component as a seed\n       - Check if border touches non-box-color connectors\n       - If both conditions met: fill with matching seed color\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label as ndlabel, binary_fill_holes\n    from collections import Counter\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Find background color (most common)\n    color_counts = Counter(int(v) for v in grid.flat)\n    bg_color = color_counts.most_common(1)[0][0]\n\n    # Find seed colors (appear exactly once, non-background)\n    seeds = {}\n    for c, cnt in color_counts.items():\n        if cnt == 1 and c != bg_color:\n            pos = tuple(np.argwhere(grid == c)[0])\n            seeds[c] = pos\n\n    if not seeds:\n        return grid.tolist()\n\n    # Determine connector type for each seed (adjacent non-bg, non-seed colors)\n    seed_connector_types = {}\n    for seed_color, seed_pos in seeds.items():\n        r, c_pos = seed_pos\n        adj = set()\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c_pos + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    v = int(grid[nr, nc])\n                    if v != bg_color and v != seed_color:\n                        adj.add(v)\n        seed_connector_types[seed_color] = adj\n\n    struct8 = np.ones((3, 3), dtype=int)\n    nonbg = grid != bg_color\n    labeled, n_comp = ndlabel(nonbg, structure=struct8)\n\n    # Find standard enclosed regions\n    enclosed = binary_fill_holes(nonbg) & ~nonbg\n\n    # Find edge-bounded enclosed regions\n    struct4 = np.array([[0,1,0],[1,1,1],[0,1,0]])\n    bg_labeled, bg_n = ndlabel(grid == bg_color, structure=struct4)\n\n    for comp in range(1, bg_n + 1):\n        comp_cells = np.argwhere(bg_labeled == comp)\n\n        # Skip if already detected or too large\n        if any(enclosed[r, c] for r, c in comp_cells):\n            continue\n        if len(comp_cells) > 20:\n            continue\n\n        comp_set = set(map(tuple, comp_cells.tolist()))\n\n        # Must touch grid edge\n        touches_edge = any(\n            r == 0 or r == rows-1 or c == 0 or c == cols-1\n            for r, c in comp_set\n        )\n        if not touches_edge:\n            continue\n\n        # Check edge sealing: on each touched edge, the component's footprint\n        # must be bounded by non-bg cells on both sides\n        sealed = True\n        for edge_name, edge_vals, edge_idx in [\n            ('top', [c for r, c in comp_set if r == 0], 0),\n            ('bottom', [c for r, c in comp_set if r == rows-1], rows-1),\n            ('left', [r for r, c in comp_set if c == 0], 0),\n            ('right', [r for r, c in comp_set if c == cols-1], cols-1),\n        ]:\n            if not edge_vals:\n                continue\n            min_val = min(edge_vals)\n            max_val = max(edge_vals)\n            has_lower = has_upper = False\n\n            if edge_name in ('top', 'bottom'):\n                r_edge = edge_idx\n                for cc in range(min_val - 1, -1, -1):\n                    if grid[r_edge, cc] != bg_color:\n                        has_lower = True\n                        break\n                for cc in range(max_val + 1, cols):\n                    if grid[r_edge, cc] != bg_color:\n                        has_upper = True\n                        break\n            else:\n                c_edge = edge_idx\n                for rr in range(min_val - 1, -1, -1):\n                    if grid[rr, c_edge] != bg_color:\n                        has_lower = True\n                        break\n                for rr in range(max_val + 1, rows):\n                    if grid[rr, c_edge] != bg_color:\n                        has_upper = True\n                        break\n\n            if not (has_lower and has_upper):\n                sealed = False\n                break\n\n        if not sealed:\n            continue\n\n        # Box-like check: most common border color must be >= 75% of border\n        border_cells = set()\n        for r, c in comp_cells:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if grid[nr, nc] != bg_color:\n                            border_cells.add((nr, nc))\n\n        if border_cells:\n            bc_counts = Counter(int(grid[r, c]) for r, c in border_cells)\n            most_common_count = bc_counts.most_common(1)[0][1]\n            total_border = sum(bc_counts.values())\n            if most_common_count / total_border >= 0.75:\n                for r, c in comp_cells:\n                    enclosed[r, c] = True\n\n    # Label enclosed regions\n    enc_labeled, n_enc = ndlabel(enclosed)\n    output = grid.copy()\n\n    for j in range(1, n_enc + 1):\n        region = np.argwhere(enc_labeled == j)\n\n        # Find border cells (non-bg cells 8-adjacent to region)\n        border_cells = set()\n        for r, c in region:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if grid[nr, nc] != bg_color:\n                            border_cells.add((nr, nc))\n\n        if not border_cells:\n            continue\n\n        # Determine box color (most common border color)\n        bc_counts = Counter(int(grid[r, c]) for r, c in border_cells)\n        box_color = bc_counts.most_common(1)[0][0]\n\n        # Find which components the border belongs to\n        border_comps = set(int(labeled[r, c]) for r, c in border_cells)\n\n        # Find connector colors (non-bg, non-box-color in border neighborhood)\n        connector_colors = set()\n        for r, c in border_cells:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        v = int(grid[nr, nc])\n                        if v != bg_color and v != box_color:\n                            connector_colors.add(v)\n\n        if not connector_colors:\n            continue  # No connectors touching border -> don't fill\n\n        # Determine fill color by matching connector type to seed\n        fill_color = None\n\n        # First try: match seed's connector type with region's connectors\n        for seed_color, seed_pos in seeds.items():\n            seed_comp = int(labeled[seed_pos[0], seed_pos[1]])\n            if seed_comp not in border_comps:\n                continue\n            seed_conn = seed_connector_types.get(seed_color, set())\n            if connector_colors & seed_conn:\n                fill_color = seed_color\n                break\n\n        # Fallback: any seed in the same component\n        if fill_color is None:\n            for seed_color, seed_pos in seeds.items():\n                seed_comp = int(labeled[seed_pos[0], seed_pos[1]])\n                if seed_comp in border_comps:\n                    fill_color = seed_color\n                    break\n\n        if fill_color is not None:\n            for r, c in region:\n                output[r, c] = fill_color\n\n    return output.tolist()\n"}, {"success": false, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 8, 0, 0, 8], [0, 0, 0, 0, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 8, 8, 0, 0, 8, 0, 0, 8], [0, 0, 0, 2, 4, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 4, 4, 8, 0, 0, 8, 8, 0], [0, 0, 0, 2, 4, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 4, 4, 8, 0, 0, 0, 0, 0], [0, 0, 0, 1, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 8, 3, 3, 8, 0, 0, 0, 5, 5, 5, 1, 0], [0, 0, 1, 0, 0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 8, 3, 3, 8, 0, 0, 5, 4, 4, 4, 5, 0], [0, 0, 1, 0, 0, 0, 0, 0, 6, 6, 6, 0, 0, 9, 9, 8, 8, 9, 0, 0, 5, 4, 4, 4, 5, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 9, 9, 0, 0, 5, 5, 5, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 8, 8, 9, 9, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 8, 3, 3, 8, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 8, 3, 3, 8, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 8, 8, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 9, 0, 0, 8, 3, 3, 8, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 3, 3, 8, 0, 0, 8, 3, 3, 8, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 3, 3, 8, 0, 0, 9, 8, 8, 0, 0], [0, 1, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 9, 8, 8, 9, 9, 9, 0, 0, 0, 0, 0], [1, 1, 0, 0, 9, 9, 9, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 1, 0, 0, 9, 3, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 0.0, "error": null, "code": "def transform(grid):\n    \"\"\"Transform input grid by filling enclosed box interiors with seed color(s).\n\n    Rule:\n    1. Find background color (most common color in grid)\n    2. Find seed color(s) (colors appearing exactly once, non-background)\n    3. Find connected components of non-background cells (8-connectivity)\n    4. Find enclosed background regions (holes in non-background mask)\n    5. Also detect edge-bounded enclosed regions (boxes touching grid edge)\n    6. For each enclosed region:\n       - Determine box color (most common border color)\n       - Check if border is in same component as a seed\n       - Check if border touches non-box-color connectors\n       - If both conditions met: fill with matching seed color\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label as ndlabel, binary_fill_holes\n    from collections import Counter\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Find background color (most common)\n    color_counts = Counter(int(v) for v in grid.flat)\n    bg_color = color_counts.most_common(1)[0][0]\n\n    # Find seed colors (appear exactly once, non-background)\n    seeds = {}\n    for c, cnt in color_counts.items():\n        if cnt == 1 and c != bg_color:\n            pos = tuple(np.argwhere(grid == c)[0])\n            seeds[c] = pos\n\n    if not seeds:\n        return grid.tolist()\n\n    # Determine connector type for each seed (adjacent non-bg, non-seed colors)\n    seed_connector_types = {}\n    for seed_color, seed_pos in seeds.items():\n        r, c_pos = seed_pos\n        adj = set()\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c_pos + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    v = int(grid[nr, nc])\n                    if v != bg_color and v != seed_color:\n                        adj.add(v)\n        seed_connector_types[seed_color] = adj\n\n    struct8 = np.ones((3, 3), dtype=int)\n    nonbg = grid != bg_color\n    labeled, n_comp = ndlabel(nonbg, structure=struct8)\n\n    # Find standard enclosed regions\n    enclosed = binary_fill_holes(nonbg) & ~nonbg\n\n    # Find edge-bounded enclosed regions\n    struct4 = np.array([[0,1,0],[1,1,1],[0,1,0]])\n    bg_labeled, bg_n = ndlabel(grid == bg_color, structure=struct4)\n\n    for comp in range(1, bg_n + 1):\n        comp_cells = np.argwhere(bg_labeled == comp)\n\n        # Skip if already detected or too large\n        if any(enclosed[r, c] for r, c in comp_cells):\n            continue\n        if len(comp_cells) > 20:\n            continue\n\n        comp_set = set(map(tuple, comp_cells.tolist()))\n\n        # Must touch grid edge\n        touches_edge = any(\n            r == 0 or r == rows-1 or c == 0 or c == cols-1\n            for r, c in comp_set\n        )\n        if not touches_edge:\n            continue\n\n        # Check edge sealing: on each touched edge, the component's footprint\n        # must be bounded by non-bg cells on both sides\n        sealed = True\n        for edge_name, edge_vals, edge_idx in [\n            ('top', [c for r, c in comp_set if r == 0], 0),\n            ('bottom', [c for r, c in comp_set if r == rows-1], rows-1),\n            ('left', [r for r, c in comp_set if c == 0], 0),\n            ('right', [r for r, c in comp_set if c == cols-1], cols-1),\n        ]:\n            if not edge_vals:\n                continue\n            min_val = min(edge_vals)\n            max_val = max(edge_vals)\n            has_lower = has_upper = False\n\n            if edge_name in ('top', 'bottom'):\n                r_edge = edge_idx\n                for cc in range(min_val - 1, -1, -1):\n                    if grid[r_edge, cc] != bg_color:\n                        has_lower = True\n                        break\n                for cc in range(max_val + 1, cols):\n                    if grid[r_edge, cc] != bg_color:\n                        has_upper = True\n                        break\n            else:\n                c_edge = edge_idx\n                for rr in range(min_val - 1, -1, -1):\n                    if grid[rr, c_edge] != bg_color:\n                        has_lower = True\n                        break\n                for rr in range(max_val + 1, rows):\n                    if grid[rr, c_edge] != bg_color:\n                        has_upper = True\n                        break\n\n            if not (has_lower and has_upper):\n                sealed = False\n                break\n\n        if not sealed:\n            continue\n\n        # Box-like check: most common border color must be >= 75% of border\n        border_cells = set()\n        for r, c in comp_cells:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if grid[nr, nc] != bg_color:\n                            border_cells.add((nr, nc))\n\n        if border_cells:\n            bc_counts = Counter(int(grid[r, c]) for r, c in border_cells)\n            most_common_count = bc_counts.most_common(1)[0][1]\n            total_border = sum(bc_counts.values())\n            if most_common_count / total_border >= 0.75:\n                for r, c in comp_cells:\n                    enclosed[r, c] = True\n\n    # Label enclosed regions\n    enc_labeled, n_enc = ndlabel(enclosed)\n    output = grid.copy()\n\n    for j in range(1, n_enc + 1):\n        region = np.argwhere(enc_labeled == j)\n\n        # Find border cells (non-bg cells 8-adjacent to region)\n        border_cells = set()\n        for r, c in region:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if grid[nr, nc] != bg_color:\n                            border_cells.add((nr, nc))\n\n        if not border_cells:\n            continue\n\n        # Determine box color (most common border color)\n        bc_counts = Counter(int(grid[r, c]) for r, c in border_cells)\n        box_color = bc_counts.most_common(1)[0][0]\n\n        # Find which components the border belongs to\n        border_comps = set(int(labeled[r, c]) for r, c in border_cells)\n\n        # Find connector colors (non-bg, non-box-color in border neighborhood)\n        connector_colors = set()\n        for r, c in border_cells:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        v = int(grid[nr, nc])\n                        if v != bg_color and v != box_color:\n                            connector_colors.add(v)\n\n        if not connector_colors:\n            continue  # No connectors touching border -> don't fill\n\n        # Determine fill color by matching connector type to seed\n        fill_color = None\n\n        # First try: match seed's connector type with region's connectors\n        for seed_color, seed_pos in seeds.items():\n            seed_comp = int(labeled[seed_pos[0], seed_pos[1]])\n            if seed_comp not in border_comps:\n                continue\n            seed_conn = seed_connector_types.get(seed_color, set())\n            if connector_colors & seed_conn:\n                fill_color = seed_color\n                break\n\n        # Fallback: any seed in the same component\n        if fill_color is None:\n            for seed_color, seed_pos in seeds.items():\n                seed_comp = int(labeled[seed_pos[0], seed_pos[1]])\n                if seed_comp in border_comps:\n                    fill_color = seed_color\n                    break\n\n        if fill_color is not None:\n            for r, c in region:\n                output[r, c] = fill_color\n\n    return output.tolist()\n"}], "agent_usage": [{"input_tokens": 11602427, "input_tokens_details": {"cached_tokens": 11451545}, "output_tokens": 104267, "output_tokens_details": {"reasoning_tokens": -137}, "total_tokens": 104406, "inference_count": 137, "cache_creation": {"ephemeral_1h_input_tokens": 150743, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 150743, "inference_geo": ["global"], "service_tier": ["standard"]}], "time_taken": 1917.7761416435242, "num_agents_used": 1, "model": "anthropic/claude-opus-4-6", "reasoning_effort": "high", "error": null, "problem_id": "8b7bacbf", "attempt_id": 1, "num": 0, "iteration": 137}