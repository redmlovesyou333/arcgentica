{"train_results": [{"success": true, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 1, 2, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 2, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "def transform(grid):\n    \"\"\"Assemble puzzle pieces by matching their 2-connectors.\n\n    Each shape (connected component of non-zero, non-2 cells) has 2-valued connector cells\n    on its border. The color-4 shape stays fixed as the center piece. All other shapes are\n    translated (without rotation) so their connectors align with free connectors of already-placed\n    shapes, assembling the puzzle outward from the center using BFS with greedy matching\n    (preferring placements that match the most connectors simultaneously).\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Find body cells (non-zero, non-2)\n    body_mask = (grid != 0) & (grid != 2)\n    labeled, n = label(body_mask)\n\n    # Extract shapes with their body cells and 2-connectors\n    shapes = []\n    for comp in range(1, n + 1):\n        body_cells = set(map(tuple, np.argwhere(labeled == comp)))\n        color = int(grid[list(body_cells)[0][0], list(body_cells)[0][1]])\n\n        connectors = set()\n        for r, c in body_cells:\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 2:\n                    connectors.add((nr, nc))\n\n        shapes.append({\n            'color': color,\n            'body': body_cells,\n            'connectors': connectors,\n        })\n\n    # Find center shape (color 4)\n    center_idx = None\n    for i, s in enumerate(shapes):\n        if s['color'] == 4:\n            center_idx = i\n            break\n\n    if center_idx is None:\n        return grid.tolist()\n\n    # Assembly via greedy BFS\n    placed = {center_idx}\n    placed_body = set(shapes[center_idx]['body'])\n    placed_connectors = set(shapes[center_idx]['connectors'])\n    free_connectors = set(shapes[center_idx]['connectors'])\n    offsets = {center_idx: (0, 0)}\n\n    changed = True\n    while changed:\n        changed = False\n        best_shape_idx = None\n        best_offset = None\n        best_match_count = 0\n\n        for ui in range(len(shapes)):\n            if ui in placed:\n                continue\n\n            unplaced = shapes[ui]\n            for uc in unplaced['connectors']:\n                for fc in list(free_connectors):\n                    dr = int(fc[0] - uc[0])\n                    dc = int(fc[1] - uc[1])\n\n                    shifted_body = {(r + dr, c + dc) for r, c in unplaced['body']}\n                    shifted_connectors = {(r + dr, c + dc) for r, c in unplaced['connectors']}\n\n                    # Check no overlaps between new body and placed body/connectors\n                    if shifted_body & placed_body:\n                        continue\n                    if shifted_body & placed_connectors:\n                        continue\n                    if shifted_connectors & placed_body:\n                        continue\n\n                    # Check bounds\n                    all_shifted = shifted_body | shifted_connectors\n                    if any(r < 0 or r >= rows or c < 0 or c >= cols for r, c in all_shifted):\n                        continue\n\n                    # Count connector matches\n                    matched = shifted_connectors & free_connectors\n                    unmatched = shifted_connectors - free_connectors\n                    already_matched = placed_connectors - free_connectors\n                    if unmatched & already_matched:\n                        continue\n\n                    match_count = len(matched)\n                    if match_count > best_match_count:\n                        best_match_count = match_count\n                        best_shape_idx = ui\n                        best_offset = (dr, dc)\n\n        if best_shape_idx is not None and best_match_count > 0:\n            ui = best_shape_idx\n            dr, dc = best_offset\n            unplaced = shapes[ui]\n            shifted_body = {(r + dr, c + dc) for r, c in unplaced['body']}\n            shifted_connectors = {(r + dr, c + dc) for r, c in unplaced['connectors']}\n\n            matched = shifted_connectors & free_connectors\n            unmatched_new = shifted_connectors - free_connectors\n\n            placed.add(ui)\n            offsets[ui] = best_offset\n            placed_body |= shifted_body\n            placed_connectors |= shifted_connectors\n            free_connectors -= matched\n            free_connectors |= unmatched_new\n            changed = True\n\n    # Build output grid\n    output = np.zeros_like(grid)\n    for i, (dr, dc) in offsets.items():\n        shape = shapes[i]\n        for r, c in shape['body']:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output[nr, nc] = shape['color']\n        for r, c in shape['connectors']:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output[nr, nc] = 2\n\n    return output.tolist()\n"}, {"success": true, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 4, 4, 4, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 4, 4, 4, 2, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "def transform(grid):\n    \"\"\"Assemble puzzle pieces by matching their 2-connectors.\n\n    Each shape (connected component of non-zero, non-2 cells) has 2-valued connector cells\n    on its border. The color-4 shape stays fixed as the center piece. All other shapes are\n    translated (without rotation) so their connectors align with free connectors of already-placed\n    shapes, assembling the puzzle outward from the center using BFS with greedy matching\n    (preferring placements that match the most connectors simultaneously).\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Find body cells (non-zero, non-2)\n    body_mask = (grid != 0) & (grid != 2)\n    labeled, n = label(body_mask)\n\n    # Extract shapes with their body cells and 2-connectors\n    shapes = []\n    for comp in range(1, n + 1):\n        body_cells = set(map(tuple, np.argwhere(labeled == comp)))\n        color = int(grid[list(body_cells)[0][0], list(body_cells)[0][1]])\n\n        connectors = set()\n        for r, c in body_cells:\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 2:\n                    connectors.add((nr, nc))\n\n        shapes.append({\n            'color': color,\n            'body': body_cells,\n            'connectors': connectors,\n        })\n\n    # Find center shape (color 4)\n    center_idx = None\n    for i, s in enumerate(shapes):\n        if s['color'] == 4:\n            center_idx = i\n            break\n\n    if center_idx is None:\n        return grid.tolist()\n\n    # Assembly via greedy BFS\n    placed = {center_idx}\n    placed_body = set(shapes[center_idx]['body'])\n    placed_connectors = set(shapes[center_idx]['connectors'])\n    free_connectors = set(shapes[center_idx]['connectors'])\n    offsets = {center_idx: (0, 0)}\n\n    changed = True\n    while changed:\n        changed = False\n        best_shape_idx = None\n        best_offset = None\n        best_match_count = 0\n\n        for ui in range(len(shapes)):\n            if ui in placed:\n                continue\n\n            unplaced = shapes[ui]\n            for uc in unplaced['connectors']:\n                for fc in list(free_connectors):\n                    dr = int(fc[0] - uc[0])\n                    dc = int(fc[1] - uc[1])\n\n                    shifted_body = {(r + dr, c + dc) for r, c in unplaced['body']}\n                    shifted_connectors = {(r + dr, c + dc) for r, c in unplaced['connectors']}\n\n                    # Check no overlaps between new body and placed body/connectors\n                    if shifted_body & placed_body:\n                        continue\n                    if shifted_body & placed_connectors:\n                        continue\n                    if shifted_connectors & placed_body:\n                        continue\n\n                    # Check bounds\n                    all_shifted = shifted_body | shifted_connectors\n                    if any(r < 0 or r >= rows or c < 0 or c >= cols for r, c in all_shifted):\n                        continue\n\n                    # Count connector matches\n                    matched = shifted_connectors & free_connectors\n                    unmatched = shifted_connectors - free_connectors\n                    already_matched = placed_connectors - free_connectors\n                    if unmatched & already_matched:\n                        continue\n\n                    match_count = len(matched)\n                    if match_count > best_match_count:\n                        best_match_count = match_count\n                        best_shape_idx = ui\n                        best_offset = (dr, dc)\n\n        if best_shape_idx is not None and best_match_count > 0:\n            ui = best_shape_idx\n            dr, dc = best_offset\n            unplaced = shapes[ui]\n            shifted_body = {(r + dr, c + dc) for r, c in unplaced['body']}\n            shifted_connectors = {(r + dr, c + dc) for r, c in unplaced['connectors']}\n\n            matched = shifted_connectors & free_connectors\n            unmatched_new = shifted_connectors - free_connectors\n\n            placed.add(ui)\n            offsets[ui] = best_offset\n            placed_body |= shifted_body\n            placed_connectors |= shifted_connectors\n            free_connectors -= matched\n            free_connectors |= unmatched_new\n            changed = True\n\n    # Build output grid\n    output = np.zeros_like(grid)\n    for i, (dr, dc) in offsets.items():\n        shape = shapes[i]\n        for r, c in shape['body']:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output[nr, nc] = shape['color']\n        for r, c in shape['connectors']:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output[nr, nc] = 2\n\n    return output.tolist()\n"}], "test_results": [{"success": false, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 2, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 8, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 2, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 2, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 0.0, "error": null, "code": "def transform(grid):\n    \"\"\"Assemble puzzle pieces by matching their 2-connectors.\n\n    Each shape (connected component of non-zero, non-2 cells) has 2-valued connector cells\n    on its border. The color-4 shape stays fixed as the center piece. All other shapes are\n    translated (without rotation) so their connectors align with free connectors of already-placed\n    shapes, assembling the puzzle outward from the center using BFS with greedy matching\n    (preferring placements that match the most connectors simultaneously).\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Find body cells (non-zero, non-2)\n    body_mask = (grid != 0) & (grid != 2)\n    labeled, n = label(body_mask)\n\n    # Extract shapes with their body cells and 2-connectors\n    shapes = []\n    for comp in range(1, n + 1):\n        body_cells = set(map(tuple, np.argwhere(labeled == comp)))\n        color = int(grid[list(body_cells)[0][0], list(body_cells)[0][1]])\n\n        connectors = set()\n        for r, c in body_cells:\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 2:\n                    connectors.add((nr, nc))\n\n        shapes.append({\n            'color': color,\n            'body': body_cells,\n            'connectors': connectors,\n        })\n\n    # Find center shape (color 4)\n    center_idx = None\n    for i, s in enumerate(shapes):\n        if s['color'] == 4:\n            center_idx = i\n            break\n\n    if center_idx is None:\n        return grid.tolist()\n\n    # Assembly via greedy BFS\n    placed = {center_idx}\n    placed_body = set(shapes[center_idx]['body'])\n    placed_connectors = set(shapes[center_idx]['connectors'])\n    free_connectors = set(shapes[center_idx]['connectors'])\n    offsets = {center_idx: (0, 0)}\n\n    changed = True\n    while changed:\n        changed = False\n        best_shape_idx = None\n        best_offset = None\n        best_match_count = 0\n\n        for ui in range(len(shapes)):\n            if ui in placed:\n                continue\n\n            unplaced = shapes[ui]\n            for uc in unplaced['connectors']:\n                for fc in list(free_connectors):\n                    dr = int(fc[0] - uc[0])\n                    dc = int(fc[1] - uc[1])\n\n                    shifted_body = {(r + dr, c + dc) for r, c in unplaced['body']}\n                    shifted_connectors = {(r + dr, c + dc) for r, c in unplaced['connectors']}\n\n                    # Check no overlaps between new body and placed body/connectors\n                    if shifted_body & placed_body:\n                        continue\n                    if shifted_body & placed_connectors:\n                        continue\n                    if shifted_connectors & placed_body:\n                        continue\n\n                    # Check bounds\n                    all_shifted = shifted_body | shifted_connectors\n                    if any(r < 0 or r >= rows or c < 0 or c >= cols for r, c in all_shifted):\n                        continue\n\n                    # Count connector matches\n                    matched = shifted_connectors & free_connectors\n                    unmatched = shifted_connectors - free_connectors\n                    already_matched = placed_connectors - free_connectors\n                    if unmatched & already_matched:\n                        continue\n\n                    match_count = len(matched)\n                    if match_count > best_match_count:\n                        best_match_count = match_count\n                        best_shape_idx = ui\n                        best_offset = (dr, dc)\n\n        if best_shape_idx is not None and best_match_count > 0:\n            ui = best_shape_idx\n            dr, dc = best_offset\n            unplaced = shapes[ui]\n            shifted_body = {(r + dr, c + dc) for r, c in unplaced['body']}\n            shifted_connectors = {(r + dr, c + dc) for r, c in unplaced['connectors']}\n\n            matched = shifted_connectors & free_connectors\n            unmatched_new = shifted_connectors - free_connectors\n\n            placed.add(ui)\n            offsets[ui] = best_offset\n            placed_body |= shifted_body\n            placed_connectors |= shifted_connectors\n            free_connectors -= matched\n            free_connectors |= unmatched_new\n            changed = True\n\n    # Build output grid\n    output = np.zeros_like(grid)\n    for i, (dr, dc) in offsets.items():\n        shape = shapes[i]\n        for r, c in shape['body']:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output[nr, nc] = shape['color']\n        for r, c in shape['connectors']:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output[nr, nc] = 2\n\n    return output.tolist()\n"}, {"success": false, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 5, 5, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 2, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 2, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 0.0, "error": null, "code": "def transform(grid):\n    \"\"\"Assemble puzzle pieces by matching their 2-connectors.\n\n    Each shape (connected component of non-zero, non-2 cells) has 2-valued connector cells\n    on its border. The color-4 shape stays fixed as the center piece. All other shapes are\n    translated (without rotation) so their connectors align with free connectors of already-placed\n    shapes, assembling the puzzle outward from the center using BFS with greedy matching\n    (preferring placements that match the most connectors simultaneously).\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Find body cells (non-zero, non-2)\n    body_mask = (grid != 0) & (grid != 2)\n    labeled, n = label(body_mask)\n\n    # Extract shapes with their body cells and 2-connectors\n    shapes = []\n    for comp in range(1, n + 1):\n        body_cells = set(map(tuple, np.argwhere(labeled == comp)))\n        color = int(grid[list(body_cells)[0][0], list(body_cells)[0][1]])\n\n        connectors = set()\n        for r, c in body_cells:\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 2:\n                    connectors.add((nr, nc))\n\n        shapes.append({\n            'color': color,\n            'body': body_cells,\n            'connectors': connectors,\n        })\n\n    # Find center shape (color 4)\n    center_idx = None\n    for i, s in enumerate(shapes):\n        if s['color'] == 4:\n            center_idx = i\n            break\n\n    if center_idx is None:\n        return grid.tolist()\n\n    # Assembly via greedy BFS\n    placed = {center_idx}\n    placed_body = set(shapes[center_idx]['body'])\n    placed_connectors = set(shapes[center_idx]['connectors'])\n    free_connectors = set(shapes[center_idx]['connectors'])\n    offsets = {center_idx: (0, 0)}\n\n    changed = True\n    while changed:\n        changed = False\n        best_shape_idx = None\n        best_offset = None\n        best_match_count = 0\n\n        for ui in range(len(shapes)):\n            if ui in placed:\n                continue\n\n            unplaced = shapes[ui]\n            for uc in unplaced['connectors']:\n                for fc in list(free_connectors):\n                    dr = int(fc[0] - uc[0])\n                    dc = int(fc[1] - uc[1])\n\n                    shifted_body = {(r + dr, c + dc) for r, c in unplaced['body']}\n                    shifted_connectors = {(r + dr, c + dc) for r, c in unplaced['connectors']}\n\n                    # Check no overlaps between new body and placed body/connectors\n                    if shifted_body & placed_body:\n                        continue\n                    if shifted_body & placed_connectors:\n                        continue\n                    if shifted_connectors & placed_body:\n                        continue\n\n                    # Check bounds\n                    all_shifted = shifted_body | shifted_connectors\n                    if any(r < 0 or r >= rows or c < 0 or c >= cols for r, c in all_shifted):\n                        continue\n\n                    # Count connector matches\n                    matched = shifted_connectors & free_connectors\n                    unmatched = shifted_connectors - free_connectors\n                    already_matched = placed_connectors - free_connectors\n                    if unmatched & already_matched:\n                        continue\n\n                    match_count = len(matched)\n                    if match_count > best_match_count:\n                        best_match_count = match_count\n                        best_shape_idx = ui\n                        best_offset = (dr, dc)\n\n        if best_shape_idx is not None and best_match_count > 0:\n            ui = best_shape_idx\n            dr, dc = best_offset\n            unplaced = shapes[ui]\n            shifted_body = {(r + dr, c + dc) for r, c in unplaced['body']}\n            shifted_connectors = {(r + dr, c + dc) for r, c in unplaced['connectors']}\n\n            matched = shifted_connectors & free_connectors\n            unmatched_new = shifted_connectors - free_connectors\n\n            placed.add(ui)\n            offsets[ui] = best_offset\n            placed_body |= shifted_body\n            placed_connectors |= shifted_connectors\n            free_connectors -= matched\n            free_connectors |= unmatched_new\n            changed = True\n\n    # Build output grid\n    output = np.zeros_like(grid)\n    for i, (dr, dc) in offsets.items():\n        shape = shapes[i]\n        for r, c in shape['body']:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output[nr, nc] = shape['color']\n        for r, c in shape['connectors']:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output[nr, nc] = 2\n\n    return output.tolist()\n"}], "agent_usage": [{"input_tokens": 405003, "input_tokens_details": {"cached_tokens": 353306}, "output_tokens": 35476, "output_tokens_details": {"reasoning_tokens": -12}, "total_tokens": 35490, "inference_count": 12, "cache_creation": {"ephemeral_1h_input_tokens": 51683, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 51683, "inference_geo": ["global"], "service_tier": ["standard"]}], "time_taken": 1188.3401234149933, "num_agents_used": 1, "model": "anthropic/claude-opus-4-6", "reasoning_effort": "high", "error": null, "problem_id": "cbebaa4b", "attempt_id": 1, "num": 0, "iteration": 12}