{"train_results": [{"success": true, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 1, 2, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 2, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Assembles puzzle pieces by matching their connector ports (color 2).\n\n    Each piece in the input grid consists of a body (non-zero, non-2 colored cells) \n    and connector ports (color 2 cells adjacent to the body). The piece with color 4 \n    (a solid filled rectangle) serves as the hub/anchor and stays in place. Other pieces \n    are assembled by matching their connector ports with opposing ports on already-placed \n    pieces. Pieces with the most simultaneous port matches are placed first.\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n    from collections import deque\n\n    grid_np = np.array(grid)\n    H, W = grid_np.shape\n\n    # Find connected components of non-zero cells\n    binary = (grid_np != 0).astype(int)\n    labels, num_features = label(binary)\n\n    # Extract pieces\n    pieces = []\n    for i in range(1, num_features + 1):\n        mask = labels == i\n        cells = list(zip(*np.where(mask)))\n\n        body_cells = [(int(r), int(c)) for r, c in cells if grid_np[r, c] != 2]\n        port_cells = [(int(r), int(c)) for r, c in cells if grid_np[r, c] == 2]\n\n        body_colors = set(int(grid_np[r, c]) for r, c in body_cells)\n        if len(body_colors) != 1:\n            continue\n        body_color = body_colors.pop()\n\n        body_set = set(body_cells)\n        ports = []\n        for pr, pc in port_cells:\n            body_neighbors = []\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = pr + dr, pc + dc\n                if (nr, nc) in body_set:\n                    body_neighbors.append((-dr, -dc))\n\n            if len(body_neighbors) == 1:\n                port_dir = body_neighbors[0]\n            else:\n                # Find the unique non-body direction\n                non_body_dirs = []\n                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nr, nc = pr + dr, pc + dc\n                    if (nr, nc) not in body_set:\n                        non_body_dirs.append((dr, dc))\n                if len(non_body_dirs) == 1:\n                    port_dir = non_body_dirs[0]\n                else:\n                    body_r = sum(r for r, c in body_cells) / len(body_cells)\n                    body_c = sum(c for r, c in body_cells) / len(body_cells)\n                    dr = pr - body_r\n                    dc = pc - body_c\n                    if abs(dr) > abs(dc):\n                        port_dir = (1 if dr > 0 else -1, 0)\n                    else:\n                        port_dir = (0, 1 if dc > 0 else -1)\n\n            ports.append({'pos': (pr, pc), 'dir': port_dir})\n\n        all_cells = {}\n        for r, c in cells:\n            all_cells[(int(r), int(c))] = int(grid_np[r, c])\n\n        pieces.append({\n            'body_color': body_color,\n            'body_cells': body_cells,\n            'ports': ports,\n            'all_cells': all_cells\n        })\n\n    # Find hub piece (color 4)\n    hub_idx = None\n    for i, p in enumerate(pieces):\n        if p['body_color'] == 4:\n            hub_idx = i\n            break\n\n    if hub_idx is None:\n        return grid  # No hub found, return as-is\n\n    # Initialize output\n    output = np.zeros((H, W), dtype=int)\n\n    # Place hub at original position\n    placed = {hub_idx}\n    offsets = {hub_idx: (0, 0)}\n    for (r, c), v in pieces[hub_idx]['all_cells'].items():\n        output[r, c] = v\n\n    # Iteratively place pieces with most simultaneous port matches\n    for _ in range(len(pieces)):\n        if len(placed) == len(pieces):\n            break\n\n        # Collect all placed ports\n        placed_port_map = {}\n        for pi in placed:\n            dr, dc = offsets[pi]\n            for port in pieces[pi]['ports']:\n                pr, pc = port['pos']\n                pos = (pr + dr, pc + dc)\n                if pos not in placed_port_map:\n                    placed_port_map[pos] = []\n                placed_port_map[pos].append(port['dir'])\n\n        best_match = None\n        best_count = 0\n\n        for bi, bpiece in enumerate(pieces):\n            if bi in placed:\n                continue\n\n            tried_offsets = set()\n            for bport in bpiece['ports']:\n                for pp_pos, pp_dirs in placed_port_map.items():\n                    for pp_dir in pp_dirs:\n                        if bport['dir'][0] + pp_dir[0] != 0 or bport['dir'][1] + pp_dir[1] != 0:\n                            continue\n\n                        offset = (pp_pos[0] - bport['pos'][0], pp_pos[1] - bport['pos'][1])\n                        if offset in tried_offsets:\n                            continue\n                        tried_offsets.add(offset)\n\n                        # Check validity\n                        valid = True\n                        for (r, c), v in bpiece['all_cells'].items():\n                            nr, nc = r + offset[0], c + offset[1]\n                            if nr < 0 or nr >= H or nc < 0 or nc >= W:\n                                valid = False\n                                break\n                            existing = output[nr, nc]\n                            if existing != 0 and not (existing == 2 and v == 2):\n                                valid = False\n                                break\n\n                        if not valid:\n                            continue\n\n                        # Count port matches\n                        match_count = 0\n                        for bp in bpiece['ports']:\n                            tp = (bp['pos'][0] + offset[0], bp['pos'][1] + offset[1])\n                            if tp in placed_port_map:\n                                for pd in placed_port_map[tp]:\n                                    if bp['dir'][0] + pd[0] == 0 and bp['dir'][1] + pd[1] == 0:\n                                        match_count += 1\n\n                        if match_count > best_count:\n                            best_count = match_count\n                            best_match = (bi, offset)\n\n        if best_match is None:\n            break\n\n        bi, offset = best_match\n        placed.add(bi)\n        offsets[bi] = offset\n        for (r, c), v in pieces[bi]['all_cells'].items():\n            nr, nc = r + offset[0], c + offset[1]\n            if output[nr, nc] == 0:\n                output[nr, nc] = v\n\n    return output.tolist()\n"}, {"success": true, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 4, 4, 4, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 4, 4, 4, 2, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Assembles puzzle pieces by matching their connector ports (color 2).\n\n    Each piece in the input grid consists of a body (non-zero, non-2 colored cells) \n    and connector ports (color 2 cells adjacent to the body). The piece with color 4 \n    (a solid filled rectangle) serves as the hub/anchor and stays in place. Other pieces \n    are assembled by matching their connector ports with opposing ports on already-placed \n    pieces. Pieces with the most simultaneous port matches are placed first.\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n    from collections import deque\n\n    grid_np = np.array(grid)\n    H, W = grid_np.shape\n\n    # Find connected components of non-zero cells\n    binary = (grid_np != 0).astype(int)\n    labels, num_features = label(binary)\n\n    # Extract pieces\n    pieces = []\n    for i in range(1, num_features + 1):\n        mask = labels == i\n        cells = list(zip(*np.where(mask)))\n\n        body_cells = [(int(r), int(c)) for r, c in cells if grid_np[r, c] != 2]\n        port_cells = [(int(r), int(c)) for r, c in cells if grid_np[r, c] == 2]\n\n        body_colors = set(int(grid_np[r, c]) for r, c in body_cells)\n        if len(body_colors) != 1:\n            continue\n        body_color = body_colors.pop()\n\n        body_set = set(body_cells)\n        ports = []\n        for pr, pc in port_cells:\n            body_neighbors = []\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = pr + dr, pc + dc\n                if (nr, nc) in body_set:\n                    body_neighbors.append((-dr, -dc))\n\n            if len(body_neighbors) == 1:\n                port_dir = body_neighbors[0]\n            else:\n                # Find the unique non-body direction\n                non_body_dirs = []\n                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nr, nc = pr + dr, pc + dc\n                    if (nr, nc) not in body_set:\n                        non_body_dirs.append((dr, dc))\n                if len(non_body_dirs) == 1:\n                    port_dir = non_body_dirs[0]\n                else:\n                    body_r = sum(r for r, c in body_cells) / len(body_cells)\n                    body_c = sum(c for r, c in body_cells) / len(body_cells)\n                    dr = pr - body_r\n                    dc = pc - body_c\n                    if abs(dr) > abs(dc):\n                        port_dir = (1 if dr > 0 else -1, 0)\n                    else:\n                        port_dir = (0, 1 if dc > 0 else -1)\n\n            ports.append({'pos': (pr, pc), 'dir': port_dir})\n\n        all_cells = {}\n        for r, c in cells:\n            all_cells[(int(r), int(c))] = int(grid_np[r, c])\n\n        pieces.append({\n            'body_color': body_color,\n            'body_cells': body_cells,\n            'ports': ports,\n            'all_cells': all_cells\n        })\n\n    # Find hub piece (color 4)\n    hub_idx = None\n    for i, p in enumerate(pieces):\n        if p['body_color'] == 4:\n            hub_idx = i\n            break\n\n    if hub_idx is None:\n        return grid  # No hub found, return as-is\n\n    # Initialize output\n    output = np.zeros((H, W), dtype=int)\n\n    # Place hub at original position\n    placed = {hub_idx}\n    offsets = {hub_idx: (0, 0)}\n    for (r, c), v in pieces[hub_idx]['all_cells'].items():\n        output[r, c] = v\n\n    # Iteratively place pieces with most simultaneous port matches\n    for _ in range(len(pieces)):\n        if len(placed) == len(pieces):\n            break\n\n        # Collect all placed ports\n        placed_port_map = {}\n        for pi in placed:\n            dr, dc = offsets[pi]\n            for port in pieces[pi]['ports']:\n                pr, pc = port['pos']\n                pos = (pr + dr, pc + dc)\n                if pos not in placed_port_map:\n                    placed_port_map[pos] = []\n                placed_port_map[pos].append(port['dir'])\n\n        best_match = None\n        best_count = 0\n\n        for bi, bpiece in enumerate(pieces):\n            if bi in placed:\n                continue\n\n            tried_offsets = set()\n            for bport in bpiece['ports']:\n                for pp_pos, pp_dirs in placed_port_map.items():\n                    for pp_dir in pp_dirs:\n                        if bport['dir'][0] + pp_dir[0] != 0 or bport['dir'][1] + pp_dir[1] != 0:\n                            continue\n\n                        offset = (pp_pos[0] - bport['pos'][0], pp_pos[1] - bport['pos'][1])\n                        if offset in tried_offsets:\n                            continue\n                        tried_offsets.add(offset)\n\n                        # Check validity\n                        valid = True\n                        for (r, c), v in bpiece['all_cells'].items():\n                            nr, nc = r + offset[0], c + offset[1]\n                            if nr < 0 or nr >= H or nc < 0 or nc >= W:\n                                valid = False\n                                break\n                            existing = output[nr, nc]\n                            if existing != 0 and not (existing == 2 and v == 2):\n                                valid = False\n                                break\n\n                        if not valid:\n                            continue\n\n                        # Count port matches\n                        match_count = 0\n                        for bp in bpiece['ports']:\n                            tp = (bp['pos'][0] + offset[0], bp['pos'][1] + offset[1])\n                            if tp in placed_port_map:\n                                for pd in placed_port_map[tp]:\n                                    if bp['dir'][0] + pd[0] == 0 and bp['dir'][1] + pd[1] == 0:\n                                        match_count += 1\n\n                        if match_count > best_count:\n                            best_count = match_count\n                            best_match = (bi, offset)\n\n        if best_match is None:\n            break\n\n        bi, offset = best_match\n        placed.add(bi)\n        offsets[bi] = offset\n        for (r, c), v in pieces[bi]['all_cells'].items():\n            nr, nc = r + offset[0], c + offset[1]\n            if output[nr, nc] == 0:\n                output[nr, nc] = v\n\n    return output.tolist()\n"}], "test_results": [{"success": false, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 2, 9, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 8, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 2, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 2, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 0.0, "error": null, "code": "\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Assembles puzzle pieces by matching their connector ports (color 2).\n\n    Each piece in the input grid consists of a body (non-zero, non-2 colored cells) \n    and connector ports (color 2 cells adjacent to the body). The piece with color 4 \n    (a solid filled rectangle) serves as the hub/anchor and stays in place. Other pieces \n    are assembled by matching their connector ports with opposing ports on already-placed \n    pieces. Pieces with the most simultaneous port matches are placed first.\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n    from collections import deque\n\n    grid_np = np.array(grid)\n    H, W = grid_np.shape\n\n    # Find connected components of non-zero cells\n    binary = (grid_np != 0).astype(int)\n    labels, num_features = label(binary)\n\n    # Extract pieces\n    pieces = []\n    for i in range(1, num_features + 1):\n        mask = labels == i\n        cells = list(zip(*np.where(mask)))\n\n        body_cells = [(int(r), int(c)) for r, c in cells if grid_np[r, c] != 2]\n        port_cells = [(int(r), int(c)) for r, c in cells if grid_np[r, c] == 2]\n\n        body_colors = set(int(grid_np[r, c]) for r, c in body_cells)\n        if len(body_colors) != 1:\n            continue\n        body_color = body_colors.pop()\n\n        body_set = set(body_cells)\n        ports = []\n        for pr, pc in port_cells:\n            body_neighbors = []\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = pr + dr, pc + dc\n                if (nr, nc) in body_set:\n                    body_neighbors.append((-dr, -dc))\n\n            if len(body_neighbors) == 1:\n                port_dir = body_neighbors[0]\n            else:\n                # Find the unique non-body direction\n                non_body_dirs = []\n                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nr, nc = pr + dr, pc + dc\n                    if (nr, nc) not in body_set:\n                        non_body_dirs.append((dr, dc))\n                if len(non_body_dirs) == 1:\n                    port_dir = non_body_dirs[0]\n                else:\n                    body_r = sum(r for r, c in body_cells) / len(body_cells)\n                    body_c = sum(c for r, c in body_cells) / len(body_cells)\n                    dr = pr - body_r\n                    dc = pc - body_c\n                    if abs(dr) > abs(dc):\n                        port_dir = (1 if dr > 0 else -1, 0)\n                    else:\n                        port_dir = (0, 1 if dc > 0 else -1)\n\n            ports.append({'pos': (pr, pc), 'dir': port_dir})\n\n        all_cells = {}\n        for r, c in cells:\n            all_cells[(int(r), int(c))] = int(grid_np[r, c])\n\n        pieces.append({\n            'body_color': body_color,\n            'body_cells': body_cells,\n            'ports': ports,\n            'all_cells': all_cells\n        })\n\n    # Find hub piece (color 4)\n    hub_idx = None\n    for i, p in enumerate(pieces):\n        if p['body_color'] == 4:\n            hub_idx = i\n            break\n\n    if hub_idx is None:\n        return grid  # No hub found, return as-is\n\n    # Initialize output\n    output = np.zeros((H, W), dtype=int)\n\n    # Place hub at original position\n    placed = {hub_idx}\n    offsets = {hub_idx: (0, 0)}\n    for (r, c), v in pieces[hub_idx]['all_cells'].items():\n        output[r, c] = v\n\n    # Iteratively place pieces with most simultaneous port matches\n    for _ in range(len(pieces)):\n        if len(placed) == len(pieces):\n            break\n\n        # Collect all placed ports\n        placed_port_map = {}\n        for pi in placed:\n            dr, dc = offsets[pi]\n            for port in pieces[pi]['ports']:\n                pr, pc = port['pos']\n                pos = (pr + dr, pc + dc)\n                if pos not in placed_port_map:\n                    placed_port_map[pos] = []\n                placed_port_map[pos].append(port['dir'])\n\n        best_match = None\n        best_count = 0\n\n        for bi, bpiece in enumerate(pieces):\n            if bi in placed:\n                continue\n\n            tried_offsets = set()\n            for bport in bpiece['ports']:\n                for pp_pos, pp_dirs in placed_port_map.items():\n                    for pp_dir in pp_dirs:\n                        if bport['dir'][0] + pp_dir[0] != 0 or bport['dir'][1] + pp_dir[1] != 0:\n                            continue\n\n                        offset = (pp_pos[0] - bport['pos'][0], pp_pos[1] - bport['pos'][1])\n                        if offset in tried_offsets:\n                            continue\n                        tried_offsets.add(offset)\n\n                        # Check validity\n                        valid = True\n                        for (r, c), v in bpiece['all_cells'].items():\n                            nr, nc = r + offset[0], c + offset[1]\n                            if nr < 0 or nr >= H or nc < 0 or nc >= W:\n                                valid = False\n                                break\n                            existing = output[nr, nc]\n                            if existing != 0 and not (existing == 2 and v == 2):\n                                valid = False\n                                break\n\n                        if not valid:\n                            continue\n\n                        # Count port matches\n                        match_count = 0\n                        for bp in bpiece['ports']:\n                            tp = (bp['pos'][0] + offset[0], bp['pos'][1] + offset[1])\n                            if tp in placed_port_map:\n                                for pd in placed_port_map[tp]:\n                                    if bp['dir'][0] + pd[0] == 0 and bp['dir'][1] + pd[1] == 0:\n                                        match_count += 1\n\n                        if match_count > best_count:\n                            best_count = match_count\n                            best_match = (bi, offset)\n\n        if best_match is None:\n            break\n\n        bi, offset = best_match\n        placed.add(bi)\n        offsets[bi] = offset\n        for (r, c), v in pieces[bi]['all_cells'].items():\n            nr, nc = r + offset[0], c + offset[1]\n            if output[nr, nc] == 0:\n                output[nr, nc] = v\n\n    return output.tolist()\n"}, {"success": false, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 5, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 8, 8, 2, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 8, 2, 4, 4, 4, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 2, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 3, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 6, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 0.0, "error": null, "code": "\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Assembles puzzle pieces by matching their connector ports (color 2).\n\n    Each piece in the input grid consists of a body (non-zero, non-2 colored cells) \n    and connector ports (color 2 cells adjacent to the body). The piece with color 4 \n    (a solid filled rectangle) serves as the hub/anchor and stays in place. Other pieces \n    are assembled by matching their connector ports with opposing ports on already-placed \n    pieces. Pieces with the most simultaneous port matches are placed first.\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n    from collections import deque\n\n    grid_np = np.array(grid)\n    H, W = grid_np.shape\n\n    # Find connected components of non-zero cells\n    binary = (grid_np != 0).astype(int)\n    labels, num_features = label(binary)\n\n    # Extract pieces\n    pieces = []\n    for i in range(1, num_features + 1):\n        mask = labels == i\n        cells = list(zip(*np.where(mask)))\n\n        body_cells = [(int(r), int(c)) for r, c in cells if grid_np[r, c] != 2]\n        port_cells = [(int(r), int(c)) for r, c in cells if grid_np[r, c] == 2]\n\n        body_colors = set(int(grid_np[r, c]) for r, c in body_cells)\n        if len(body_colors) != 1:\n            continue\n        body_color = body_colors.pop()\n\n        body_set = set(body_cells)\n        ports = []\n        for pr, pc in port_cells:\n            body_neighbors = []\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = pr + dr, pc + dc\n                if (nr, nc) in body_set:\n                    body_neighbors.append((-dr, -dc))\n\n            if len(body_neighbors) == 1:\n                port_dir = body_neighbors[0]\n            else:\n                # Find the unique non-body direction\n                non_body_dirs = []\n                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nr, nc = pr + dr, pc + dc\n                    if (nr, nc) not in body_set:\n                        non_body_dirs.append((dr, dc))\n                if len(non_body_dirs) == 1:\n                    port_dir = non_body_dirs[0]\n                else:\n                    body_r = sum(r for r, c in body_cells) / len(body_cells)\n                    body_c = sum(c for r, c in body_cells) / len(body_cells)\n                    dr = pr - body_r\n                    dc = pc - body_c\n                    if abs(dr) > abs(dc):\n                        port_dir = (1 if dr > 0 else -1, 0)\n                    else:\n                        port_dir = (0, 1 if dc > 0 else -1)\n\n            ports.append({'pos': (pr, pc), 'dir': port_dir})\n\n        all_cells = {}\n        for r, c in cells:\n            all_cells[(int(r), int(c))] = int(grid_np[r, c])\n\n        pieces.append({\n            'body_color': body_color,\n            'body_cells': body_cells,\n            'ports': ports,\n            'all_cells': all_cells\n        })\n\n    # Find hub piece (color 4)\n    hub_idx = None\n    for i, p in enumerate(pieces):\n        if p['body_color'] == 4:\n            hub_idx = i\n            break\n\n    if hub_idx is None:\n        return grid  # No hub found, return as-is\n\n    # Initialize output\n    output = np.zeros((H, W), dtype=int)\n\n    # Place hub at original position\n    placed = {hub_idx}\n    offsets = {hub_idx: (0, 0)}\n    for (r, c), v in pieces[hub_idx]['all_cells'].items():\n        output[r, c] = v\n\n    # Iteratively place pieces with most simultaneous port matches\n    for _ in range(len(pieces)):\n        if len(placed) == len(pieces):\n            break\n\n        # Collect all placed ports\n        placed_port_map = {}\n        for pi in placed:\n            dr, dc = offsets[pi]\n            for port in pieces[pi]['ports']:\n                pr, pc = port['pos']\n                pos = (pr + dr, pc + dc)\n                if pos not in placed_port_map:\n                    placed_port_map[pos] = []\n                placed_port_map[pos].append(port['dir'])\n\n        best_match = None\n        best_count = 0\n\n        for bi, bpiece in enumerate(pieces):\n            if bi in placed:\n                continue\n\n            tried_offsets = set()\n            for bport in bpiece['ports']:\n                for pp_pos, pp_dirs in placed_port_map.items():\n                    for pp_dir in pp_dirs:\n                        if bport['dir'][0] + pp_dir[0] != 0 or bport['dir'][1] + pp_dir[1] != 0:\n                            continue\n\n                        offset = (pp_pos[0] - bport['pos'][0], pp_pos[1] - bport['pos'][1])\n                        if offset in tried_offsets:\n                            continue\n                        tried_offsets.add(offset)\n\n                        # Check validity\n                        valid = True\n                        for (r, c), v in bpiece['all_cells'].items():\n                            nr, nc = r + offset[0], c + offset[1]\n                            if nr < 0 or nr >= H or nc < 0 or nc >= W:\n                                valid = False\n                                break\n                            existing = output[nr, nc]\n                            if existing != 0 and not (existing == 2 and v == 2):\n                                valid = False\n                                break\n\n                        if not valid:\n                            continue\n\n                        # Count port matches\n                        match_count = 0\n                        for bp in bpiece['ports']:\n                            tp = (bp['pos'][0] + offset[0], bp['pos'][1] + offset[1])\n                            if tp in placed_port_map:\n                                for pd in placed_port_map[tp]:\n                                    if bp['dir'][0] + pd[0] == 0 and bp['dir'][1] + pd[1] == 0:\n                                        match_count += 1\n\n                        if match_count > best_count:\n                            best_count = match_count\n                            best_match = (bi, offset)\n\n        if best_match is None:\n            break\n\n        bi, offset = best_match\n        placed.add(bi)\n        offsets[bi] = offset\n        for (r, c), v in pieces[bi]['all_cells'].items():\n            nr, nc = r + offset[0], c + offset[1]\n            if output[nr, nc] == 0:\n                output[nr, nc] = v\n\n    return output.tolist()\n"}], "agent_usage": [{"input_tokens": 770793, "input_tokens_details": {"cached_tokens": 660581}, "output_tokens": 85186, "output_tokens_details": {"reasoning_tokens": -15}, "total_tokens": 85203, "inference_count": 15, "cache_creation": {"ephemeral_1h_input_tokens": 110195, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 110195, "inference_geo": ["global"], "service_tier": ["standard"]}], "time_taken": 2252.64284157753, "num_agents_used": 1, "model": "anthropic/claude-opus-4-6", "reasoning_effort": "high", "error": null, "problem_id": "cbebaa4b", "attempt_id": 0, "num": 0, "iteration": 15}