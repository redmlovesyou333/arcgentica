{"train_results": [{"success": true, "output": "[[7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5], [7, 1, 1, 2, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2, 1, 1, 5], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5], [7, 1, 1, 2, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2, 1, 1, 5], [7, 7, 7, 7, 7, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 7, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 7, 7, 7, 0, 0, 5, 5, 5, 5, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 5, 5, 5, 0, 0, 5, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 7, 5, 5, 5, 5, 0, 0, 0, 0, 5, 0], [0, 7, 7, 0, 0, 0, 0, 0, 4, 7, 5, 0, 0, 0, 0, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 7, 0, 0, 0, 7, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 5, 4, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [0, 5, 4, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 5, 0, 0, 0, 0, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 5, 5, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [0, 0, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform by moving each 4-marker to the wall of its enclosing region in the direction \n    specified by the corresponding template pattern.\n\n    Templates are small bordered rectangles containing two non-border colors. The direction \n    is from the centroid of the more frequent interior color to the centroid of the less frequent one.\n    Each 4 moves in that direction (matched by its enclosing border color) until hitting a wall.\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Step 1: Find templates (connected components of non-zero, non-4 cells with 3 distinct values)\n    template_mask = (grid != 0) & (grid != 4)\n    labeled, num_features = label(template_mask)\n\n    templates = {}  # border_color -> direction (dr, dc)\n\n    for comp_id in range(1, num_features + 1):\n        comp_mask = labeled == comp_id\n        values_in_comp = set(grid[comp_mask].tolist()) - {0, 4}\n\n        if len(values_in_comp) != 3:\n            continue\n\n        # Border color is the most frequent value in the component\n        value_counts = {v: int(np.sum(grid[comp_mask] == v)) for v in values_in_comp}\n        border_color = max(value_counts, key=value_counts.get)\n        interior_colors = sorted(values_in_comp - {border_color})\n\n        # Find positions of each interior color\n        a_pos = np.argwhere(comp_mask & (grid == interior_colors[0]))\n        b_pos = np.argwhere(comp_mask & (grid == interior_colors[1]))\n\n        # Direction: from more frequent interior color to less frequent\n        if len(a_pos) >= len(b_pos):\n            centroid_more = a_pos.mean(axis=0)\n            centroid_fewer = b_pos.mean(axis=0)\n        else:\n            centroid_more = b_pos.mean(axis=0)\n            centroid_fewer = a_pos.mean(axis=0)\n\n        diff = centroid_fewer - centroid_more\n        direction = (int(np.sign(diff[0])), int(np.sign(diff[1])))\n        templates[border_color] = direction\n\n    # Step 2: For each 4, flood-fill to find enclosing border color, then move in template direction\n    result = grid.copy()\n    four_positions = list(zip(*np.where(grid == 4)))\n\n    for r, c in four_positions:\n        visited = set()\n        border_color_counts = {}\n        stack = [(int(r), int(c))]\n\n        while stack:\n            cr, cc = stack.pop()\n            if (cr, cc) in visited or cr < 0 or cr >= rows or cc < 0 or cc >= cols:\n                continue\n            val = grid[cr, cc]\n            if val != 0 and val != 4:\n                border_color_counts[val] = border_color_counts.get(val, 0) + 1\n                continue\n            visited.add((cr, cc))\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                stack.append((cr + dr, cc + dc))\n\n        if not border_color_counts:\n            continue\n\n        border_color = max(border_color_counts, key=border_color_counts.get)\n        if border_color not in templates:\n            continue\n\n        dr, dc = templates[border_color]\n\n        # Move the 4 until hitting a wall\n        nr, nc = int(r) + dr, int(c) + dc\n        while 0 <= nr < rows and 0 <= nc < cols and (grid[nr, nc] == 0 or grid[nr, nc] == 4):\n            nr += dr\n            nc += dc\n        nr -= dr\n        nc -= dc\n\n        result[int(r), int(c)] = 0\n        result[nr, nc] = 4\n\n    return result.tolist()\n"}, {"success": true, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 1, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 5, 5, 1, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 1, 5, 5, 2, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 2, 5, 5, 5], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 5, 5, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 4, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 5, 5, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 5, 5, 0, 5, 5, 5, 0, 5, 0, 0, 0, 4, 5, 5, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 5, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform by moving each 4-marker to the wall of its enclosing region in the direction \n    specified by the corresponding template pattern.\n\n    Templates are small bordered rectangles containing two non-border colors. The direction \n    is from the centroid of the more frequent interior color to the centroid of the less frequent one.\n    Each 4 moves in that direction (matched by its enclosing border color) until hitting a wall.\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Step 1: Find templates (connected components of non-zero, non-4 cells with 3 distinct values)\n    template_mask = (grid != 0) & (grid != 4)\n    labeled, num_features = label(template_mask)\n\n    templates = {}  # border_color -> direction (dr, dc)\n\n    for comp_id in range(1, num_features + 1):\n        comp_mask = labeled == comp_id\n        values_in_comp = set(grid[comp_mask].tolist()) - {0, 4}\n\n        if len(values_in_comp) != 3:\n            continue\n\n        # Border color is the most frequent value in the component\n        value_counts = {v: int(np.sum(grid[comp_mask] == v)) for v in values_in_comp}\n        border_color = max(value_counts, key=value_counts.get)\n        interior_colors = sorted(values_in_comp - {border_color})\n\n        # Find positions of each interior color\n        a_pos = np.argwhere(comp_mask & (grid == interior_colors[0]))\n        b_pos = np.argwhere(comp_mask & (grid == interior_colors[1]))\n\n        # Direction: from more frequent interior color to less frequent\n        if len(a_pos) >= len(b_pos):\n            centroid_more = a_pos.mean(axis=0)\n            centroid_fewer = b_pos.mean(axis=0)\n        else:\n            centroid_more = b_pos.mean(axis=0)\n            centroid_fewer = a_pos.mean(axis=0)\n\n        diff = centroid_fewer - centroid_more\n        direction = (int(np.sign(diff[0])), int(np.sign(diff[1])))\n        templates[border_color] = direction\n\n    # Step 2: For each 4, flood-fill to find enclosing border color, then move in template direction\n    result = grid.copy()\n    four_positions = list(zip(*np.where(grid == 4)))\n\n    for r, c in four_positions:\n        visited = set()\n        border_color_counts = {}\n        stack = [(int(r), int(c))]\n\n        while stack:\n            cr, cc = stack.pop()\n            if (cr, cc) in visited or cr < 0 or cr >= rows or cc < 0 or cc >= cols:\n                continue\n            val = grid[cr, cc]\n            if val != 0 and val != 4:\n                border_color_counts[val] = border_color_counts.get(val, 0) + 1\n                continue\n            visited.add((cr, cc))\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                stack.append((cr + dr, cc + dc))\n\n        if not border_color_counts:\n            continue\n\n        border_color = max(border_color_counts, key=border_color_counts.get)\n        if border_color not in templates:\n            continue\n\n        dr, dc = templates[border_color]\n\n        # Move the 4 until hitting a wall\n        nr, nc = int(r) + dr, int(c) + dc\n        while 0 <= nr < rows and 0 <= nc < cols and (grid[nr, nc] == 0 or grid[nr, nc] == 4):\n            nr += dr\n            nc += dc\n        nr -= dr\n        nc -= dc\n\n        result[int(r), int(c)] = 0\n        result[nr, nc] = 4\n\n    return result.tolist()\n"}, {"success": true, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 5, 1, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 5, 1, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2, 5, 2, 5], [0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 5, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 5, 5, 5, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 5, 0, 5, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 4, 5, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform by moving each 4-marker to the wall of its enclosing region in the direction \n    specified by the corresponding template pattern.\n\n    Templates are small bordered rectangles containing two non-border colors. The direction \n    is from the centroid of the more frequent interior color to the centroid of the less frequent one.\n    Each 4 moves in that direction (matched by its enclosing border color) until hitting a wall.\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Step 1: Find templates (connected components of non-zero, non-4 cells with 3 distinct values)\n    template_mask = (grid != 0) & (grid != 4)\n    labeled, num_features = label(template_mask)\n\n    templates = {}  # border_color -> direction (dr, dc)\n\n    for comp_id in range(1, num_features + 1):\n        comp_mask = labeled == comp_id\n        values_in_comp = set(grid[comp_mask].tolist()) - {0, 4}\n\n        if len(values_in_comp) != 3:\n            continue\n\n        # Border color is the most frequent value in the component\n        value_counts = {v: int(np.sum(grid[comp_mask] == v)) for v in values_in_comp}\n        border_color = max(value_counts, key=value_counts.get)\n        interior_colors = sorted(values_in_comp - {border_color})\n\n        # Find positions of each interior color\n        a_pos = np.argwhere(comp_mask & (grid == interior_colors[0]))\n        b_pos = np.argwhere(comp_mask & (grid == interior_colors[1]))\n\n        # Direction: from more frequent interior color to less frequent\n        if len(a_pos) >= len(b_pos):\n            centroid_more = a_pos.mean(axis=0)\n            centroid_fewer = b_pos.mean(axis=0)\n        else:\n            centroid_more = b_pos.mean(axis=0)\n            centroid_fewer = a_pos.mean(axis=0)\n\n        diff = centroid_fewer - centroid_more\n        direction = (int(np.sign(diff[0])), int(np.sign(diff[1])))\n        templates[border_color] = direction\n\n    # Step 2: For each 4, flood-fill to find enclosing border color, then move in template direction\n    result = grid.copy()\n    four_positions = list(zip(*np.where(grid == 4)))\n\n    for r, c in four_positions:\n        visited = set()\n        border_color_counts = {}\n        stack = [(int(r), int(c))]\n\n        while stack:\n            cr, cc = stack.pop()\n            if (cr, cc) in visited or cr < 0 or cr >= rows or cc < 0 or cc >= cols:\n                continue\n            val = grid[cr, cc]\n            if val != 0 and val != 4:\n                border_color_counts[val] = border_color_counts.get(val, 0) + 1\n                continue\n            visited.add((cr, cc))\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                stack.append((cr + dr, cc + dc))\n\n        if not border_color_counts:\n            continue\n\n        border_color = max(border_color_counts, key=border_color_counts.get)\n        if border_color not in templates:\n            continue\n\n        dr, dc = templates[border_color]\n\n        # Move the 4 until hitting a wall\n        nr, nc = int(r) + dr, int(c) + dc\n        while 0 <= nr < rows and 0 <= nc < cols and (grid[nr, nc] == 0 or grid[nr, nc] == 4):\n            nr += dr\n            nc += dc\n        nr -= dr\n        nc -= dc\n\n        result[int(r), int(c)] = 0\n        result[nr, nc] = 4\n\n    return result.tolist()\n"}], "test_results": [{"success": false, "output": "[[5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 1, 5, 5, 5, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 1, 5, 5, 1, 5, 5, 0, 0, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0], [5, 5, 1, 5, 5, 2, 5, 0, 0, 5, 0, 0, 0, 5, 0, 0, 5, 5, 0, 0], [5, 5, 5, 2, 5, 5, 5, 0, 0, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0], [5, 5, 5, 5, 5, 5, 5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 0, 0, 0, 0, 0, 4, 0, 5, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 5, 5, 5, 0, 4, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 4, 1, 1, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 2, 1, 2, 1, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 1, 0], [1, 5, 1, 5, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 5, 1, 5, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 0.0, "error": null, "code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform by moving each 4-marker to the wall of its enclosing region in the direction \n    specified by the corresponding template pattern.\n\n    Templates are small bordered rectangles containing two non-border colors. The direction \n    is from the centroid of the more frequent interior color to the centroid of the less frequent one.\n    Each 4 moves in that direction (matched by its enclosing border color) until hitting a wall.\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Step 1: Find templates (connected components of non-zero, non-4 cells with 3 distinct values)\n    template_mask = (grid != 0) & (grid != 4)\n    labeled, num_features = label(template_mask)\n\n    templates = {}  # border_color -> direction (dr, dc)\n\n    for comp_id in range(1, num_features + 1):\n        comp_mask = labeled == comp_id\n        values_in_comp = set(grid[comp_mask].tolist()) - {0, 4}\n\n        if len(values_in_comp) != 3:\n            continue\n\n        # Border color is the most frequent value in the component\n        value_counts = {v: int(np.sum(grid[comp_mask] == v)) for v in values_in_comp}\n        border_color = max(value_counts, key=value_counts.get)\n        interior_colors = sorted(values_in_comp - {border_color})\n\n        # Find positions of each interior color\n        a_pos = np.argwhere(comp_mask & (grid == interior_colors[0]))\n        b_pos = np.argwhere(comp_mask & (grid == interior_colors[1]))\n\n        # Direction: from more frequent interior color to less frequent\n        if len(a_pos) >= len(b_pos):\n            centroid_more = a_pos.mean(axis=0)\n            centroid_fewer = b_pos.mean(axis=0)\n        else:\n            centroid_more = b_pos.mean(axis=0)\n            centroid_fewer = a_pos.mean(axis=0)\n\n        diff = centroid_fewer - centroid_more\n        direction = (int(np.sign(diff[0])), int(np.sign(diff[1])))\n        templates[border_color] = direction\n\n    # Step 2: For each 4, flood-fill to find enclosing border color, then move in template direction\n    result = grid.copy()\n    four_positions = list(zip(*np.where(grid == 4)))\n\n    for r, c in four_positions:\n        visited = set()\n        border_color_counts = {}\n        stack = [(int(r), int(c))]\n\n        while stack:\n            cr, cc = stack.pop()\n            if (cr, cc) in visited or cr < 0 or cr >= rows or cc < 0 or cc >= cols:\n                continue\n            val = grid[cr, cc]\n            if val != 0 and val != 4:\n                border_color_counts[val] = border_color_counts.get(val, 0) + 1\n                continue\n            visited.add((cr, cc))\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                stack.append((cr + dr, cc + dc))\n\n        if not border_color_counts:\n            continue\n\n        border_color = max(border_color_counts, key=border_color_counts.get)\n        if border_color not in templates:\n            continue\n\n        dr, dc = templates[border_color]\n\n        # Move the 4 until hitting a wall\n        nr, nc = int(r) + dr, int(c) + dc\n        while 0 <= nr < rows and 0 <= nc < cols and (grid[nr, nc] == 0 or grid[nr, nc] == 4):\n            nr += dr\n            nc += dc\n        nr -= dr\n        nc -= dc\n\n        result[int(r), int(c)] = 0\n        result[nr, nc] = 4\n\n    return result.tolist()\n"}, {"success": false, "output": "[[6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 2, 6, 2, 6, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 6, 6, 6, 6], [6, 1, 6, 1, 6, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 6, 0, 4, 6], [6, 1, 6, 1, 6, 0, 3, 3, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 0, 6], [6, 6, 6, 6, 6, 0, 3, 4, 0, 0, 0, 0, 3, 3, 6, 0, 4, 0, 0, 6], [0, 0, 0, 0, 0, 0, 3, 4, 0, 0, 0, 0, 3, 0, 6, 0, 0, 0, 0, 6], [0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 3, 3, 6, 6, 6, 0, 0, 6], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 6, 0, 0, 6], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 6, 0, 0, 6], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 6, 6, 0, 6], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 4, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3], [0, 0, 3, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 3, 3, 3, 2, 3, 3, 3], [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 2, 3, 3, 1, 3, 3], [0, 0, 3, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 3, 1, 3, 3, 1, 3], [0, 0, 0, 3, 3, 3, 0, 0, 3, 3, 0, 0, 0, 3, 3, 3, 1, 3, 3, 3], [0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3]]", "soft_score": 0.0, "error": null, "code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform by moving each 4-marker to the wall of its enclosing region in the direction \n    specified by the corresponding template pattern.\n\n    Templates are small bordered rectangles containing two non-border colors. The direction \n    is from the centroid of the more frequent interior color to the centroid of the less frequent one.\n    Each 4 moves in that direction (matched by its enclosing border color) until hitting a wall.\n    \"\"\"\n    import numpy as np\n    from scipy.ndimage import label\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Step 1: Find templates (connected components of non-zero, non-4 cells with 3 distinct values)\n    template_mask = (grid != 0) & (grid != 4)\n    labeled, num_features = label(template_mask)\n\n    templates = {}  # border_color -> direction (dr, dc)\n\n    for comp_id in range(1, num_features + 1):\n        comp_mask = labeled == comp_id\n        values_in_comp = set(grid[comp_mask].tolist()) - {0, 4}\n\n        if len(values_in_comp) != 3:\n            continue\n\n        # Border color is the most frequent value in the component\n        value_counts = {v: int(np.sum(grid[comp_mask] == v)) for v in values_in_comp}\n        border_color = max(value_counts, key=value_counts.get)\n        interior_colors = sorted(values_in_comp - {border_color})\n\n        # Find positions of each interior color\n        a_pos = np.argwhere(comp_mask & (grid == interior_colors[0]))\n        b_pos = np.argwhere(comp_mask & (grid == interior_colors[1]))\n\n        # Direction: from more frequent interior color to less frequent\n        if len(a_pos) >= len(b_pos):\n            centroid_more = a_pos.mean(axis=0)\n            centroid_fewer = b_pos.mean(axis=0)\n        else:\n            centroid_more = b_pos.mean(axis=0)\n            centroid_fewer = a_pos.mean(axis=0)\n\n        diff = centroid_fewer - centroid_more\n        direction = (int(np.sign(diff[0])), int(np.sign(diff[1])))\n        templates[border_color] = direction\n\n    # Step 2: For each 4, flood-fill to find enclosing border color, then move in template direction\n    result = grid.copy()\n    four_positions = list(zip(*np.where(grid == 4)))\n\n    for r, c in four_positions:\n        visited = set()\n        border_color_counts = {}\n        stack = [(int(r), int(c))]\n\n        while stack:\n            cr, cc = stack.pop()\n            if (cr, cc) in visited or cr < 0 or cr >= rows or cc < 0 or cc >= cols:\n                continue\n            val = grid[cr, cc]\n            if val != 0 and val != 4:\n                border_color_counts[val] = border_color_counts.get(val, 0) + 1\n                continue\n            visited.add((cr, cc))\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                stack.append((cr + dr, cc + dc))\n\n        if not border_color_counts:\n            continue\n\n        border_color = max(border_color_counts, key=border_color_counts.get)\n        if border_color not in templates:\n            continue\n\n        dr, dc = templates[border_color]\n\n        # Move the 4 until hitting a wall\n        nr, nc = int(r) + dr, int(c) + dc\n        while 0 <= nr < rows and 0 <= nc < cols and (grid[nr, nc] == 0 or grid[nr, nc] == 4):\n            nr += dr\n            nc += dc\n        nr -= dr\n        nc -= dc\n\n        result[int(r), int(c)] = 0\n        result[nr, nc] = 4\n\n    return result.tolist()\n"}], "agent_usage": [{"input_tokens": 488995, "input_tokens_details": {"cached_tokens": 427059}, "output_tokens": 44206, "output_tokens_details": {"reasoning_tokens": -12}, "total_tokens": 44220, "inference_count": 12, "cache_creation": {"ephemeral_1h_input_tokens": 61922, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 61922, "inference_geo": ["global"], "service_tier": ["standard"]}], "time_taken": 1325.5276198387146, "num_agents_used": 1, "model": "anthropic/claude-opus-4-6", "reasoning_effort": "high", "error": null, "problem_id": "88e364bc", "attempt_id": 1, "num": 0, "iteration": 12}