{"train_results": [{"success": true, "output": "[[7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5], [7, 1, 1, 2, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2, 1, 1, 5], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5], [7, 1, 1, 2, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2, 1, 1, 5], [7, 7, 7, 7, 7, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 4, 7, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 7, 7, 7, 0, 0, 5, 5, 5, 5, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 5, 5, 5, 0, 0, 5, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 7, 5, 5, 5, 5, 0, 0, 0, 0, 5, 0], [0, 7, 7, 0, 0, 0, 0, 0, 4, 7, 5, 0, 0, 0, 0, 0, 0, 5, 5, 0], [0, 0, 7, 7, 7, 7, 0, 0, 0, 7, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 5, 4, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [0, 5, 4, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 5, 0, 0, 0, 0, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 5, 5, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [0, 0, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform grid by sliding each 4-marker toward the wall in the direction\n    indicated by the matching template pattern.\n\n    Templates are rectangular bordered regions containing two non-border colors.\n    The more frequent interior color is the \"source\" and less frequent is the \"target\".\n    The direction from source centroid to target centroid gives the sliding direction.\n\n    Each 4 finds its nearest wall color via BFS, looks up the corresponding template\n    direction, and slides in that direction until hitting a wall.\n    \"\"\"\n    import numpy as np\n    from scipy import ndimage\n    from collections import deque\n\n    g = np.array(grid)\n    rows, cols = g.shape\n\n    # Step 1: Find templates - rectangular bordered regions with 2 interior colors\n    templates = {}  # border_color -> direction (dr, dc)\n\n    non_zero_colors = set(int(x) for x in np.unique(g)) - {0, 4}\n\n    for c in non_zero_colors:\n        mask = (g == c)\n        labeled, n = ndimage.label(mask)\n        for comp_id in range(1, n + 1):\n            comp = np.where(labeled == comp_id)\n            rmin, rmax = int(comp[0].min()), int(comp[0].max())\n            cmin, cmax = int(comp[1].min()), int(comp[1].max())\n\n            subgrid = g[rmin:rmax+1, cmin:cmax+1]\n            if subgrid.shape[0] < 3 or subgrid.shape[1] < 3:\n                continue\n\n            # Check if border is all color c\n            border_cells = np.concatenate([\n                subgrid[0,:], subgrid[-1,:], subgrid[1:-1,0], subgrid[1:-1,-1]\n            ])\n            if not np.all(border_cells == c):\n                continue\n\n            interior = subgrid[1:-1, 1:-1]\n            interior_colors = sorted(set(int(x) for x in np.unique(interior)) - {c})\n\n            if len(interior_colors) != 2:\n                continue\n\n            # Found a template - compute direction\n            c1, c2 = interior_colors\n            count1 = int(np.sum(interior == c1))\n            count2 = int(np.sum(interior == c2))\n\n            if count1 >= count2:\n                source_color, target_color = c1, c2\n            else:\n                source_color, target_color = c2, c1\n\n            source_pos = np.array(np.where(interior == source_color))\n            target_pos = np.array(np.where(interior == target_color))\n\n            source_centroid = source_pos.mean(axis=1)\n            target_centroid = target_pos.mean(axis=1)\n\n            direction = target_centroid - source_centroid\n            dr = int(np.sign(direction[0])) if abs(direction[0]) > 0.01 else 0\n            dc = int(np.sign(direction[1])) if abs(direction[1]) > 0.01 else 0\n\n            templates[c] = (dr, dc)\n\n    # Step 2: For each 4, find nearest wall color and slide in template direction\n    result = g.copy()\n    four_positions = list(zip(*np.where(g == 4)))\n\n    for fr, fc in four_positions:\n        fr, fc = int(fr), int(fc)\n\n        # BFS to find nearest non-zero, non-4 cell\n        visited = set()\n        queue = deque([(fr, fc, 0)])\n        visited.add((fr, fc))\n        nearest_color = None\n\n        while queue:\n            r, c, dist = queue.popleft()\n            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    val = int(g[nr, nc])\n                    if val != 0 and val != 4:\n                        nearest_color = val\n                        break\n                    else:\n                        queue.append((nr, nc, dist + 1))\n            if nearest_color is not None:\n                break\n\n        if nearest_color is None or nearest_color not in templates:\n            continue\n\n        direction = templates[nearest_color]\n        dr, dc = direction\n\n        # Remove 4 from original position\n        result[fr, fc] = 0\n\n        # Slide in direction until hitting a wall\n        r, c = fr, fc\n        while True:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and (g[nr, nc] == 0 or g[nr, nc] == 4):\n                r, c = nr, nc\n            else:\n                break\n\n        result[r, c] = 4\n\n    return result.tolist()\n"}, {"success": true, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 1, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 5, 5, 1, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 1, 5, 5, 2, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 2, 5, 5, 5], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 5, 5, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 4, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 5, 5, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 5, 5, 0, 5, 5, 5, 0, 5, 0, 0, 0, 4, 5, 5, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 5, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform grid by sliding each 4-marker toward the wall in the direction\n    indicated by the matching template pattern.\n\n    Templates are rectangular bordered regions containing two non-border colors.\n    The more frequent interior color is the \"source\" and less frequent is the \"target\".\n    The direction from source centroid to target centroid gives the sliding direction.\n\n    Each 4 finds its nearest wall color via BFS, looks up the corresponding template\n    direction, and slides in that direction until hitting a wall.\n    \"\"\"\n    import numpy as np\n    from scipy import ndimage\n    from collections import deque\n\n    g = np.array(grid)\n    rows, cols = g.shape\n\n    # Step 1: Find templates - rectangular bordered regions with 2 interior colors\n    templates = {}  # border_color -> direction (dr, dc)\n\n    non_zero_colors = set(int(x) for x in np.unique(g)) - {0, 4}\n\n    for c in non_zero_colors:\n        mask = (g == c)\n        labeled, n = ndimage.label(mask)\n        for comp_id in range(1, n + 1):\n            comp = np.where(labeled == comp_id)\n            rmin, rmax = int(comp[0].min()), int(comp[0].max())\n            cmin, cmax = int(comp[1].min()), int(comp[1].max())\n\n            subgrid = g[rmin:rmax+1, cmin:cmax+1]\n            if subgrid.shape[0] < 3 or subgrid.shape[1] < 3:\n                continue\n\n            # Check if border is all color c\n            border_cells = np.concatenate([\n                subgrid[0,:], subgrid[-1,:], subgrid[1:-1,0], subgrid[1:-1,-1]\n            ])\n            if not np.all(border_cells == c):\n                continue\n\n            interior = subgrid[1:-1, 1:-1]\n            interior_colors = sorted(set(int(x) for x in np.unique(interior)) - {c})\n\n            if len(interior_colors) != 2:\n                continue\n\n            # Found a template - compute direction\n            c1, c2 = interior_colors\n            count1 = int(np.sum(interior == c1))\n            count2 = int(np.sum(interior == c2))\n\n            if count1 >= count2:\n                source_color, target_color = c1, c2\n            else:\n                source_color, target_color = c2, c1\n\n            source_pos = np.array(np.where(interior == source_color))\n            target_pos = np.array(np.where(interior == target_color))\n\n            source_centroid = source_pos.mean(axis=1)\n            target_centroid = target_pos.mean(axis=1)\n\n            direction = target_centroid - source_centroid\n            dr = int(np.sign(direction[0])) if abs(direction[0]) > 0.01 else 0\n            dc = int(np.sign(direction[1])) if abs(direction[1]) > 0.01 else 0\n\n            templates[c] = (dr, dc)\n\n    # Step 2: For each 4, find nearest wall color and slide in template direction\n    result = g.copy()\n    four_positions = list(zip(*np.where(g == 4)))\n\n    for fr, fc in four_positions:\n        fr, fc = int(fr), int(fc)\n\n        # BFS to find nearest non-zero, non-4 cell\n        visited = set()\n        queue = deque([(fr, fc, 0)])\n        visited.add((fr, fc))\n        nearest_color = None\n\n        while queue:\n            r, c, dist = queue.popleft()\n            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    val = int(g[nr, nc])\n                    if val != 0 and val != 4:\n                        nearest_color = val\n                        break\n                    else:\n                        queue.append((nr, nc, dist + 1))\n            if nearest_color is not None:\n                break\n\n        if nearest_color is None or nearest_color not in templates:\n            continue\n\n        direction = templates[nearest_color]\n        dr, dc = direction\n\n        # Remove 4 from original position\n        result[fr, fc] = 0\n\n        # Slide in direction until hitting a wall\n        r, c = fr, fc\n        while True:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and (g[nr, nc] == 0 or g[nr, nc] == 4):\n                r, c = nr, nc\n            else:\n                break\n\n        result[r, c] = 4\n\n    return result.tolist()\n"}, {"success": true, "output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 5, 1, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 5, 1, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2, 5, 2, 5], [0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 5, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 5, 5, 5, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 5, 0, 5, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 4, 5, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 1.0, "error": null, "code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform grid by sliding each 4-marker toward the wall in the direction\n    indicated by the matching template pattern.\n\n    Templates are rectangular bordered regions containing two non-border colors.\n    The more frequent interior color is the \"source\" and less frequent is the \"target\".\n    The direction from source centroid to target centroid gives the sliding direction.\n\n    Each 4 finds its nearest wall color via BFS, looks up the corresponding template\n    direction, and slides in that direction until hitting a wall.\n    \"\"\"\n    import numpy as np\n    from scipy import ndimage\n    from collections import deque\n\n    g = np.array(grid)\n    rows, cols = g.shape\n\n    # Step 1: Find templates - rectangular bordered regions with 2 interior colors\n    templates = {}  # border_color -> direction (dr, dc)\n\n    non_zero_colors = set(int(x) for x in np.unique(g)) - {0, 4}\n\n    for c in non_zero_colors:\n        mask = (g == c)\n        labeled, n = ndimage.label(mask)\n        for comp_id in range(1, n + 1):\n            comp = np.where(labeled == comp_id)\n            rmin, rmax = int(comp[0].min()), int(comp[0].max())\n            cmin, cmax = int(comp[1].min()), int(comp[1].max())\n\n            subgrid = g[rmin:rmax+1, cmin:cmax+1]\n            if subgrid.shape[0] < 3 or subgrid.shape[1] < 3:\n                continue\n\n            # Check if border is all color c\n            border_cells = np.concatenate([\n                subgrid[0,:], subgrid[-1,:], subgrid[1:-1,0], subgrid[1:-1,-1]\n            ])\n            if not np.all(border_cells == c):\n                continue\n\n            interior = subgrid[1:-1, 1:-1]\n            interior_colors = sorted(set(int(x) for x in np.unique(interior)) - {c})\n\n            if len(interior_colors) != 2:\n                continue\n\n            # Found a template - compute direction\n            c1, c2 = interior_colors\n            count1 = int(np.sum(interior == c1))\n            count2 = int(np.sum(interior == c2))\n\n            if count1 >= count2:\n                source_color, target_color = c1, c2\n            else:\n                source_color, target_color = c2, c1\n\n            source_pos = np.array(np.where(interior == source_color))\n            target_pos = np.array(np.where(interior == target_color))\n\n            source_centroid = source_pos.mean(axis=1)\n            target_centroid = target_pos.mean(axis=1)\n\n            direction = target_centroid - source_centroid\n            dr = int(np.sign(direction[0])) if abs(direction[0]) > 0.01 else 0\n            dc = int(np.sign(direction[1])) if abs(direction[1]) > 0.01 else 0\n\n            templates[c] = (dr, dc)\n\n    # Step 2: For each 4, find nearest wall color and slide in template direction\n    result = g.copy()\n    four_positions = list(zip(*np.where(g == 4)))\n\n    for fr, fc in four_positions:\n        fr, fc = int(fr), int(fc)\n\n        # BFS to find nearest non-zero, non-4 cell\n        visited = set()\n        queue = deque([(fr, fc, 0)])\n        visited.add((fr, fc))\n        nearest_color = None\n\n        while queue:\n            r, c, dist = queue.popleft()\n            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    val = int(g[nr, nc])\n                    if val != 0 and val != 4:\n                        nearest_color = val\n                        break\n                    else:\n                        queue.append((nr, nc, dist + 1))\n            if nearest_color is not None:\n                break\n\n        if nearest_color is None or nearest_color not in templates:\n            continue\n\n        direction = templates[nearest_color]\n        dr, dc = direction\n\n        # Remove 4 from original position\n        result[fr, fc] = 0\n\n        # Slide in direction until hitting a wall\n        r, c = fr, fc\n        while True:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and (g[nr, nc] == 0 or g[nr, nc] == 4):\n                r, c = nr, nc\n            else:\n                break\n\n        result[r, c] = 4\n\n    return result.tolist()\n"}], "test_results": [{"success": false, "output": "[[5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 1, 5, 5, 5, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [5, 1, 5, 5, 1, 5, 5, 0, 0, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0], [5, 5, 1, 5, 5, 2, 5, 0, 0, 5, 0, 0, 0, 5, 0, 0, 5, 5, 0, 0], [5, 5, 5, 2, 5, 5, 5, 0, 0, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0], [5, 5, 5, 5, 5, 5, 5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 0, 0, 0, 0, 0, 4, 0, 5, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 5, 5, 5, 0, 4, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 4, 1, 1, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 2, 1, 2, 1, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 1, 0], [1, 5, 1, 5, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 5, 1, 5, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 0.0, "error": null, "code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform grid by sliding each 4-marker toward the wall in the direction\n    indicated by the matching template pattern.\n\n    Templates are rectangular bordered regions containing two non-border colors.\n    The more frequent interior color is the \"source\" and less frequent is the \"target\".\n    The direction from source centroid to target centroid gives the sliding direction.\n\n    Each 4 finds its nearest wall color via BFS, looks up the corresponding template\n    direction, and slides in that direction until hitting a wall.\n    \"\"\"\n    import numpy as np\n    from scipy import ndimage\n    from collections import deque\n\n    g = np.array(grid)\n    rows, cols = g.shape\n\n    # Step 1: Find templates - rectangular bordered regions with 2 interior colors\n    templates = {}  # border_color -> direction (dr, dc)\n\n    non_zero_colors = set(int(x) for x in np.unique(g)) - {0, 4}\n\n    for c in non_zero_colors:\n        mask = (g == c)\n        labeled, n = ndimage.label(mask)\n        for comp_id in range(1, n + 1):\n            comp = np.where(labeled == comp_id)\n            rmin, rmax = int(comp[0].min()), int(comp[0].max())\n            cmin, cmax = int(comp[1].min()), int(comp[1].max())\n\n            subgrid = g[rmin:rmax+1, cmin:cmax+1]\n            if subgrid.shape[0] < 3 or subgrid.shape[1] < 3:\n                continue\n\n            # Check if border is all color c\n            border_cells = np.concatenate([\n                subgrid[0,:], subgrid[-1,:], subgrid[1:-1,0], subgrid[1:-1,-1]\n            ])\n            if not np.all(border_cells == c):\n                continue\n\n            interior = subgrid[1:-1, 1:-1]\n            interior_colors = sorted(set(int(x) for x in np.unique(interior)) - {c})\n\n            if len(interior_colors) != 2:\n                continue\n\n            # Found a template - compute direction\n            c1, c2 = interior_colors\n            count1 = int(np.sum(interior == c1))\n            count2 = int(np.sum(interior == c2))\n\n            if count1 >= count2:\n                source_color, target_color = c1, c2\n            else:\n                source_color, target_color = c2, c1\n\n            source_pos = np.array(np.where(interior == source_color))\n            target_pos = np.array(np.where(interior == target_color))\n\n            source_centroid = source_pos.mean(axis=1)\n            target_centroid = target_pos.mean(axis=1)\n\n            direction = target_centroid - source_centroid\n            dr = int(np.sign(direction[0])) if abs(direction[0]) > 0.01 else 0\n            dc = int(np.sign(direction[1])) if abs(direction[1]) > 0.01 else 0\n\n            templates[c] = (dr, dc)\n\n    # Step 2: For each 4, find nearest wall color and slide in template direction\n    result = g.copy()\n    four_positions = list(zip(*np.where(g == 4)))\n\n    for fr, fc in four_positions:\n        fr, fc = int(fr), int(fc)\n\n        # BFS to find nearest non-zero, non-4 cell\n        visited = set()\n        queue = deque([(fr, fc, 0)])\n        visited.add((fr, fc))\n        nearest_color = None\n\n        while queue:\n            r, c, dist = queue.popleft()\n            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    val = int(g[nr, nc])\n                    if val != 0 and val != 4:\n                        nearest_color = val\n                        break\n                    else:\n                        queue.append((nr, nc, dist + 1))\n            if nearest_color is not None:\n                break\n\n        if nearest_color is None or nearest_color not in templates:\n            continue\n\n        direction = templates[nearest_color]\n        dr, dc = direction\n\n        # Remove 4 from original position\n        result[fr, fc] = 0\n\n        # Slide in direction until hitting a wall\n        r, c = fr, fc\n        while True:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and (g[nr, nc] == 0 or g[nr, nc] == 4):\n                r, c = nr, nc\n            else:\n                break\n\n        result[r, c] = 4\n\n    return result.tolist()\n"}, {"success": false, "output": "[[6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 2, 6, 2, 6, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 6, 6, 6, 6], [6, 1, 6, 1, 6, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 6, 0, 4, 6], [6, 1, 6, 1, 6, 0, 3, 3, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 0, 6], [6, 6, 6, 6, 6, 0, 3, 4, 0, 0, 0, 0, 3, 3, 6, 0, 4, 0, 0, 6], [0, 0, 0, 0, 0, 0, 3, 4, 0, 0, 0, 0, 3, 0, 6, 0, 0, 0, 0, 6], [0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 3, 3, 6, 6, 6, 0, 0, 6], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 6, 0, 0, 6], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 6, 0, 0, 6], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 6, 6, 0, 6], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 4, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 3, 3, 3, 3, 3, 3], [0, 0, 3, 4, 0, 0, 0, 0, 0, 3, 3, 0, 0, 3, 3, 3, 2, 3, 3, 3], [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 2, 3, 3, 1, 3, 3], [0, 0, 3, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 3, 1, 3, 3, 1, 3], [0, 0, 0, 3, 3, 3, 0, 0, 3, 3, 0, 0, 0, 3, 3, 3, 1, 3, 3, 3], [0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3]]", "soft_score": 0.0, "error": null, "code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Transform grid by sliding each 4-marker toward the wall in the direction\n    indicated by the matching template pattern.\n\n    Templates are rectangular bordered regions containing two non-border colors.\n    The more frequent interior color is the \"source\" and less frequent is the \"target\".\n    The direction from source centroid to target centroid gives the sliding direction.\n\n    Each 4 finds its nearest wall color via BFS, looks up the corresponding template\n    direction, and slides in that direction until hitting a wall.\n    \"\"\"\n    import numpy as np\n    from scipy import ndimage\n    from collections import deque\n\n    g = np.array(grid)\n    rows, cols = g.shape\n\n    # Step 1: Find templates - rectangular bordered regions with 2 interior colors\n    templates = {}  # border_color -> direction (dr, dc)\n\n    non_zero_colors = set(int(x) for x in np.unique(g)) - {0, 4}\n\n    for c in non_zero_colors:\n        mask = (g == c)\n        labeled, n = ndimage.label(mask)\n        for comp_id in range(1, n + 1):\n            comp = np.where(labeled == comp_id)\n            rmin, rmax = int(comp[0].min()), int(comp[0].max())\n            cmin, cmax = int(comp[1].min()), int(comp[1].max())\n\n            subgrid = g[rmin:rmax+1, cmin:cmax+1]\n            if subgrid.shape[0] < 3 or subgrid.shape[1] < 3:\n                continue\n\n            # Check if border is all color c\n            border_cells = np.concatenate([\n                subgrid[0,:], subgrid[-1,:], subgrid[1:-1,0], subgrid[1:-1,-1]\n            ])\n            if not np.all(border_cells == c):\n                continue\n\n            interior = subgrid[1:-1, 1:-1]\n            interior_colors = sorted(set(int(x) for x in np.unique(interior)) - {c})\n\n            if len(interior_colors) != 2:\n                continue\n\n            # Found a template - compute direction\n            c1, c2 = interior_colors\n            count1 = int(np.sum(interior == c1))\n            count2 = int(np.sum(interior == c2))\n\n            if count1 >= count2:\n                source_color, target_color = c1, c2\n            else:\n                source_color, target_color = c2, c1\n\n            source_pos = np.array(np.where(interior == source_color))\n            target_pos = np.array(np.where(interior == target_color))\n\n            source_centroid = source_pos.mean(axis=1)\n            target_centroid = target_pos.mean(axis=1)\n\n            direction = target_centroid - source_centroid\n            dr = int(np.sign(direction[0])) if abs(direction[0]) > 0.01 else 0\n            dc = int(np.sign(direction[1])) if abs(direction[1]) > 0.01 else 0\n\n            templates[c] = (dr, dc)\n\n    # Step 2: For each 4, find nearest wall color and slide in template direction\n    result = g.copy()\n    four_positions = list(zip(*np.where(g == 4)))\n\n    for fr, fc in four_positions:\n        fr, fc = int(fr), int(fc)\n\n        # BFS to find nearest non-zero, non-4 cell\n        visited = set()\n        queue = deque([(fr, fc, 0)])\n        visited.add((fr, fc))\n        nearest_color = None\n\n        while queue:\n            r, c, dist = queue.popleft()\n            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    val = int(g[nr, nc])\n                    if val != 0 and val != 4:\n                        nearest_color = val\n                        break\n                    else:\n                        queue.append((nr, nc, dist + 1))\n            if nearest_color is not None:\n                break\n\n        if nearest_color is None or nearest_color not in templates:\n            continue\n\n        direction = templates[nearest_color]\n        dr, dc = direction\n\n        # Remove 4 from original position\n        result[fr, fc] = 0\n\n        # Slide in direction until hitting a wall\n        r, c = fr, fc\n        while True:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and (g[nr, nc] == 0 or g[nr, nc] == 4):\n                r, c = nr, nc\n            else:\n                break\n\n        result[r, c] = 4\n\n    return result.tolist()\n"}], "agent_usage": [{"input_tokens": 345195, "input_tokens_details": {"cached_tokens": 288622}, "output_tokens": 40802, "output_tokens_details": {"reasoning_tokens": -10}, "total_tokens": 40814, "inference_count": 10, "cache_creation": {"ephemeral_1h_input_tokens": 56561, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 56561, "inference_geo": ["global"], "service_tier": ["standard"]}], "time_taken": 832.0658187866211, "num_agents_used": 1, "model": "anthropic/claude-opus-4-6", "reasoning_effort": "high", "error": null, "problem_id": "88e364bc", "attempt_id": 0, "num": 0, "iteration": 10}