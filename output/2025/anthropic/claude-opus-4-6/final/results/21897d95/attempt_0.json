{"train_results": [{"success": true, "output": "[[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 3, 3, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 3, 3, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 3, 3, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 3, 3, 7, 7, 7], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 7, 7, 7]]", "soft_score": 1.0, "error": null, "code": "\ndef transform(grid_list):\n    \"\"\"Transform input grid using T-arrow color mapping and optional rotation.\n\n    The input grid contains:\n    1. Colored regions (possibly with staircase boundaries)\n    2. T-shaped arrows made of 1s (with optional payload color at bar center)\n    3. Optional L-shaped rotation indicator (5 cells)\n\n    The transformation:\n    1. Detect T-arrows and determine color flow direction\n    2. Fill arrow cells with source region color\n    3. Find connected color regions\n    4. Apply per-region color mapping based on arrows\n    5. Optionally rotate the grid based on L-shape indicator\n    \"\"\"\n    import numpy as np\n    from scipy import ndimage\n    from collections import Counter\n\n    grid = np.array(grid_list)\n    h, w = grid.shape\n\n    # === Find T-arrows ===\n    arrows = []\n    used_cells = set()\n    ones_mask = (grid == 1)\n    labeled, num_components = ndimage.label(ones_mask)\n\n    def classify_t(cells):\n        cells_set = set(cells)\n        rows = [r for r, c in cells]\n        cols = [c for r, c in cells]\n        min_r, max_r = min(rows), max(rows)\n        min_c, max_c = min(cols), max(cols)\n        bh, bw = max_r - min_r + 1, max_c - min_c + 1\n\n        if bh == 3 and bw == 2:\n            col_counts = Counter(c for r, c in cells)\n            bar_col = stem_col = None\n            for col, cnt in col_counts.items():\n                if cnt == 3: bar_col = col\n                elif cnt == 1: stem_col = col\n            if bar_col is None or stem_col is None: return None\n            stem_r = next(r for r, c in cells if c == stem_col)\n            if (stem_r, bar_col) not in cells_set: return None\n            direction = 'RIGHT' if stem_col > bar_col else 'LEFT'\n            return {'direction': direction, 'payload': None, 'stem': (stem_r, stem_col),\n                    'bar_center': (stem_r, bar_col), 'cells': list(cells)}\n        elif bh == 2 and bw == 3:\n            row_counts = Counter(r for r, c in cells)\n            bar_row = stem_row = None\n            for row, cnt in row_counts.items():\n                if cnt == 3: bar_row = row\n                elif cnt == 1: stem_row = row\n            if bar_row is None or stem_row is None: return None\n            stem_c = next(c for r, c in cells if r == stem_row)\n            if (bar_row, stem_c) not in cells_set: return None\n            direction = 'UP' if stem_row < bar_row else 'DOWN'\n            return {'direction': direction, 'payload': None, 'stem': (stem_row, stem_c),\n                    'bar_center': (bar_row, stem_c), 'cells': list(cells)}\n        return None\n\n    # Standard arrows (4 connected 1-cells)\n    for comp in range(1, num_components + 1):\n        cells = [tuple(int(x) for x in pos) for pos in np.argwhere(labeled == comp)]\n        if len(cells) == 4:\n            arrow = classify_t(cells)\n            if arrow:\n                arrows.append(arrow)\n                for c in cells: used_cells.add(c)\n\n    # Payload arrows (3 isolated 1-cells + 1 non-1 center)\n    one_positions = set(tuple(int(x) for x in pos) for pos in np.argwhere(ones_mask))\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] == 1 or (r, c) in used_cells: continue\n            # Vertical bar with payload at center\n            if r-1 >= 0 and r+1 < h and (r-1, c) in one_positions and (r+1, c) in one_positions:\n                if (r-1, c) not in used_cells and (r+1, c) not in used_cells:\n                    for dc in [1, -1]:\n                        nc = c + dc\n                        if 0 <= nc < w and (r, nc) in one_positions and (r, nc) not in used_cells:\n                            cells = [(r-1,c), (r,c), (r+1,c), (r,nc)]\n                            arrow = classify_t(cells)\n                            if arrow:\n                                arrow['payload'] = int(grid[r, c])\n                                arrows.append(arrow)\n                                for cell in cells: used_cells.add(cell)\n                                break\n            # Horizontal bar with payload at center\n            if c-1 >= 0 and c+1 < w and (r, c-1) in one_positions and (r, c+1) in one_positions:\n                if (r, c-1) not in used_cells and (r, c+1) not in used_cells:\n                    for dr in [-1, 1]:\n                        nr = r + dr\n                        if 0 <= nr < h and (nr, c) in one_positions and (nr, c) not in used_cells:\n                            cells = [(r,c-1), (r,c), (r,c+1), (nr,c)]\n                            arrow = classify_t(cells)\n                            if arrow:\n                                arrow['payload'] = int(grid[r, c])\n                                arrows.append(arrow)\n                                for cell in cells: used_cells.add(cell)\n                                break\n\n    # === Find L-shape rotation indicator ===\n    l_shape_dir = None\n    l_cells = set()\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    for color, count in zip(unique_colors, counts):\n        if color == 1 or count != 5: continue\n        cells = [tuple(int(x) for x in pos) for pos in np.argwhere(grid == int(color))]\n        if any(c in used_cells for c in cells): continue\n        row_counts = Counter(r for r, c in cells)\n        col_counts = Counter(c for r, c in cells)\n        found = False\n        for row, cnt in row_counts.items():\n            if cnt == 3:\n                bar = sorted([(r, c) for r, c in cells if r == row], key=lambda x: x[1])\n                bar_cols = [c for _, c in bar]\n                if bar_cols == list(range(bar_cols[0], bar_cols[0]+3)):\n                    ext = [(r, c) for r, c in cells if r != row]\n                    ext_cols = set(c for _, c in ext)\n                    if len(ext_cols) == 1:\n                        ec = ext_cols.pop()\n                        if ec == bar_cols[0]: l_shape_dir = 'LEFT'\n                        elif ec == bar_cols[2]: l_shape_dir = 'RIGHT'\n                        l_cells = set(cells)\n                        found = True\n                        break\n        if not found:\n            for col, cnt in col_counts.items():\n                if cnt == 3:\n                    bar = sorted([(r, c) for r, c in cells if c == col], key=lambda x: x[0])\n                    bar_rows = [r for r, _ in bar]\n                    if bar_rows == list(range(bar_rows[0], bar_rows[0]+3)):\n                        ext = [(r, c) for r, c in cells if c != col]\n                        ext_rows = set(r for r, _ in ext)\n                        if len(ext_rows) == 1:\n                            er = ext_rows.pop()\n                            if er == bar_rows[0]: l_shape_dir = 'TOP'\n                            elif er == bar_rows[2]: l_shape_dir = 'BOTTOM'\n                            l_cells = set(cells)\n                            found = True\n                            break\n        if found: break\n\n    # === Fill arrow cells with source color ===\n    filled = grid.copy()\n    all_arrow_cells = set()\n    for a in arrows:\n        for c in a['cells']:\n            all_arrow_cells.add(tuple(int(x) for x in c))\n\n    for a in arrows:\n        d = a['direction']\n        bar_r, bar_c = int(a['bar_center'][0]), int(a['bar_center'][1])\n        cells = [(int(r), int(c)) for r, c in a['cells']]\n\n        # Get bar endpoints (the two non-center cells of the bar)\n        if d in ('RIGHT', 'LEFT'):\n            bar_cells_list = [(r, c) for r, c in cells if c == bar_c]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n        else:\n            bar_cells_list = [(r, c) for r, c in cells if r == bar_r]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n\n        # Source = bar endpoints' neighbors in STEM direction\n        if d == 'RIGHT': src_nbrs = [(r, c+1) for r, c in bar_endpoints if c+1 < w]\n        elif d == 'LEFT': src_nbrs = [(r, c-1) for r, c in bar_endpoints if c-1 >= 0]\n        elif d == 'UP': src_nbrs = [(r-1, c) for r, c in bar_endpoints if r-1 >= 0]\n        elif d == 'DOWN': src_nbrs = [(r+1, c) for r, c in bar_endpoints if r+1 < h]\n\n        src_colors = [int(grid[r,c]) for r,c in src_nbrs \n                      if (r,c) not in all_arrow_cells and grid[r,c] != 1]\n\n        if src_colors:\n            for r, c in cells:\n                filled[r, c] = src_colors[0]\n\n    # Fill L-shape cells with surrounding color\n    for r, c in l_cells:\n        filled[r, c] = -1\n\n    for _ in range(max(h, w)):\n        changed = False\n        new_f = filled.copy()\n        for r in range(h):\n            for c in range(w):\n                if filled[r, c] == -1:\n                    neighbors = []\n                    for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n                        nr, nc = r+dr, c+dc\n                        if 0 <= nr < h and 0 <= nc < w and filled[nr, nc] != -1:\n                            neighbors.append(filled[nr, nc])\n                    if neighbors:\n                        new_f[r, c] = Counter(neighbors).most_common(1)[0][0]\n                        changed = True\n        filled = new_f\n        if not changed: break\n\n    # === Find connected components ===\n    region_map = np.zeros(filled.shape, dtype=int)\n    region_id = 0\n    region_colors = {}\n    for color in sorted(set(filled.flatten()) - {-1}):\n        mask = (filled == int(color))\n        lab, num = ndimage.label(mask)\n        for comp in range(1, num + 1):\n            region_id += 1\n            region_map[lab == comp] = region_id\n            region_colors[region_id] = int(color)\n\n    # === Determine per-region color mappings from arrows ===\n    region_new_color = {}\n    color_mapping_entries = {}\n\n    for a in arrows:\n        d = a['direction']\n        stem_r, stem_c = int(a['stem'][0]), int(a['stem'][1])\n        bar_r, bar_c = int(a['bar_center'][0]), int(a['bar_center'][1])\n        cells = [(int(r), int(c)) for r, c in a['cells']]\n\n        if d in ('RIGHT', 'LEFT'):\n            bar_cells_list = [(r, c) for r, c in cells if c == bar_c]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n        else:\n            bar_cells_list = [(r, c) for r, c in cells if r == bar_r]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n\n        if d == 'RIGHT': src_nbrs = [(r, c+1) for r, c in bar_endpoints if c+1 < w]\n        elif d == 'LEFT': src_nbrs = [(r, c-1) for r, c in bar_endpoints if c-1 >= 0]\n        elif d == 'UP': src_nbrs = [(r-1, c) for r, c in bar_endpoints if r-1 >= 0]\n        elif d == 'DOWN': src_nbrs = [(r+1, c) for r, c in bar_endpoints if r+1 < h]\n\n        src_colors = [int(grid[r,c]) for r,c in src_nbrs \n                      if (r,c) not in all_arrow_cells and grid[r,c] != 1]\n        src_color = src_colors[0] if src_colors else None\n\n        if d == 'RIGHT': tgt_pos = (stem_r, stem_c + 1)\n        elif d == 'LEFT': tgt_pos = (stem_r, stem_c - 1)\n        elif d == 'UP': tgt_pos = (stem_r - 1, stem_c)\n        elif d == 'DOWN': tgt_pos = (stem_r + 1, stem_c)\n\n        tr, tc = tgt_pos\n        if 0 <= tr < h and 0 <= tc < w:\n            tgt_rid = int(region_map[tr, tc])\n            tgt_color = region_colors.get(tgt_rid, -1)\n            new_color = a['payload'] if a['payload'] is not None else src_color\n\n            if new_color is not None:\n                region_new_color[tgt_rid] = new_color\n                if tgt_color not in color_mapping_entries:\n                    color_mapping_entries[tgt_color] = []\n                color_mapping_entries[tgt_color].append((new_color, tgt_rid))\n\n    # Apply per-region mappings\n    result = filled.copy()\n    for rid, new_c in region_new_color.items():\n        result[region_map == rid] = new_c\n\n    # For unmapped regions, use global color mapping (with proximity for conflicts)\n    for rid, old_c in region_colors.items():\n        if rid not in region_new_color and old_c in color_mapping_entries:\n            entries = color_mapping_entries[old_c]\n            if len(entries) == 1:\n                result[region_map == rid] = entries[0][0]\n            else:\n                rid_cells = np.argwhere(region_map == rid)\n                centroid = rid_cells.mean(axis=0)\n                best_dist = float('inf')\n                best_color = entries[0][0]\n                for new_c, tgt_rid in entries:\n                    tgt_cells = np.argwhere(region_map == tgt_rid)\n                    tgt_centroid = tgt_cells.mean(axis=0)\n                    dist = np.sqrt(((centroid - tgt_centroid)**2).sum())\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_color = new_c\n                result[region_map == rid] = best_color\n\n    # === Apply rotation ===\n    if l_shape_dir == 'RIGHT':\n        result = np.rot90(result, k=1)   # CCW\n    elif l_shape_dir == 'LEFT':\n        result = np.rot90(result, k=-1)  # CW\n\n    return result.tolist()\n"}, {"success": true, "output": "[[6, 6, 6, 6, 6, 6, 6, 6, 7, 7], [6, 6, 6, 6, 6, 6, 6, 6, 7, 7], [6, 6, 6, 6, 6, 6, 6, 6, 7, 7], [3, 3, 3, 8, 8, 6, 6, 6, 7, 7], [3, 3, 3, 8, 8, 6, 6, 6, 7, 7], [3, 3, 3, 8, 8, 6, 6, 6, 7, 7], [3, 3, 3, 8, 8, 6, 6, 6, 7, 7], [3, 3, 3, 8, 8, 6, 6, 6, 7, 7], [3, 3, 3, 8, 8, 9, 9, 9, 7, 7], [3, 3, 3, 8, 8, 9, 9, 9, 7, 7]]", "soft_score": 1.0, "error": null, "code": "\ndef transform(grid_list):\n    \"\"\"Transform input grid using T-arrow color mapping and optional rotation.\n\n    The input grid contains:\n    1. Colored regions (possibly with staircase boundaries)\n    2. T-shaped arrows made of 1s (with optional payload color at bar center)\n    3. Optional L-shaped rotation indicator (5 cells)\n\n    The transformation:\n    1. Detect T-arrows and determine color flow direction\n    2. Fill arrow cells with source region color\n    3. Find connected color regions\n    4. Apply per-region color mapping based on arrows\n    5. Optionally rotate the grid based on L-shape indicator\n    \"\"\"\n    import numpy as np\n    from scipy import ndimage\n    from collections import Counter\n\n    grid = np.array(grid_list)\n    h, w = grid.shape\n\n    # === Find T-arrows ===\n    arrows = []\n    used_cells = set()\n    ones_mask = (grid == 1)\n    labeled, num_components = ndimage.label(ones_mask)\n\n    def classify_t(cells):\n        cells_set = set(cells)\n        rows = [r for r, c in cells]\n        cols = [c for r, c in cells]\n        min_r, max_r = min(rows), max(rows)\n        min_c, max_c = min(cols), max(cols)\n        bh, bw = max_r - min_r + 1, max_c - min_c + 1\n\n        if bh == 3 and bw == 2:\n            col_counts = Counter(c for r, c in cells)\n            bar_col = stem_col = None\n            for col, cnt in col_counts.items():\n                if cnt == 3: bar_col = col\n                elif cnt == 1: stem_col = col\n            if bar_col is None or stem_col is None: return None\n            stem_r = next(r for r, c in cells if c == stem_col)\n            if (stem_r, bar_col) not in cells_set: return None\n            direction = 'RIGHT' if stem_col > bar_col else 'LEFT'\n            return {'direction': direction, 'payload': None, 'stem': (stem_r, stem_col),\n                    'bar_center': (stem_r, bar_col), 'cells': list(cells)}\n        elif bh == 2 and bw == 3:\n            row_counts = Counter(r for r, c in cells)\n            bar_row = stem_row = None\n            for row, cnt in row_counts.items():\n                if cnt == 3: bar_row = row\n                elif cnt == 1: stem_row = row\n            if bar_row is None or stem_row is None: return None\n            stem_c = next(c for r, c in cells if r == stem_row)\n            if (bar_row, stem_c) not in cells_set: return None\n            direction = 'UP' if stem_row < bar_row else 'DOWN'\n            return {'direction': direction, 'payload': None, 'stem': (stem_row, stem_c),\n                    'bar_center': (bar_row, stem_c), 'cells': list(cells)}\n        return None\n\n    # Standard arrows (4 connected 1-cells)\n    for comp in range(1, num_components + 1):\n        cells = [tuple(int(x) for x in pos) for pos in np.argwhere(labeled == comp)]\n        if len(cells) == 4:\n            arrow = classify_t(cells)\n            if arrow:\n                arrows.append(arrow)\n                for c in cells: used_cells.add(c)\n\n    # Payload arrows (3 isolated 1-cells + 1 non-1 center)\n    one_positions = set(tuple(int(x) for x in pos) for pos in np.argwhere(ones_mask))\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] == 1 or (r, c) in used_cells: continue\n            # Vertical bar with payload at center\n            if r-1 >= 0 and r+1 < h and (r-1, c) in one_positions and (r+1, c) in one_positions:\n                if (r-1, c) not in used_cells and (r+1, c) not in used_cells:\n                    for dc in [1, -1]:\n                        nc = c + dc\n                        if 0 <= nc < w and (r, nc) in one_positions and (r, nc) not in used_cells:\n                            cells = [(r-1,c), (r,c), (r+1,c), (r,nc)]\n                            arrow = classify_t(cells)\n                            if arrow:\n                                arrow['payload'] = int(grid[r, c])\n                                arrows.append(arrow)\n                                for cell in cells: used_cells.add(cell)\n                                break\n            # Horizontal bar with payload at center\n            if c-1 >= 0 and c+1 < w and (r, c-1) in one_positions and (r, c+1) in one_positions:\n                if (r, c-1) not in used_cells and (r, c+1) not in used_cells:\n                    for dr in [-1, 1]:\n                        nr = r + dr\n                        if 0 <= nr < h and (nr, c) in one_positions and (nr, c) not in used_cells:\n                            cells = [(r,c-1), (r,c), (r,c+1), (nr,c)]\n                            arrow = classify_t(cells)\n                            if arrow:\n                                arrow['payload'] = int(grid[r, c])\n                                arrows.append(arrow)\n                                for cell in cells: used_cells.add(cell)\n                                break\n\n    # === Find L-shape rotation indicator ===\n    l_shape_dir = None\n    l_cells = set()\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    for color, count in zip(unique_colors, counts):\n        if color == 1 or count != 5: continue\n        cells = [tuple(int(x) for x in pos) for pos in np.argwhere(grid == int(color))]\n        if any(c in used_cells for c in cells): continue\n        row_counts = Counter(r for r, c in cells)\n        col_counts = Counter(c for r, c in cells)\n        found = False\n        for row, cnt in row_counts.items():\n            if cnt == 3:\n                bar = sorted([(r, c) for r, c in cells if r == row], key=lambda x: x[1])\n                bar_cols = [c for _, c in bar]\n                if bar_cols == list(range(bar_cols[0], bar_cols[0]+3)):\n                    ext = [(r, c) for r, c in cells if r != row]\n                    ext_cols = set(c for _, c in ext)\n                    if len(ext_cols) == 1:\n                        ec = ext_cols.pop()\n                        if ec == bar_cols[0]: l_shape_dir = 'LEFT'\n                        elif ec == bar_cols[2]: l_shape_dir = 'RIGHT'\n                        l_cells = set(cells)\n                        found = True\n                        break\n        if not found:\n            for col, cnt in col_counts.items():\n                if cnt == 3:\n                    bar = sorted([(r, c) for r, c in cells if c == col], key=lambda x: x[0])\n                    bar_rows = [r for r, _ in bar]\n                    if bar_rows == list(range(bar_rows[0], bar_rows[0]+3)):\n                        ext = [(r, c) for r, c in cells if c != col]\n                        ext_rows = set(r for r, _ in ext)\n                        if len(ext_rows) == 1:\n                            er = ext_rows.pop()\n                            if er == bar_rows[0]: l_shape_dir = 'TOP'\n                            elif er == bar_rows[2]: l_shape_dir = 'BOTTOM'\n                            l_cells = set(cells)\n                            found = True\n                            break\n        if found: break\n\n    # === Fill arrow cells with source color ===\n    filled = grid.copy()\n    all_arrow_cells = set()\n    for a in arrows:\n        for c in a['cells']:\n            all_arrow_cells.add(tuple(int(x) for x in c))\n\n    for a in arrows:\n        d = a['direction']\n        bar_r, bar_c = int(a['bar_center'][0]), int(a['bar_center'][1])\n        cells = [(int(r), int(c)) for r, c in a['cells']]\n\n        # Get bar endpoints (the two non-center cells of the bar)\n        if d in ('RIGHT', 'LEFT'):\n            bar_cells_list = [(r, c) for r, c in cells if c == bar_c]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n        else:\n            bar_cells_list = [(r, c) for r, c in cells if r == bar_r]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n\n        # Source = bar endpoints' neighbors in STEM direction\n        if d == 'RIGHT': src_nbrs = [(r, c+1) for r, c in bar_endpoints if c+1 < w]\n        elif d == 'LEFT': src_nbrs = [(r, c-1) for r, c in bar_endpoints if c-1 >= 0]\n        elif d == 'UP': src_nbrs = [(r-1, c) for r, c in bar_endpoints if r-1 >= 0]\n        elif d == 'DOWN': src_nbrs = [(r+1, c) for r, c in bar_endpoints if r+1 < h]\n\n        src_colors = [int(grid[r,c]) for r,c in src_nbrs \n                      if (r,c) not in all_arrow_cells and grid[r,c] != 1]\n\n        if src_colors:\n            for r, c in cells:\n                filled[r, c] = src_colors[0]\n\n    # Fill L-shape cells with surrounding color\n    for r, c in l_cells:\n        filled[r, c] = -1\n\n    for _ in range(max(h, w)):\n        changed = False\n        new_f = filled.copy()\n        for r in range(h):\n            for c in range(w):\n                if filled[r, c] == -1:\n                    neighbors = []\n                    for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n                        nr, nc = r+dr, c+dc\n                        if 0 <= nr < h and 0 <= nc < w and filled[nr, nc] != -1:\n                            neighbors.append(filled[nr, nc])\n                    if neighbors:\n                        new_f[r, c] = Counter(neighbors).most_common(1)[0][0]\n                        changed = True\n        filled = new_f\n        if not changed: break\n\n    # === Find connected components ===\n    region_map = np.zeros(filled.shape, dtype=int)\n    region_id = 0\n    region_colors = {}\n    for color in sorted(set(filled.flatten()) - {-1}):\n        mask = (filled == int(color))\n        lab, num = ndimage.label(mask)\n        for comp in range(1, num + 1):\n            region_id += 1\n            region_map[lab == comp] = region_id\n            region_colors[region_id] = int(color)\n\n    # === Determine per-region color mappings from arrows ===\n    region_new_color = {}\n    color_mapping_entries = {}\n\n    for a in arrows:\n        d = a['direction']\n        stem_r, stem_c = int(a['stem'][0]), int(a['stem'][1])\n        bar_r, bar_c = int(a['bar_center'][0]), int(a['bar_center'][1])\n        cells = [(int(r), int(c)) for r, c in a['cells']]\n\n        if d in ('RIGHT', 'LEFT'):\n            bar_cells_list = [(r, c) for r, c in cells if c == bar_c]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n        else:\n            bar_cells_list = [(r, c) for r, c in cells if r == bar_r]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n\n        if d == 'RIGHT': src_nbrs = [(r, c+1) for r, c in bar_endpoints if c+1 < w]\n        elif d == 'LEFT': src_nbrs = [(r, c-1) for r, c in bar_endpoints if c-1 >= 0]\n        elif d == 'UP': src_nbrs = [(r-1, c) for r, c in bar_endpoints if r-1 >= 0]\n        elif d == 'DOWN': src_nbrs = [(r+1, c) for r, c in bar_endpoints if r+1 < h]\n\n        src_colors = [int(grid[r,c]) for r,c in src_nbrs \n                      if (r,c) not in all_arrow_cells and grid[r,c] != 1]\n        src_color = src_colors[0] if src_colors else None\n\n        if d == 'RIGHT': tgt_pos = (stem_r, stem_c + 1)\n        elif d == 'LEFT': tgt_pos = (stem_r, stem_c - 1)\n        elif d == 'UP': tgt_pos = (stem_r - 1, stem_c)\n        elif d == 'DOWN': tgt_pos = (stem_r + 1, stem_c)\n\n        tr, tc = tgt_pos\n        if 0 <= tr < h and 0 <= tc < w:\n            tgt_rid = int(region_map[tr, tc])\n            tgt_color = region_colors.get(tgt_rid, -1)\n            new_color = a['payload'] if a['payload'] is not None else src_color\n\n            if new_color is not None:\n                region_new_color[tgt_rid] = new_color\n                if tgt_color not in color_mapping_entries:\n                    color_mapping_entries[tgt_color] = []\n                color_mapping_entries[tgt_color].append((new_color, tgt_rid))\n\n    # Apply per-region mappings\n    result = filled.copy()\n    for rid, new_c in region_new_color.items():\n        result[region_map == rid] = new_c\n\n    # For unmapped regions, use global color mapping (with proximity for conflicts)\n    for rid, old_c in region_colors.items():\n        if rid not in region_new_color and old_c in color_mapping_entries:\n            entries = color_mapping_entries[old_c]\n            if len(entries) == 1:\n                result[region_map == rid] = entries[0][0]\n            else:\n                rid_cells = np.argwhere(region_map == rid)\n                centroid = rid_cells.mean(axis=0)\n                best_dist = float('inf')\n                best_color = entries[0][0]\n                for new_c, tgt_rid in entries:\n                    tgt_cells = np.argwhere(region_map == tgt_rid)\n                    tgt_centroid = tgt_cells.mean(axis=0)\n                    dist = np.sqrt(((centroid - tgt_centroid)**2).sum())\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_color = new_c\n                result[region_map == rid] = best_color\n\n    # === Apply rotation ===\n    if l_shape_dir == 'RIGHT':\n        result = np.rot90(result, k=1)   # CCW\n    elif l_shape_dir == 'LEFT':\n        result = np.rot90(result, k=-1)  # CW\n\n    return result.tolist()\n"}, {"success": true, "output": "[[5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3], [5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3], [5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3], [7, 8, 8, 8, 6, 3, 3, 3, 6, 6, 6, 4, 4, 4], [7, 8, 8, 8, 6, 3, 3, 3, 6, 6, 6, 4, 4, 4], [7, 8, 8, 8, 6, 3, 3, 3, 6, 6, 6, 4, 4, 4], [7, 8, 8, 8, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4], [7, 8, 8, 8, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4], [7, 8, 8, 8, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4]]", "soft_score": 1.0, "error": null, "code": "\ndef transform(grid_list):\n    \"\"\"Transform input grid using T-arrow color mapping and optional rotation.\n\n    The input grid contains:\n    1. Colored regions (possibly with staircase boundaries)\n    2. T-shaped arrows made of 1s (with optional payload color at bar center)\n    3. Optional L-shaped rotation indicator (5 cells)\n\n    The transformation:\n    1. Detect T-arrows and determine color flow direction\n    2. Fill arrow cells with source region color\n    3. Find connected color regions\n    4. Apply per-region color mapping based on arrows\n    5. Optionally rotate the grid based on L-shape indicator\n    \"\"\"\n    import numpy as np\n    from scipy import ndimage\n    from collections import Counter\n\n    grid = np.array(grid_list)\n    h, w = grid.shape\n\n    # === Find T-arrows ===\n    arrows = []\n    used_cells = set()\n    ones_mask = (grid == 1)\n    labeled, num_components = ndimage.label(ones_mask)\n\n    def classify_t(cells):\n        cells_set = set(cells)\n        rows = [r for r, c in cells]\n        cols = [c for r, c in cells]\n        min_r, max_r = min(rows), max(rows)\n        min_c, max_c = min(cols), max(cols)\n        bh, bw = max_r - min_r + 1, max_c - min_c + 1\n\n        if bh == 3 and bw == 2:\n            col_counts = Counter(c for r, c in cells)\n            bar_col = stem_col = None\n            for col, cnt in col_counts.items():\n                if cnt == 3: bar_col = col\n                elif cnt == 1: stem_col = col\n            if bar_col is None or stem_col is None: return None\n            stem_r = next(r for r, c in cells if c == stem_col)\n            if (stem_r, bar_col) not in cells_set: return None\n            direction = 'RIGHT' if stem_col > bar_col else 'LEFT'\n            return {'direction': direction, 'payload': None, 'stem': (stem_r, stem_col),\n                    'bar_center': (stem_r, bar_col), 'cells': list(cells)}\n        elif bh == 2 and bw == 3:\n            row_counts = Counter(r for r, c in cells)\n            bar_row = stem_row = None\n            for row, cnt in row_counts.items():\n                if cnt == 3: bar_row = row\n                elif cnt == 1: stem_row = row\n            if bar_row is None or stem_row is None: return None\n            stem_c = next(c for r, c in cells if r == stem_row)\n            if (bar_row, stem_c) not in cells_set: return None\n            direction = 'UP' if stem_row < bar_row else 'DOWN'\n            return {'direction': direction, 'payload': None, 'stem': (stem_row, stem_c),\n                    'bar_center': (bar_row, stem_c), 'cells': list(cells)}\n        return None\n\n    # Standard arrows (4 connected 1-cells)\n    for comp in range(1, num_components + 1):\n        cells = [tuple(int(x) for x in pos) for pos in np.argwhere(labeled == comp)]\n        if len(cells) == 4:\n            arrow = classify_t(cells)\n            if arrow:\n                arrows.append(arrow)\n                for c in cells: used_cells.add(c)\n\n    # Payload arrows (3 isolated 1-cells + 1 non-1 center)\n    one_positions = set(tuple(int(x) for x in pos) for pos in np.argwhere(ones_mask))\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] == 1 or (r, c) in used_cells: continue\n            # Vertical bar with payload at center\n            if r-1 >= 0 and r+1 < h and (r-1, c) in one_positions and (r+1, c) in one_positions:\n                if (r-1, c) not in used_cells and (r+1, c) not in used_cells:\n                    for dc in [1, -1]:\n                        nc = c + dc\n                        if 0 <= nc < w and (r, nc) in one_positions and (r, nc) not in used_cells:\n                            cells = [(r-1,c), (r,c), (r+1,c), (r,nc)]\n                            arrow = classify_t(cells)\n                            if arrow:\n                                arrow['payload'] = int(grid[r, c])\n                                arrows.append(arrow)\n                                for cell in cells: used_cells.add(cell)\n                                break\n            # Horizontal bar with payload at center\n            if c-1 >= 0 and c+1 < w and (r, c-1) in one_positions and (r, c+1) in one_positions:\n                if (r, c-1) not in used_cells and (r, c+1) not in used_cells:\n                    for dr in [-1, 1]:\n                        nr = r + dr\n                        if 0 <= nr < h and (nr, c) in one_positions and (nr, c) not in used_cells:\n                            cells = [(r,c-1), (r,c), (r,c+1), (nr,c)]\n                            arrow = classify_t(cells)\n                            if arrow:\n                                arrow['payload'] = int(grid[r, c])\n                                arrows.append(arrow)\n                                for cell in cells: used_cells.add(cell)\n                                break\n\n    # === Find L-shape rotation indicator ===\n    l_shape_dir = None\n    l_cells = set()\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    for color, count in zip(unique_colors, counts):\n        if color == 1 or count != 5: continue\n        cells = [tuple(int(x) for x in pos) for pos in np.argwhere(grid == int(color))]\n        if any(c in used_cells for c in cells): continue\n        row_counts = Counter(r for r, c in cells)\n        col_counts = Counter(c for r, c in cells)\n        found = False\n        for row, cnt in row_counts.items():\n            if cnt == 3:\n                bar = sorted([(r, c) for r, c in cells if r == row], key=lambda x: x[1])\n                bar_cols = [c for _, c in bar]\n                if bar_cols == list(range(bar_cols[0], bar_cols[0]+3)):\n                    ext = [(r, c) for r, c in cells if r != row]\n                    ext_cols = set(c for _, c in ext)\n                    if len(ext_cols) == 1:\n                        ec = ext_cols.pop()\n                        if ec == bar_cols[0]: l_shape_dir = 'LEFT'\n                        elif ec == bar_cols[2]: l_shape_dir = 'RIGHT'\n                        l_cells = set(cells)\n                        found = True\n                        break\n        if not found:\n            for col, cnt in col_counts.items():\n                if cnt == 3:\n                    bar = sorted([(r, c) for r, c in cells if c == col], key=lambda x: x[0])\n                    bar_rows = [r for r, _ in bar]\n                    if bar_rows == list(range(bar_rows[0], bar_rows[0]+3)):\n                        ext = [(r, c) for r, c in cells if c != col]\n                        ext_rows = set(r for r, _ in ext)\n                        if len(ext_rows) == 1:\n                            er = ext_rows.pop()\n                            if er == bar_rows[0]: l_shape_dir = 'TOP'\n                            elif er == bar_rows[2]: l_shape_dir = 'BOTTOM'\n                            l_cells = set(cells)\n                            found = True\n                            break\n        if found: break\n\n    # === Fill arrow cells with source color ===\n    filled = grid.copy()\n    all_arrow_cells = set()\n    for a in arrows:\n        for c in a['cells']:\n            all_arrow_cells.add(tuple(int(x) for x in c))\n\n    for a in arrows:\n        d = a['direction']\n        bar_r, bar_c = int(a['bar_center'][0]), int(a['bar_center'][1])\n        cells = [(int(r), int(c)) for r, c in a['cells']]\n\n        # Get bar endpoints (the two non-center cells of the bar)\n        if d in ('RIGHT', 'LEFT'):\n            bar_cells_list = [(r, c) for r, c in cells if c == bar_c]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n        else:\n            bar_cells_list = [(r, c) for r, c in cells if r == bar_r]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n\n        # Source = bar endpoints' neighbors in STEM direction\n        if d == 'RIGHT': src_nbrs = [(r, c+1) for r, c in bar_endpoints if c+1 < w]\n        elif d == 'LEFT': src_nbrs = [(r, c-1) for r, c in bar_endpoints if c-1 >= 0]\n        elif d == 'UP': src_nbrs = [(r-1, c) for r, c in bar_endpoints if r-1 >= 0]\n        elif d == 'DOWN': src_nbrs = [(r+1, c) for r, c in bar_endpoints if r+1 < h]\n\n        src_colors = [int(grid[r,c]) for r,c in src_nbrs \n                      if (r,c) not in all_arrow_cells and grid[r,c] != 1]\n\n        if src_colors:\n            for r, c in cells:\n                filled[r, c] = src_colors[0]\n\n    # Fill L-shape cells with surrounding color\n    for r, c in l_cells:\n        filled[r, c] = -1\n\n    for _ in range(max(h, w)):\n        changed = False\n        new_f = filled.copy()\n        for r in range(h):\n            for c in range(w):\n                if filled[r, c] == -1:\n                    neighbors = []\n                    for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n                        nr, nc = r+dr, c+dc\n                        if 0 <= nr < h and 0 <= nc < w and filled[nr, nc] != -1:\n                            neighbors.append(filled[nr, nc])\n                    if neighbors:\n                        new_f[r, c] = Counter(neighbors).most_common(1)[0][0]\n                        changed = True\n        filled = new_f\n        if not changed: break\n\n    # === Find connected components ===\n    region_map = np.zeros(filled.shape, dtype=int)\n    region_id = 0\n    region_colors = {}\n    for color in sorted(set(filled.flatten()) - {-1}):\n        mask = (filled == int(color))\n        lab, num = ndimage.label(mask)\n        for comp in range(1, num + 1):\n            region_id += 1\n            region_map[lab == comp] = region_id\n            region_colors[region_id] = int(color)\n\n    # === Determine per-region color mappings from arrows ===\n    region_new_color = {}\n    color_mapping_entries = {}\n\n    for a in arrows:\n        d = a['direction']\n        stem_r, stem_c = int(a['stem'][0]), int(a['stem'][1])\n        bar_r, bar_c = int(a['bar_center'][0]), int(a['bar_center'][1])\n        cells = [(int(r), int(c)) for r, c in a['cells']]\n\n        if d in ('RIGHT', 'LEFT'):\n            bar_cells_list = [(r, c) for r, c in cells if c == bar_c]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n        else:\n            bar_cells_list = [(r, c) for r, c in cells if r == bar_r]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n\n        if d == 'RIGHT': src_nbrs = [(r, c+1) for r, c in bar_endpoints if c+1 < w]\n        elif d == 'LEFT': src_nbrs = [(r, c-1) for r, c in bar_endpoints if c-1 >= 0]\n        elif d == 'UP': src_nbrs = [(r-1, c) for r, c in bar_endpoints if r-1 >= 0]\n        elif d == 'DOWN': src_nbrs = [(r+1, c) for r, c in bar_endpoints if r+1 < h]\n\n        src_colors = [int(grid[r,c]) for r,c in src_nbrs \n                      if (r,c) not in all_arrow_cells and grid[r,c] != 1]\n        src_color = src_colors[0] if src_colors else None\n\n        if d == 'RIGHT': tgt_pos = (stem_r, stem_c + 1)\n        elif d == 'LEFT': tgt_pos = (stem_r, stem_c - 1)\n        elif d == 'UP': tgt_pos = (stem_r - 1, stem_c)\n        elif d == 'DOWN': tgt_pos = (stem_r + 1, stem_c)\n\n        tr, tc = tgt_pos\n        if 0 <= tr < h and 0 <= tc < w:\n            tgt_rid = int(region_map[tr, tc])\n            tgt_color = region_colors.get(tgt_rid, -1)\n            new_color = a['payload'] if a['payload'] is not None else src_color\n\n            if new_color is not None:\n                region_new_color[tgt_rid] = new_color\n                if tgt_color not in color_mapping_entries:\n                    color_mapping_entries[tgt_color] = []\n                color_mapping_entries[tgt_color].append((new_color, tgt_rid))\n\n    # Apply per-region mappings\n    result = filled.copy()\n    for rid, new_c in region_new_color.items():\n        result[region_map == rid] = new_c\n\n    # For unmapped regions, use global color mapping (with proximity for conflicts)\n    for rid, old_c in region_colors.items():\n        if rid not in region_new_color and old_c in color_mapping_entries:\n            entries = color_mapping_entries[old_c]\n            if len(entries) == 1:\n                result[region_map == rid] = entries[0][0]\n            else:\n                rid_cells = np.argwhere(region_map == rid)\n                centroid = rid_cells.mean(axis=0)\n                best_dist = float('inf')\n                best_color = entries[0][0]\n                for new_c, tgt_rid in entries:\n                    tgt_cells = np.argwhere(region_map == tgt_rid)\n                    tgt_centroid = tgt_cells.mean(axis=0)\n                    dist = np.sqrt(((centroid - tgt_centroid)**2).sum())\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_color = new_c\n                result[region_map == rid] = best_color\n\n    # === Apply rotation ===\n    if l_shape_dir == 'RIGHT':\n        result = np.rot90(result, k=1)   # CCW\n    elif l_shape_dir == 'LEFT':\n        result = np.rot90(result, k=-1)  # CW\n\n    return result.tolist()\n"}, {"success": true, "output": "[[6, 6, 6, 6, 6, 6, 6, 2, 2, 2], [6, 6, 6, 6, 6, 6, 6, 2, 2, 2], [6, 6, 6, 6, 6, 6, 6, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 2, 2, 2], [6, 6, 6, 6, 6, 6, 6, 2, 2, 2], [6, 6, 6, 6, 6, 6, 6, 2, 2, 2], [6, 6, 6, 6, 6, 6, 6, 2, 2, 2]]", "soft_score": 1.0, "error": null, "code": "\ndef transform(grid_list):\n    \"\"\"Transform input grid using T-arrow color mapping and optional rotation.\n\n    The input grid contains:\n    1. Colored regions (possibly with staircase boundaries)\n    2. T-shaped arrows made of 1s (with optional payload color at bar center)\n    3. Optional L-shaped rotation indicator (5 cells)\n\n    The transformation:\n    1. Detect T-arrows and determine color flow direction\n    2. Fill arrow cells with source region color\n    3. Find connected color regions\n    4. Apply per-region color mapping based on arrows\n    5. Optionally rotate the grid based on L-shape indicator\n    \"\"\"\n    import numpy as np\n    from scipy import ndimage\n    from collections import Counter\n\n    grid = np.array(grid_list)\n    h, w = grid.shape\n\n    # === Find T-arrows ===\n    arrows = []\n    used_cells = set()\n    ones_mask = (grid == 1)\n    labeled, num_components = ndimage.label(ones_mask)\n\n    def classify_t(cells):\n        cells_set = set(cells)\n        rows = [r for r, c in cells]\n        cols = [c for r, c in cells]\n        min_r, max_r = min(rows), max(rows)\n        min_c, max_c = min(cols), max(cols)\n        bh, bw = max_r - min_r + 1, max_c - min_c + 1\n\n        if bh == 3 and bw == 2:\n            col_counts = Counter(c for r, c in cells)\n            bar_col = stem_col = None\n            for col, cnt in col_counts.items():\n                if cnt == 3: bar_col = col\n                elif cnt == 1: stem_col = col\n            if bar_col is None or stem_col is None: return None\n            stem_r = next(r for r, c in cells if c == stem_col)\n            if (stem_r, bar_col) not in cells_set: return None\n            direction = 'RIGHT' if stem_col > bar_col else 'LEFT'\n            return {'direction': direction, 'payload': None, 'stem': (stem_r, stem_col),\n                    'bar_center': (stem_r, bar_col), 'cells': list(cells)}\n        elif bh == 2 and bw == 3:\n            row_counts = Counter(r for r, c in cells)\n            bar_row = stem_row = None\n            for row, cnt in row_counts.items():\n                if cnt == 3: bar_row = row\n                elif cnt == 1: stem_row = row\n            if bar_row is None or stem_row is None: return None\n            stem_c = next(c for r, c in cells if r == stem_row)\n            if (bar_row, stem_c) not in cells_set: return None\n            direction = 'UP' if stem_row < bar_row else 'DOWN'\n            return {'direction': direction, 'payload': None, 'stem': (stem_row, stem_c),\n                    'bar_center': (bar_row, stem_c), 'cells': list(cells)}\n        return None\n\n    # Standard arrows (4 connected 1-cells)\n    for comp in range(1, num_components + 1):\n        cells = [tuple(int(x) for x in pos) for pos in np.argwhere(labeled == comp)]\n        if len(cells) == 4:\n            arrow = classify_t(cells)\n            if arrow:\n                arrows.append(arrow)\n                for c in cells: used_cells.add(c)\n\n    # Payload arrows (3 isolated 1-cells + 1 non-1 center)\n    one_positions = set(tuple(int(x) for x in pos) for pos in np.argwhere(ones_mask))\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] == 1 or (r, c) in used_cells: continue\n            # Vertical bar with payload at center\n            if r-1 >= 0 and r+1 < h and (r-1, c) in one_positions and (r+1, c) in one_positions:\n                if (r-1, c) not in used_cells and (r+1, c) not in used_cells:\n                    for dc in [1, -1]:\n                        nc = c + dc\n                        if 0 <= nc < w and (r, nc) in one_positions and (r, nc) not in used_cells:\n                            cells = [(r-1,c), (r,c), (r+1,c), (r,nc)]\n                            arrow = classify_t(cells)\n                            if arrow:\n                                arrow['payload'] = int(grid[r, c])\n                                arrows.append(arrow)\n                                for cell in cells: used_cells.add(cell)\n                                break\n            # Horizontal bar with payload at center\n            if c-1 >= 0 and c+1 < w and (r, c-1) in one_positions and (r, c+1) in one_positions:\n                if (r, c-1) not in used_cells and (r, c+1) not in used_cells:\n                    for dr in [-1, 1]:\n                        nr = r + dr\n                        if 0 <= nr < h and (nr, c) in one_positions and (nr, c) not in used_cells:\n                            cells = [(r,c-1), (r,c), (r,c+1), (nr,c)]\n                            arrow = classify_t(cells)\n                            if arrow:\n                                arrow['payload'] = int(grid[r, c])\n                                arrows.append(arrow)\n                                for cell in cells: used_cells.add(cell)\n                                break\n\n    # === Find L-shape rotation indicator ===\n    l_shape_dir = None\n    l_cells = set()\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    for color, count in zip(unique_colors, counts):\n        if color == 1 or count != 5: continue\n        cells = [tuple(int(x) for x in pos) for pos in np.argwhere(grid == int(color))]\n        if any(c in used_cells for c in cells): continue\n        row_counts = Counter(r for r, c in cells)\n        col_counts = Counter(c for r, c in cells)\n        found = False\n        for row, cnt in row_counts.items():\n            if cnt == 3:\n                bar = sorted([(r, c) for r, c in cells if r == row], key=lambda x: x[1])\n                bar_cols = [c for _, c in bar]\n                if bar_cols == list(range(bar_cols[0], bar_cols[0]+3)):\n                    ext = [(r, c) for r, c in cells if r != row]\n                    ext_cols = set(c for _, c in ext)\n                    if len(ext_cols) == 1:\n                        ec = ext_cols.pop()\n                        if ec == bar_cols[0]: l_shape_dir = 'LEFT'\n                        elif ec == bar_cols[2]: l_shape_dir = 'RIGHT'\n                        l_cells = set(cells)\n                        found = True\n                        break\n        if not found:\n            for col, cnt in col_counts.items():\n                if cnt == 3:\n                    bar = sorted([(r, c) for r, c in cells if c == col], key=lambda x: x[0])\n                    bar_rows = [r for r, _ in bar]\n                    if bar_rows == list(range(bar_rows[0], bar_rows[0]+3)):\n                        ext = [(r, c) for r, c in cells if c != col]\n                        ext_rows = set(r for r, _ in ext)\n                        if len(ext_rows) == 1:\n                            er = ext_rows.pop()\n                            if er == bar_rows[0]: l_shape_dir = 'TOP'\n                            elif er == bar_rows[2]: l_shape_dir = 'BOTTOM'\n                            l_cells = set(cells)\n                            found = True\n                            break\n        if found: break\n\n    # === Fill arrow cells with source color ===\n    filled = grid.copy()\n    all_arrow_cells = set()\n    for a in arrows:\n        for c in a['cells']:\n            all_arrow_cells.add(tuple(int(x) for x in c))\n\n    for a in arrows:\n        d = a['direction']\n        bar_r, bar_c = int(a['bar_center'][0]), int(a['bar_center'][1])\n        cells = [(int(r), int(c)) for r, c in a['cells']]\n\n        # Get bar endpoints (the two non-center cells of the bar)\n        if d in ('RIGHT', 'LEFT'):\n            bar_cells_list = [(r, c) for r, c in cells if c == bar_c]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n        else:\n            bar_cells_list = [(r, c) for r, c in cells if r == bar_r]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n\n        # Source = bar endpoints' neighbors in STEM direction\n        if d == 'RIGHT': src_nbrs = [(r, c+1) for r, c in bar_endpoints if c+1 < w]\n        elif d == 'LEFT': src_nbrs = [(r, c-1) for r, c in bar_endpoints if c-1 >= 0]\n        elif d == 'UP': src_nbrs = [(r-1, c) for r, c in bar_endpoints if r-1 >= 0]\n        elif d == 'DOWN': src_nbrs = [(r+1, c) for r, c in bar_endpoints if r+1 < h]\n\n        src_colors = [int(grid[r,c]) for r,c in src_nbrs \n                      if (r,c) not in all_arrow_cells and grid[r,c] != 1]\n\n        if src_colors:\n            for r, c in cells:\n                filled[r, c] = src_colors[0]\n\n    # Fill L-shape cells with surrounding color\n    for r, c in l_cells:\n        filled[r, c] = -1\n\n    for _ in range(max(h, w)):\n        changed = False\n        new_f = filled.copy()\n        for r in range(h):\n            for c in range(w):\n                if filled[r, c] == -1:\n                    neighbors = []\n                    for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n                        nr, nc = r+dr, c+dc\n                        if 0 <= nr < h and 0 <= nc < w and filled[nr, nc] != -1:\n                            neighbors.append(filled[nr, nc])\n                    if neighbors:\n                        new_f[r, c] = Counter(neighbors).most_common(1)[0][0]\n                        changed = True\n        filled = new_f\n        if not changed: break\n\n    # === Find connected components ===\n    region_map = np.zeros(filled.shape, dtype=int)\n    region_id = 0\n    region_colors = {}\n    for color in sorted(set(filled.flatten()) - {-1}):\n        mask = (filled == int(color))\n        lab, num = ndimage.label(mask)\n        for comp in range(1, num + 1):\n            region_id += 1\n            region_map[lab == comp] = region_id\n            region_colors[region_id] = int(color)\n\n    # === Determine per-region color mappings from arrows ===\n    region_new_color = {}\n    color_mapping_entries = {}\n\n    for a in arrows:\n        d = a['direction']\n        stem_r, stem_c = int(a['stem'][0]), int(a['stem'][1])\n        bar_r, bar_c = int(a['bar_center'][0]), int(a['bar_center'][1])\n        cells = [(int(r), int(c)) for r, c in a['cells']]\n\n        if d in ('RIGHT', 'LEFT'):\n            bar_cells_list = [(r, c) for r, c in cells if c == bar_c]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n        else:\n            bar_cells_list = [(r, c) for r, c in cells if r == bar_r]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n\n        if d == 'RIGHT': src_nbrs = [(r, c+1) for r, c in bar_endpoints if c+1 < w]\n        elif d == 'LEFT': src_nbrs = [(r, c-1) for r, c in bar_endpoints if c-1 >= 0]\n        elif d == 'UP': src_nbrs = [(r-1, c) for r, c in bar_endpoints if r-1 >= 0]\n        elif d == 'DOWN': src_nbrs = [(r+1, c) for r, c in bar_endpoints if r+1 < h]\n\n        src_colors = [int(grid[r,c]) for r,c in src_nbrs \n                      if (r,c) not in all_arrow_cells and grid[r,c] != 1]\n        src_color = src_colors[0] if src_colors else None\n\n        if d == 'RIGHT': tgt_pos = (stem_r, stem_c + 1)\n        elif d == 'LEFT': tgt_pos = (stem_r, stem_c - 1)\n        elif d == 'UP': tgt_pos = (stem_r - 1, stem_c)\n        elif d == 'DOWN': tgt_pos = (stem_r + 1, stem_c)\n\n        tr, tc = tgt_pos\n        if 0 <= tr < h and 0 <= tc < w:\n            tgt_rid = int(region_map[tr, tc])\n            tgt_color = region_colors.get(tgt_rid, -1)\n            new_color = a['payload'] if a['payload'] is not None else src_color\n\n            if new_color is not None:\n                region_new_color[tgt_rid] = new_color\n                if tgt_color not in color_mapping_entries:\n                    color_mapping_entries[tgt_color] = []\n                color_mapping_entries[tgt_color].append((new_color, tgt_rid))\n\n    # Apply per-region mappings\n    result = filled.copy()\n    for rid, new_c in region_new_color.items():\n        result[region_map == rid] = new_c\n\n    # For unmapped regions, use global color mapping (with proximity for conflicts)\n    for rid, old_c in region_colors.items():\n        if rid not in region_new_color and old_c in color_mapping_entries:\n            entries = color_mapping_entries[old_c]\n            if len(entries) == 1:\n                result[region_map == rid] = entries[0][0]\n            else:\n                rid_cells = np.argwhere(region_map == rid)\n                centroid = rid_cells.mean(axis=0)\n                best_dist = float('inf')\n                best_color = entries[0][0]\n                for new_c, tgt_rid in entries:\n                    tgt_cells = np.argwhere(region_map == tgt_rid)\n                    tgt_centroid = tgt_cells.mean(axis=0)\n                    dist = np.sqrt(((centroid - tgt_centroid)**2).sum())\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_color = new_c\n                result[region_map == rid] = best_color\n\n    # === Apply rotation ===\n    if l_shape_dir == 'RIGHT':\n        result = np.rot90(result, k=1)   # CCW\n    elif l_shape_dir == 'LEFT':\n        result = np.rot90(result, k=-1)  # CW\n\n    return result.tolist()\n"}], "test_results": [{"success": false, "output": "[[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 9, 9, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 9, 9, 9, 9, 3, 3], [3, 3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 9, 9, 9, 9, 3, 3], [3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 9, 9, 9, 9, 3, 3], [3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 8], [3, 8, 8, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3, 3, 8, 8], [3, 8, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 8, 8, 8], [3, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 8, 8, 8], [3, 8, 8, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 3, 3, 3, 3, 8, 8, 8, 8], [3, 8, 8, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 3, 3, 3, 3, 8, 8, 8, 8], [3, 8, 8, 2, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 3, 3, 8, 8, 8, 8], [3, 8, 8, 2, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 8, 8, 8, 8, 8], [0, 0, 0, 2, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 8, 8, 8, 8, 8], [0, 0, 0, 2, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 8, 8, 8, 8, 8], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 8, 8, 8, 8, 8], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 3, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 3, 0, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 3, 3, 0, 0, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 6, 6, 6, 6, 3, 3, 3, 3, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "soft_score": 0.0, "error": null, "code": "\ndef transform(grid_list):\n    \"\"\"Transform input grid using T-arrow color mapping and optional rotation.\n\n    The input grid contains:\n    1. Colored regions (possibly with staircase boundaries)\n    2. T-shaped arrows made of 1s (with optional payload color at bar center)\n    3. Optional L-shaped rotation indicator (5 cells)\n\n    The transformation:\n    1. Detect T-arrows and determine color flow direction\n    2. Fill arrow cells with source region color\n    3. Find connected color regions\n    4. Apply per-region color mapping based on arrows\n    5. Optionally rotate the grid based on L-shape indicator\n    \"\"\"\n    import numpy as np\n    from scipy import ndimage\n    from collections import Counter\n\n    grid = np.array(grid_list)\n    h, w = grid.shape\n\n    # === Find T-arrows ===\n    arrows = []\n    used_cells = set()\n    ones_mask = (grid == 1)\n    labeled, num_components = ndimage.label(ones_mask)\n\n    def classify_t(cells):\n        cells_set = set(cells)\n        rows = [r for r, c in cells]\n        cols = [c for r, c in cells]\n        min_r, max_r = min(rows), max(rows)\n        min_c, max_c = min(cols), max(cols)\n        bh, bw = max_r - min_r + 1, max_c - min_c + 1\n\n        if bh == 3 and bw == 2:\n            col_counts = Counter(c for r, c in cells)\n            bar_col = stem_col = None\n            for col, cnt in col_counts.items():\n                if cnt == 3: bar_col = col\n                elif cnt == 1: stem_col = col\n            if bar_col is None or stem_col is None: return None\n            stem_r = next(r for r, c in cells if c == stem_col)\n            if (stem_r, bar_col) not in cells_set: return None\n            direction = 'RIGHT' if stem_col > bar_col else 'LEFT'\n            return {'direction': direction, 'payload': None, 'stem': (stem_r, stem_col),\n                    'bar_center': (stem_r, bar_col), 'cells': list(cells)}\n        elif bh == 2 and bw == 3:\n            row_counts = Counter(r for r, c in cells)\n            bar_row = stem_row = None\n            for row, cnt in row_counts.items():\n                if cnt == 3: bar_row = row\n                elif cnt == 1: stem_row = row\n            if bar_row is None or stem_row is None: return None\n            stem_c = next(c for r, c in cells if r == stem_row)\n            if (bar_row, stem_c) not in cells_set: return None\n            direction = 'UP' if stem_row < bar_row else 'DOWN'\n            return {'direction': direction, 'payload': None, 'stem': (stem_row, stem_c),\n                    'bar_center': (bar_row, stem_c), 'cells': list(cells)}\n        return None\n\n    # Standard arrows (4 connected 1-cells)\n    for comp in range(1, num_components + 1):\n        cells = [tuple(int(x) for x in pos) for pos in np.argwhere(labeled == comp)]\n        if len(cells) == 4:\n            arrow = classify_t(cells)\n            if arrow:\n                arrows.append(arrow)\n                for c in cells: used_cells.add(c)\n\n    # Payload arrows (3 isolated 1-cells + 1 non-1 center)\n    one_positions = set(tuple(int(x) for x in pos) for pos in np.argwhere(ones_mask))\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] == 1 or (r, c) in used_cells: continue\n            # Vertical bar with payload at center\n            if r-1 >= 0 and r+1 < h and (r-1, c) in one_positions and (r+1, c) in one_positions:\n                if (r-1, c) not in used_cells and (r+1, c) not in used_cells:\n                    for dc in [1, -1]:\n                        nc = c + dc\n                        if 0 <= nc < w and (r, nc) in one_positions and (r, nc) not in used_cells:\n                            cells = [(r-1,c), (r,c), (r+1,c), (r,nc)]\n                            arrow = classify_t(cells)\n                            if arrow:\n                                arrow['payload'] = int(grid[r, c])\n                                arrows.append(arrow)\n                                for cell in cells: used_cells.add(cell)\n                                break\n            # Horizontal bar with payload at center\n            if c-1 >= 0 and c+1 < w and (r, c-1) in one_positions and (r, c+1) in one_positions:\n                if (r, c-1) not in used_cells and (r, c+1) not in used_cells:\n                    for dr in [-1, 1]:\n                        nr = r + dr\n                        if 0 <= nr < h and (nr, c) in one_positions and (nr, c) not in used_cells:\n                            cells = [(r,c-1), (r,c), (r,c+1), (nr,c)]\n                            arrow = classify_t(cells)\n                            if arrow:\n                                arrow['payload'] = int(grid[r, c])\n                                arrows.append(arrow)\n                                for cell in cells: used_cells.add(cell)\n                                break\n\n    # === Find L-shape rotation indicator ===\n    l_shape_dir = None\n    l_cells = set()\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    for color, count in zip(unique_colors, counts):\n        if color == 1 or count != 5: continue\n        cells = [tuple(int(x) for x in pos) for pos in np.argwhere(grid == int(color))]\n        if any(c in used_cells for c in cells): continue\n        row_counts = Counter(r for r, c in cells)\n        col_counts = Counter(c for r, c in cells)\n        found = False\n        for row, cnt in row_counts.items():\n            if cnt == 3:\n                bar = sorted([(r, c) for r, c in cells if r == row], key=lambda x: x[1])\n                bar_cols = [c for _, c in bar]\n                if bar_cols == list(range(bar_cols[0], bar_cols[0]+3)):\n                    ext = [(r, c) for r, c in cells if r != row]\n                    ext_cols = set(c for _, c in ext)\n                    if len(ext_cols) == 1:\n                        ec = ext_cols.pop()\n                        if ec == bar_cols[0]: l_shape_dir = 'LEFT'\n                        elif ec == bar_cols[2]: l_shape_dir = 'RIGHT'\n                        l_cells = set(cells)\n                        found = True\n                        break\n        if not found:\n            for col, cnt in col_counts.items():\n                if cnt == 3:\n                    bar = sorted([(r, c) for r, c in cells if c == col], key=lambda x: x[0])\n                    bar_rows = [r for r, _ in bar]\n                    if bar_rows == list(range(bar_rows[0], bar_rows[0]+3)):\n                        ext = [(r, c) for r, c in cells if c != col]\n                        ext_rows = set(r for r, _ in ext)\n                        if len(ext_rows) == 1:\n                            er = ext_rows.pop()\n                            if er == bar_rows[0]: l_shape_dir = 'TOP'\n                            elif er == bar_rows[2]: l_shape_dir = 'BOTTOM'\n                            l_cells = set(cells)\n                            found = True\n                            break\n        if found: break\n\n    # === Fill arrow cells with source color ===\n    filled = grid.copy()\n    all_arrow_cells = set()\n    for a in arrows:\n        for c in a['cells']:\n            all_arrow_cells.add(tuple(int(x) for x in c))\n\n    for a in arrows:\n        d = a['direction']\n        bar_r, bar_c = int(a['bar_center'][0]), int(a['bar_center'][1])\n        cells = [(int(r), int(c)) for r, c in a['cells']]\n\n        # Get bar endpoints (the two non-center cells of the bar)\n        if d in ('RIGHT', 'LEFT'):\n            bar_cells_list = [(r, c) for r, c in cells if c == bar_c]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n        else:\n            bar_cells_list = [(r, c) for r, c in cells if r == bar_r]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n\n        # Source = bar endpoints' neighbors in STEM direction\n        if d == 'RIGHT': src_nbrs = [(r, c+1) for r, c in bar_endpoints if c+1 < w]\n        elif d == 'LEFT': src_nbrs = [(r, c-1) for r, c in bar_endpoints if c-1 >= 0]\n        elif d == 'UP': src_nbrs = [(r-1, c) for r, c in bar_endpoints if r-1 >= 0]\n        elif d == 'DOWN': src_nbrs = [(r+1, c) for r, c in bar_endpoints if r+1 < h]\n\n        src_colors = [int(grid[r,c]) for r,c in src_nbrs \n                      if (r,c) not in all_arrow_cells and grid[r,c] != 1]\n\n        if src_colors:\n            for r, c in cells:\n                filled[r, c] = src_colors[0]\n\n    # Fill L-shape cells with surrounding color\n    for r, c in l_cells:\n        filled[r, c] = -1\n\n    for _ in range(max(h, w)):\n        changed = False\n        new_f = filled.copy()\n        for r in range(h):\n            for c in range(w):\n                if filled[r, c] == -1:\n                    neighbors = []\n                    for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n                        nr, nc = r+dr, c+dc\n                        if 0 <= nr < h and 0 <= nc < w and filled[nr, nc] != -1:\n                            neighbors.append(filled[nr, nc])\n                    if neighbors:\n                        new_f[r, c] = Counter(neighbors).most_common(1)[0][0]\n                        changed = True\n        filled = new_f\n        if not changed: break\n\n    # === Find connected components ===\n    region_map = np.zeros(filled.shape, dtype=int)\n    region_id = 0\n    region_colors = {}\n    for color in sorted(set(filled.flatten()) - {-1}):\n        mask = (filled == int(color))\n        lab, num = ndimage.label(mask)\n        for comp in range(1, num + 1):\n            region_id += 1\n            region_map[lab == comp] = region_id\n            region_colors[region_id] = int(color)\n\n    # === Determine per-region color mappings from arrows ===\n    region_new_color = {}\n    color_mapping_entries = {}\n\n    for a in arrows:\n        d = a['direction']\n        stem_r, stem_c = int(a['stem'][0]), int(a['stem'][1])\n        bar_r, bar_c = int(a['bar_center'][0]), int(a['bar_center'][1])\n        cells = [(int(r), int(c)) for r, c in a['cells']]\n\n        if d in ('RIGHT', 'LEFT'):\n            bar_cells_list = [(r, c) for r, c in cells if c == bar_c]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n        else:\n            bar_cells_list = [(r, c) for r, c in cells if r == bar_r]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n\n        if d == 'RIGHT': src_nbrs = [(r, c+1) for r, c in bar_endpoints if c+1 < w]\n        elif d == 'LEFT': src_nbrs = [(r, c-1) for r, c in bar_endpoints if c-1 >= 0]\n        elif d == 'UP': src_nbrs = [(r-1, c) for r, c in bar_endpoints if r-1 >= 0]\n        elif d == 'DOWN': src_nbrs = [(r+1, c) for r, c in bar_endpoints if r+1 < h]\n\n        src_colors = [int(grid[r,c]) for r,c in src_nbrs \n                      if (r,c) not in all_arrow_cells and grid[r,c] != 1]\n        src_color = src_colors[0] if src_colors else None\n\n        if d == 'RIGHT': tgt_pos = (stem_r, stem_c + 1)\n        elif d == 'LEFT': tgt_pos = (stem_r, stem_c - 1)\n        elif d == 'UP': tgt_pos = (stem_r - 1, stem_c)\n        elif d == 'DOWN': tgt_pos = (stem_r + 1, stem_c)\n\n        tr, tc = tgt_pos\n        if 0 <= tr < h and 0 <= tc < w:\n            tgt_rid = int(region_map[tr, tc])\n            tgt_color = region_colors.get(tgt_rid, -1)\n            new_color = a['payload'] if a['payload'] is not None else src_color\n\n            if new_color is not None:\n                region_new_color[tgt_rid] = new_color\n                if tgt_color not in color_mapping_entries:\n                    color_mapping_entries[tgt_color] = []\n                color_mapping_entries[tgt_color].append((new_color, tgt_rid))\n\n    # Apply per-region mappings\n    result = filled.copy()\n    for rid, new_c in region_new_color.items():\n        result[region_map == rid] = new_c\n\n    # For unmapped regions, use global color mapping (with proximity for conflicts)\n    for rid, old_c in region_colors.items():\n        if rid not in region_new_color and old_c in color_mapping_entries:\n            entries = color_mapping_entries[old_c]\n            if len(entries) == 1:\n                result[region_map == rid] = entries[0][0]\n            else:\n                rid_cells = np.argwhere(region_map == rid)\n                centroid = rid_cells.mean(axis=0)\n                best_dist = float('inf')\n                best_color = entries[0][0]\n                for new_c, tgt_rid in entries:\n                    tgt_cells = np.argwhere(region_map == tgt_rid)\n                    tgt_centroid = tgt_cells.mean(axis=0)\n                    dist = np.sqrt(((centroid - tgt_centroid)**2).sum())\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_color = new_c\n                result[region_map == rid] = best_color\n\n    # === Apply rotation ===\n    if l_shape_dir == 'RIGHT':\n        result = np.rot90(result, k=1)   # CCW\n    elif l_shape_dir == 'LEFT':\n        result = np.rot90(result, k=-1)  # CW\n\n    return result.tolist()\n"}, {"success": false, "output": "[[3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6], [3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6], [3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6], [3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6], [3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6], [3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6], [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 6, 6, 6, 6], [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 6, 6, 6, 6], [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 6, 6, 6, 6], [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 6, 6, 6, 6], [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 6, 6, 6, 6], [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 6, 6, 6, 6], [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 6, 6, 6, 6], [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 6, 6, 6, 6], [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 6, 6, 6, 6], [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 6, 6, 6, 6], [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 6, 6, 6, 6], [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 6, 6, 6, 6], [3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6], [3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6], [3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6], [3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6], [3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6], [3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6]]", "soft_score": 0.0, "error": null, "code": "\ndef transform(grid_list):\n    \"\"\"Transform input grid using T-arrow color mapping and optional rotation.\n\n    The input grid contains:\n    1. Colored regions (possibly with staircase boundaries)\n    2. T-shaped arrows made of 1s (with optional payload color at bar center)\n    3. Optional L-shaped rotation indicator (5 cells)\n\n    The transformation:\n    1. Detect T-arrows and determine color flow direction\n    2. Fill arrow cells with source region color\n    3. Find connected color regions\n    4. Apply per-region color mapping based on arrows\n    5. Optionally rotate the grid based on L-shape indicator\n    \"\"\"\n    import numpy as np\n    from scipy import ndimage\n    from collections import Counter\n\n    grid = np.array(grid_list)\n    h, w = grid.shape\n\n    # === Find T-arrows ===\n    arrows = []\n    used_cells = set()\n    ones_mask = (grid == 1)\n    labeled, num_components = ndimage.label(ones_mask)\n\n    def classify_t(cells):\n        cells_set = set(cells)\n        rows = [r for r, c in cells]\n        cols = [c for r, c in cells]\n        min_r, max_r = min(rows), max(rows)\n        min_c, max_c = min(cols), max(cols)\n        bh, bw = max_r - min_r + 1, max_c - min_c + 1\n\n        if bh == 3 and bw == 2:\n            col_counts = Counter(c for r, c in cells)\n            bar_col = stem_col = None\n            for col, cnt in col_counts.items():\n                if cnt == 3: bar_col = col\n                elif cnt == 1: stem_col = col\n            if bar_col is None or stem_col is None: return None\n            stem_r = next(r for r, c in cells if c == stem_col)\n            if (stem_r, bar_col) not in cells_set: return None\n            direction = 'RIGHT' if stem_col > bar_col else 'LEFT'\n            return {'direction': direction, 'payload': None, 'stem': (stem_r, stem_col),\n                    'bar_center': (stem_r, bar_col), 'cells': list(cells)}\n        elif bh == 2 and bw == 3:\n            row_counts = Counter(r for r, c in cells)\n            bar_row = stem_row = None\n            for row, cnt in row_counts.items():\n                if cnt == 3: bar_row = row\n                elif cnt == 1: stem_row = row\n            if bar_row is None or stem_row is None: return None\n            stem_c = next(c for r, c in cells if r == stem_row)\n            if (bar_row, stem_c) not in cells_set: return None\n            direction = 'UP' if stem_row < bar_row else 'DOWN'\n            return {'direction': direction, 'payload': None, 'stem': (stem_row, stem_c),\n                    'bar_center': (bar_row, stem_c), 'cells': list(cells)}\n        return None\n\n    # Standard arrows (4 connected 1-cells)\n    for comp in range(1, num_components + 1):\n        cells = [tuple(int(x) for x in pos) for pos in np.argwhere(labeled == comp)]\n        if len(cells) == 4:\n            arrow = classify_t(cells)\n            if arrow:\n                arrows.append(arrow)\n                for c in cells: used_cells.add(c)\n\n    # Payload arrows (3 isolated 1-cells + 1 non-1 center)\n    one_positions = set(tuple(int(x) for x in pos) for pos in np.argwhere(ones_mask))\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] == 1 or (r, c) in used_cells: continue\n            # Vertical bar with payload at center\n            if r-1 >= 0 and r+1 < h and (r-1, c) in one_positions and (r+1, c) in one_positions:\n                if (r-1, c) not in used_cells and (r+1, c) not in used_cells:\n                    for dc in [1, -1]:\n                        nc = c + dc\n                        if 0 <= nc < w and (r, nc) in one_positions and (r, nc) not in used_cells:\n                            cells = [(r-1,c), (r,c), (r+1,c), (r,nc)]\n                            arrow = classify_t(cells)\n                            if arrow:\n                                arrow['payload'] = int(grid[r, c])\n                                arrows.append(arrow)\n                                for cell in cells: used_cells.add(cell)\n                                break\n            # Horizontal bar with payload at center\n            if c-1 >= 0 and c+1 < w and (r, c-1) in one_positions and (r, c+1) in one_positions:\n                if (r, c-1) not in used_cells and (r, c+1) not in used_cells:\n                    for dr in [-1, 1]:\n                        nr = r + dr\n                        if 0 <= nr < h and (nr, c) in one_positions and (nr, c) not in used_cells:\n                            cells = [(r,c-1), (r,c), (r,c+1), (nr,c)]\n                            arrow = classify_t(cells)\n                            if arrow:\n                                arrow['payload'] = int(grid[r, c])\n                                arrows.append(arrow)\n                                for cell in cells: used_cells.add(cell)\n                                break\n\n    # === Find L-shape rotation indicator ===\n    l_shape_dir = None\n    l_cells = set()\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    for color, count in zip(unique_colors, counts):\n        if color == 1 or count != 5: continue\n        cells = [tuple(int(x) for x in pos) for pos in np.argwhere(grid == int(color))]\n        if any(c in used_cells for c in cells): continue\n        row_counts = Counter(r for r, c in cells)\n        col_counts = Counter(c for r, c in cells)\n        found = False\n        for row, cnt in row_counts.items():\n            if cnt == 3:\n                bar = sorted([(r, c) for r, c in cells if r == row], key=lambda x: x[1])\n                bar_cols = [c for _, c in bar]\n                if bar_cols == list(range(bar_cols[0], bar_cols[0]+3)):\n                    ext = [(r, c) for r, c in cells if r != row]\n                    ext_cols = set(c for _, c in ext)\n                    if len(ext_cols) == 1:\n                        ec = ext_cols.pop()\n                        if ec == bar_cols[0]: l_shape_dir = 'LEFT'\n                        elif ec == bar_cols[2]: l_shape_dir = 'RIGHT'\n                        l_cells = set(cells)\n                        found = True\n                        break\n        if not found:\n            for col, cnt in col_counts.items():\n                if cnt == 3:\n                    bar = sorted([(r, c) for r, c in cells if c == col], key=lambda x: x[0])\n                    bar_rows = [r for r, _ in bar]\n                    if bar_rows == list(range(bar_rows[0], bar_rows[0]+3)):\n                        ext = [(r, c) for r, c in cells if c != col]\n                        ext_rows = set(r for r, _ in ext)\n                        if len(ext_rows) == 1:\n                            er = ext_rows.pop()\n                            if er == bar_rows[0]: l_shape_dir = 'TOP'\n                            elif er == bar_rows[2]: l_shape_dir = 'BOTTOM'\n                            l_cells = set(cells)\n                            found = True\n                            break\n        if found: break\n\n    # === Fill arrow cells with source color ===\n    filled = grid.copy()\n    all_arrow_cells = set()\n    for a in arrows:\n        for c in a['cells']:\n            all_arrow_cells.add(tuple(int(x) for x in c))\n\n    for a in arrows:\n        d = a['direction']\n        bar_r, bar_c = int(a['bar_center'][0]), int(a['bar_center'][1])\n        cells = [(int(r), int(c)) for r, c in a['cells']]\n\n        # Get bar endpoints (the two non-center cells of the bar)\n        if d in ('RIGHT', 'LEFT'):\n            bar_cells_list = [(r, c) for r, c in cells if c == bar_c]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n        else:\n            bar_cells_list = [(r, c) for r, c in cells if r == bar_r]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n\n        # Source = bar endpoints' neighbors in STEM direction\n        if d == 'RIGHT': src_nbrs = [(r, c+1) for r, c in bar_endpoints if c+1 < w]\n        elif d == 'LEFT': src_nbrs = [(r, c-1) for r, c in bar_endpoints if c-1 >= 0]\n        elif d == 'UP': src_nbrs = [(r-1, c) for r, c in bar_endpoints if r-1 >= 0]\n        elif d == 'DOWN': src_nbrs = [(r+1, c) for r, c in bar_endpoints if r+1 < h]\n\n        src_colors = [int(grid[r,c]) for r,c in src_nbrs \n                      if (r,c) not in all_arrow_cells and grid[r,c] != 1]\n\n        if src_colors:\n            for r, c in cells:\n                filled[r, c] = src_colors[0]\n\n    # Fill L-shape cells with surrounding color\n    for r, c in l_cells:\n        filled[r, c] = -1\n\n    for _ in range(max(h, w)):\n        changed = False\n        new_f = filled.copy()\n        for r in range(h):\n            for c in range(w):\n                if filled[r, c] == -1:\n                    neighbors = []\n                    for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n                        nr, nc = r+dr, c+dc\n                        if 0 <= nr < h and 0 <= nc < w and filled[nr, nc] != -1:\n                            neighbors.append(filled[nr, nc])\n                    if neighbors:\n                        new_f[r, c] = Counter(neighbors).most_common(1)[0][0]\n                        changed = True\n        filled = new_f\n        if not changed: break\n\n    # === Find connected components ===\n    region_map = np.zeros(filled.shape, dtype=int)\n    region_id = 0\n    region_colors = {}\n    for color in sorted(set(filled.flatten()) - {-1}):\n        mask = (filled == int(color))\n        lab, num = ndimage.label(mask)\n        for comp in range(1, num + 1):\n            region_id += 1\n            region_map[lab == comp] = region_id\n            region_colors[region_id] = int(color)\n\n    # === Determine per-region color mappings from arrows ===\n    region_new_color = {}\n    color_mapping_entries = {}\n\n    for a in arrows:\n        d = a['direction']\n        stem_r, stem_c = int(a['stem'][0]), int(a['stem'][1])\n        bar_r, bar_c = int(a['bar_center'][0]), int(a['bar_center'][1])\n        cells = [(int(r), int(c)) for r, c in a['cells']]\n\n        if d in ('RIGHT', 'LEFT'):\n            bar_cells_list = [(r, c) for r, c in cells if c == bar_c]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n        else:\n            bar_cells_list = [(r, c) for r, c in cells if r == bar_r]\n            bar_endpoints = [bc for bc in bar_cells_list if bc != (bar_r, bar_c)]\n\n        if d == 'RIGHT': src_nbrs = [(r, c+1) for r, c in bar_endpoints if c+1 < w]\n        elif d == 'LEFT': src_nbrs = [(r, c-1) for r, c in bar_endpoints if c-1 >= 0]\n        elif d == 'UP': src_nbrs = [(r-1, c) for r, c in bar_endpoints if r-1 >= 0]\n        elif d == 'DOWN': src_nbrs = [(r+1, c) for r, c in bar_endpoints if r+1 < h]\n\n        src_colors = [int(grid[r,c]) for r,c in src_nbrs \n                      if (r,c) not in all_arrow_cells and grid[r,c] != 1]\n        src_color = src_colors[0] if src_colors else None\n\n        if d == 'RIGHT': tgt_pos = (stem_r, stem_c + 1)\n        elif d == 'LEFT': tgt_pos = (stem_r, stem_c - 1)\n        elif d == 'UP': tgt_pos = (stem_r - 1, stem_c)\n        elif d == 'DOWN': tgt_pos = (stem_r + 1, stem_c)\n\n        tr, tc = tgt_pos\n        if 0 <= tr < h and 0 <= tc < w:\n            tgt_rid = int(region_map[tr, tc])\n            tgt_color = region_colors.get(tgt_rid, -1)\n            new_color = a['payload'] if a['payload'] is not None else src_color\n\n            if new_color is not None:\n                region_new_color[tgt_rid] = new_color\n                if tgt_color not in color_mapping_entries:\n                    color_mapping_entries[tgt_color] = []\n                color_mapping_entries[tgt_color].append((new_color, tgt_rid))\n\n    # Apply per-region mappings\n    result = filled.copy()\n    for rid, new_c in region_new_color.items():\n        result[region_map == rid] = new_c\n\n    # For unmapped regions, use global color mapping (with proximity for conflicts)\n    for rid, old_c in region_colors.items():\n        if rid not in region_new_color and old_c in color_mapping_entries:\n            entries = color_mapping_entries[old_c]\n            if len(entries) == 1:\n                result[region_map == rid] = entries[0][0]\n            else:\n                rid_cells = np.argwhere(region_map == rid)\n                centroid = rid_cells.mean(axis=0)\n                best_dist = float('inf')\n                best_color = entries[0][0]\n                for new_c, tgt_rid in entries:\n                    tgt_cells = np.argwhere(region_map == tgt_rid)\n                    tgt_centroid = tgt_cells.mean(axis=0)\n                    dist = np.sqrt(((centroid - tgt_centroid)**2).sum())\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_color = new_c\n                result[region_map == rid] = best_color\n\n    # === Apply rotation ===\n    if l_shape_dir == 'RIGHT':\n        result = np.rot90(result, k=1)   # CCW\n    elif l_shape_dir == 'LEFT':\n        result = np.rot90(result, k=-1)  # CW\n\n    return result.tolist()\n"}], "agent_usage": [{"input_tokens": 6300797, "input_tokens_details": {"cached_tokens": 6157541}, "output_tokens": 105939, "output_tokens_details": {"reasoning_tokens": -83}, "total_tokens": 106024, "inference_count": 83, "cache_creation": {"ephemeral_1h_input_tokens": 143171, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 143171, "inference_geo": ["global"], "service_tier": ["standard"]}, {"input_tokens": 5019295, "input_tokens_details": {"cached_tokens": 4887641}, "output_tokens": 93624, "output_tokens_details": {"reasoning_tokens": -73}, "total_tokens": 93699, "inference_count": 73, "cache_creation": {"ephemeral_1h_input_tokens": 131579, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 131579, "inference_geo": ["global"], "service_tier": ["standard"]}, {"input_tokens": 13025277, "input_tokens_details": {"cached_tokens": 12843707}, "output_tokens": 134956, "output_tokens_details": {"reasoning_tokens": -138}, "total_tokens": 135096, "inference_count": 138, "cache_creation": {"ephemeral_1h_input_tokens": 181430, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 181430, "inference_geo": ["global"], "service_tier": ["standard"]}, {"input_tokens": 3556874, "input_tokens_details": {"cached_tokens": 3446461}, "output_tokens": 74595, "output_tokens_details": {"reasoning_tokens": -64}, "total_tokens": 74661, "inference_count": 64, "cache_creation": {"ephemeral_1h_input_tokens": 110347, "ephemeral_5m_input_tokens": 0}, "cache_creation_input_tokens": 110347, "inference_geo": ["global"], "service_tier": ["standard"]}], "time_taken": 6893.748728275299, "num_agents_used": 4, "model": "anthropic/claude-opus-4-6", "reasoning_effort": "high", "error": null, "problem_id": "21897d95", "attempt_id": 0, "num": 0, "iteration": 83}